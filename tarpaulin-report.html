<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","app.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse axum::{\n    Form, Json, Router,\n    body::Bytes,\n    extract::{Multipart, Path, Query, State},\n    http::{StatusCode, header},\n    middleware,\n    response::{Html, IntoResponse, Redirect, Response},\n    routing::{get, post},\n};\nuse axum_extra::extract::cookie::CookieJar;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::path::PathBuf;\nuse std::sync::{Arc, Mutex};\nuse tokio::net::TcpListener;\nuse tower_http::services::ServeDir;\n\nuse crate::downloader;\nuse crate::graph::{GraphOptions, GraphType, create_graph};\nuse crate::login::{\n    self, User, UserCredentials, serve_change_password_page, serve_forgot_password_page,\n    serve_reset_password_page,\n};\nuse crate::saving;\nuse crate::spreadsheet::{FunctionName, Operand, ParsedRHS, Spreadsheet};\n\n/// Application state shared across all requests\n///\n/// This structure contains the shared state for the web application, including:\n/// - The current spreadsheet in memory\n/// - The original file path for saving/loading operations\n/// - A set of public spreadsheets that can be accessed without authentication\npub struct AppState {\n    /// The current spreadsheet data, wrapped in a mutex for thread-safe access\n    pub sheet: Mutex\u003cBox\u003cSpreadsheet\u003e\u003e,\n\n    /// The original file path of the loaded spreadsheet (if any)\n    /// Used to save the spreadsheet back to its source location\n    pub original_path: Mutex\u003cOption\u003cString\u003e\u003e,\n\n    /// A set of publicly accessible spreadsheets, identified by their paths\n    /// Format: \"username/sheetname\"\n    pub public_sheets: Mutex\u003cHashSet\u003cString\u003e\u003e,\n}\n\n/// Data structure for cell updates from the client\n#[derive(Debug, Deserialize)]\nstruct CellUpdate {\n    /// The right-hand side formula or value to be parsed\n    rhs: String,\n    /// The cell identifier (e.g., \"A1\", \"B2\")\n    cell: String,\n}\n\n/// Response data structure for cell updates\n#[derive(Serialize)]\nstruct CellResponse {\n    /// Status message indicating success or the error that occurred\n    status: String,\n    /// The calculated cell value (if successful)\n    value: Option\u003ci32\u003e,\n}\n\n/// Query parameters for saving a spreadsheet\n#[derive(Deserialize)]\nstruct SaveQuery {\n    /// Filename for the spreadsheet\n    filename: String,\n}\n\n/// Query parameters for sheet creation/initialization\n#[derive(Deserialize)]\nstruct SheetQuery {\n    /// Number of rows to create (optional)\n    rows: Option\u003ci32\u003e,\n    /// Number of columns to create (optional)\n    cols: Option\u003ci32\u003e,\n}\n\n/// Response structure for save operations\n#[derive(Serialize)]\nstruct SaveResponse {\n    /// Status of the operation (\"ok\" or \"error\")\n    status: String,\n    /// Optional message with additional details, especially for errors\n    message: Option\u003cString\u003e,\n}\n\n/// Query parameters for operations that require a filename\n#[derive(Debug, Deserialize)]\nstruct FileNameQuery {\n    /// Name of the file\n    name: String,\n}\n\n/// Request data for graph generation\n#[derive(Debug, Deserialize)]\nstruct GraphRequest {\n    /// Cell range for X-axis values (e.g., \"A1:A10\")\n    x_range: String,\n    /// Cell range for Y-axis values (e.g., \"B1:B10\")\n    y_range: String,\n    /// Title for the graph\n    title: String,\n    /// Label for the X-axis\n    x_label: String,\n    /// Label for the Y-axis\n    y_label: String,\n    /// Type of graph (\"Line\", \"Bar\", \"Scatter\", \"Area\")\n    graph_type: String,\n}\n\n/// Data structure for listing spreadsheets\n#[derive(Debug, Serialize, Deserialize)]\nstruct SheetEntry {\n    /// Name of the spreadsheet\n    name: String,\n    /// Visibility status (\"public\" or \"private\")\n    status: String,\n}\n\n/// Form data for changing spreadsheet visibility status\n#[derive(Debug, Deserialize)]\nstruct ChangeStatusForm {\n    /// New status value (\"public\" or \"private\")\n    status: String,\n}\n\n/// Main application entry point\n///\n/// Initializes the database, creates the default spreadsheet, and starts the web server.\n/// Sets up both public and authenticated routes for the application.\n///\n/// # Arguments\n/// * `rows` - Number of rows for the initial spreadsheet\n/// * `cols` - Number of columns for the initial spreadsheet\n///\n/// # Returns\n/// * `Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e` - Success or error\npub async fn run(rows: i16, cols: i16) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Initialize the database\n    login::init_database()?;\n\n    // Create spreadsheet\n    let sheet = Spreadsheet::spreadsheet_create(rows, cols).expect(\"Failed to create spreadsheet\");\n\n    // Setup app state\n    let app_state = Arc::new(AppState {\n        sheet: Mutex::new(sheet),\n        original_path: Mutex::new(None),\n        public_sheets: Mutex::new(HashSet::new()),\n    });\n\n    // 1) Build the public (no‐auth) routes\n    let public = Router::new()\n        .route(\"/\", get(serve_landing))\n        .route(\n            \"/login\",\n            get(login::serve_login_page).post(login::handle_login),\n        )\n        .route(\n            \"/signup\",\n            get(login::serve_signup_page).post(login::handle_signup),\n        )\n        .route(\"/logout\", get(login::handle_logout))\n        .route(\n            \"/forgot-password\",\n            get(serve_forgot_password_page).post(login::handle_forgot_password),\n        )\n        .route(\n            \"/reset-password\",\n            get(serve_reset_password_page).post(login::handle_reset_password),\n        )\n        .route(\n            \"/change-password\",\n            get(serve_change_password_page).post(login::handle_change_password),\n        )\n        // Public routes for accessing sheets\n        .route(\"/:username/:sheet_name\", get(load_user_file))\n        // Add these API endpoints to public routes for public sheets\n        .route(\"/api/sheet\", get(get_sheet_data))\n        .route(\"/api/cell/:cell_name\", get(get_cell))\n        .route(\"/api/sheet_info\", get(get_sheet_info))\n        .nest_service(\"/static\", ServeDir::new(\"static\"));\n\n    // 2) Build the protected routes and apply auth‐middleware\n    let protected = Router::new()\n        // spreadsheet endpoints\n        .route(\"/sheet\", get(serve_sheet))\n        // .route(\"/api/sheet\", get(get_sheet_data))\n        // .route(\"/api/cell/:cell_name\", get(get_cell))\n        // .route(\"/api/sheet_info\", get(get_sheet_info))\n        .route(\"/api/update_cell\", post(update_cell))\n        .route(\"/api/save\", post(save_spreadsheet))\n        .route(\"/api/export\", post(export_spreadsheet))\n        .route(\"/api/load\", post(load_spreadsheet))\n        .route(\"/api/graph\", post(generate_graph))\n        .route(\"/api/download/csv\", get(download_csv))\n        .route(\"/api/download/xlsx\", get(download_xlsx))\n        .route(\"/api/save_with_name\", post(save_spreadsheet_with_name))\n        // user file routes\n        .route(\"/:username\", get(login::list_files))\n        .route(\n            \"/:username/create\",\n            get(login::serve_create_sheet_form).post(login::handle_create_sheet),\n        )\n        .route(\"/:username/:sheet_name/status\", post(change_sheet_status))\n        .route(\n            \"/:username/:sheet_name/delete\",\n            post(login::handle_delete_sheet),\n        )\n        // only these get require_auth\n        .layer(middleware::from_fn(login::require_auth));\n\n    // 3) Merge and attach shared state\n    let app = Router::new()\n        .merge(public)\n        .merge(protected)\n        .with_state(app_state);\n\n    // Start server\n    let listener = TcpListener::bind(\"0.0.0.0:3000\").await?;\n    println!(\"Listening on http://127.0.0.1:3000\");\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n\n/// Generate a graph based on spreadsheet data\n///\n/// Creates and returns a graph image (PNG format) based on data ranges from the spreadsheet.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n/// * `payload` - Graph configuration including ranges, labels, and graph type\n///\n/// # Returns\n/// * A PNG image of the requested graph, or an error message\nasync fn generate_graph(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(payload): Json\u003cGraphRequest\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    let graph_type = match payload.graph_type.as_str() {\n        \"Line\" =\u003e GraphType::Line,\n        \"Bar\" =\u003e GraphType::Bar,\n        \"Scatter\" =\u003e GraphType::Scatter,\n        \"Area\" =\u003e GraphType::Area,\n        _ =\u003e GraphType::Line,\n    };\n\n    let options = GraphOptions {\n        title: payload.title,\n        x_label: payload.x_label,\n        y_label: payload.y_label,\n        width: 800,\n        height: 600,\n        graph_type,\n    };\n\n    match create_graph(\u0026sheet, \u0026payload.x_range, \u0026payload.y_range, options) {\n        Ok(img_data) =\u003e ([(\"Content-Type\", \"image/png\")], img_data).into_response(),\n        Err(e) =\u003e (\n            StatusCode::BAD_REQUEST,\n            format!(\"Failed to create graph: {}\", e),\n        )\n            .into_response(),\n    }\n}\n\n/// Serve the landing page\n///\n/// Redirects to the login page.\n///\n/// # Returns\n/// * Redirect response to the login page\nasync fn serve_landing() -\u003e impl IntoResponse {\n    // Redirect to login page\n    Redirect::to(\"/login\")\n}\n\n/// Serve the spreadsheet application page\n///\n/// Optionally creates a new spreadsheet with the specified dimensions.\n/// Returns the HTML for the spreadsheet application.\n///\n/// # Arguments\n/// * `params` - Optional query parameters specifying sheet dimensions\n/// * `state` - Application state\n///\n/// # Returns\n/// * HTML content for the spreadsheet UI\nasync fn serve_sheet(\n    Query(params): Query\u003cSheetQuery\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e Html\u003c\u0026'static str\u003e {\n    if let (Some(rows), Some(cols)) = (params.rows, params.cols) {\n        if rows \u003e 0 \u0026\u0026 rows \u003c= 1000 \u0026\u0026 cols \u003e 0 \u0026\u0026 cols \u003c= 18278 {\n            let new_sheet = Spreadsheet::spreadsheet_create(rows as i16, cols as i16)\n                .expect(\"Failed to create spreadsheet with specified dimensions\");\n\n            let mut current_sheet = state.sheet.lock().unwrap();\n            *current_sheet = new_sheet;\n        }\n    }\n\n    Html(include_str!(\"./static/sheet.html\"))\n}\n\n/// Get spreadsheet data in JSON format\n///\n/// Returns the current spreadsheet data including all cells with values.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * JSON representation of the spreadsheet data\nasync fn get_sheet_data(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n    let rows = sheet.rows;\n    let cols = sheet.cols;\n\n    let mut cell_data = Vec::new();\n\n    for r in 1..=rows {\n        for c in 1..=cols {\n            let index = ((r - 1) * cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                cell_data.push(serde_json::json!({\n                    \"row\": r,\n                    \"col\": c,\n                    \"name\": Spreadsheet::get_cell_name(r, c),\n                    \"value\": cell.value,\n                    \"formula\": formula_to_string(\u0026cell.formula),  // Convert to string\n                    \"error\": cell.error,\n                }));\n            }\n        }\n    }\n\n    Json(serde_json::json!({\n        \"rows\": rows,\n        \"cols\": cols,\n        \"cells\": cell_data,\n    }))\n}\n\n/// Get data for a specific cell\n///\n/// Returns the value, formula and error status of a specific cell.\n///\n/// # Arguments\n/// * `cell_name` - Cell identifier (e.g., \"A1\", \"B2\")\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * JSON data for the requested cell or 404 if not found\nasync fn get_cell(\n    Path(cell_name): Path\u003cString\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026cell_name) {\n        let index = ((row - 1) * sheet.cols + (col - 1)) as usize;\n        if let Some(cell) = \u0026sheet.cells[index] {\n            return Json(serde_json::json!({\n                \"name\": cell_name,\n                \"value\": cell.value,\n                \"formula\": formula_to_string(\u0026cell.formula),  // Convert to string\n                \"error\": cell.error,\n            }))\n            .into_response();\n        }\n    }\n\n    StatusCode::NOT_FOUND.into_response()\n}\n\n/// Update a cell's value in the spreadsheet\n///\n/// Parses the input formula/value and updates the specified cell.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n/// * `payload` - Cell update data including the cell name and formula/value\n///\n/// # Returns\n/// * JSON response with update status and the new cell value\nasync fn update_cell(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(payload): Json\u003cCellUpdate\u003e,\n) -\u003e impl IntoResponse {\n    // println!(\"(DEBUG) Received update_cell payload: {:?}\", payload);\n    let mut sheet = state.sheet.lock().unwrap();\n    let mut status = String::new();\n\n    // Parse the cell name\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026payload.cell) {\n        // println!(\"(DEBUG) Parsed cell name: row={}, col={}\", row, col);\n\n        // Parse the formula string into ParsedRHS using is_valid_command\n        let (is_valid, _, _, parsed_rhs) = sheet.is_valid_command(\u0026payload.cell, \u0026payload.rhs);\n\n        if is_valid {\n            // println!(\"(DEBUG) Valid formula parsed: {:?}\", parsed_rhs);\n            sheet.spreadsheet_set_cell_value(row, col, parsed_rhs, \u0026mut status);\n        } else {\n            status = format!(\"Invalid formula: {}\", payload.rhs);\n            // println!(\"(DEBUG) {}\", status);\n        }\n    } else {\n        status = format!(\"Invalid cell identifier: {}\", payload.cell);\n        // println!(\"(DEBUG) {}\", status);\n    }\n\n    // Retrieve the updated cell value and print its state\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026payload.cell) {\n        let index = ((row - 1) * sheet.cols + (col - 1)) as usize;\n        if let Some(cell) = \u0026sheet.cells[index] {\n            // println!(\n            //     \"(DEBUG) Final state of cell {}: value = {}, formula = {:?}, error = {}\",\n            //     payload.cell, cell.value, cell.formula, cell.error\n            // );\n            Json(CellResponse {\n                status,\n                value: Some(cell.value),\n            })\n            .into_response()\n        } else {\n            // println!(\"(DEBUG) Missing cell at index {}\", index);\n            Json(CellResponse {\n                status: \"Cell not found\".into(),\n                value: None,\n            })\n            .into_response()\n        }\n    } else {\n        // println!(\n        //     \"(DEBUG) Second parsing of cell identifier failed for '{}'\",\n        //     payload.cell\n        // );\n        Json(CellResponse {\n            status,\n            value: None,\n        })\n        .into_response()\n    }\n}\n\n/// Save the current spreadsheet\n///\n/// Saves the spreadsheet to the provided filename or to the original path.\n///\n/// # Arguments\n/// * `params` - Query parameters containing the filename\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * JSON response indicating success or failure\nasync fn save_spreadsheet(\n    Query(params): Query\u003cSaveQuery\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e impl IntoResponse {\n    // Get the sheet and original path\n    let sheet = state.sheet.lock().unwrap();\n    let mut original_path = state.original_path.lock().unwrap();\n\n    // Get filename from query params or use original path if none provided\n    let filename = if params.filename.is_empty() {\n        // Try to use the original path\n        match original_path.as_ref() {\n            Some(path) =\u003e path.clone(),\n            None =\u003e {\n                return Json(SaveResponse {\n                    status: \"error\".to_string(),\n                    message: Some(\n                        \"No filename provided and no original path available\".to_string(),\n                    ),\n                })\n                .into_response();\n            }\n        }\n    } else {\n        // For new sheets, update the original path with the provided filename\n        let new_filename = params.filename.clone();\n        *original_path = Some(new_filename.clone());\n        new_filename\n    };\n\n    match saving::save_spreadsheet(\u0026sheet, \u0026filename) {\n        Ok(_) =\u003e Json(SaveResponse {\n            status: \"ok\".to_string(),\n            message: None,\n        })\n        .into_response(),\n        Err(e) =\u003e {\n            // If save fails, don't keep the path for new sheets\n            if original_path.as_ref().unwrap() == \u0026filename \u0026\u0026 params.filename == filename {\n                *original_path = None;\n            }\n\n            Json(SaveResponse {\n                status: \"error\".to_string(),\n                message: Some(e.to_string()),\n            })\n            .into_response()\n        }\n    }\n}\n\n/// Save spreadsheet to a user's directory with a specific name\n///\n/// Saves the current spreadsheet to the authenticated user's directory\n/// with the specified name.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n/// * `username` - The authenticated username\n/// * `query` - Form data containing the filename\n///\n/// # Returns\n/// * JSON response indicating success or failure\nasync fn save_spreadsheet_with_name(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    username: axum::extract::Extension\u003cString\u003e,\n    Form(query): Form\u003cFileNameQuery\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    // Create user directory if it doesn't exist\n    let user_dir = format!(\"database/{}\", username.0);\n    let _ = std::fs::create_dir_all(\u0026user_dir);\n\n    // Build the filename\n    let filename = if query.name.trim().is_empty() {\n        \"spreadsheet.bin.gz\".to_string()\n    } else {\n        if !query.name.ends_with(\".bin.gz\") {\n            format!(\"{}.bin.gz\", query.name)\n        } else {\n            query.name\n        }\n    };\n\n    let path = format!(\"{}/{}\", user_dir, filename);\n\n    // Update original path\n    let mut original_path = state.original_path.lock().unwrap();\n    *original_path = Some(path.clone());\n\n    // Save the file\n    match saving::save_spreadsheet(\u0026sheet, \u0026path) {\n        Ok(_) =\u003e Json(SaveResponse {\n            status: \"ok\".to_string(),\n            message: None,\n        })\n        .into_response(),\n        Err(e) =\u003e {\n            *original_path = None;\n            Json(SaveResponse {\n                status: \"error\".to_string(),\n                message: Some(e.to_string()),\n            })\n            .into_response()\n        }\n    }\n}\n\n/// Load a user's spreadsheet file\n///\n/// Loads a spreadsheet file from a user's directory and serves the spreadsheet UI.\n/// Checks for public/private access permissions.\n///\n/// # Arguments\n/// * `username` and `filename` - Path parameters identifying the file\n/// * `jar` - Cookie jar containing session information\n/// * `state` - Application state\n///\n/// # Returns\n/// * Spreadsheet UI if authorized, or redirects to login\nasync fn load_user_file(\n    axum::extract::Path((username, filename)): axum::extract::Path\u003c(String, String)\u003e,\n    jar: CookieJar, // New parameter\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e impl IntoResponse {\n    let path = format!(\"database/{}/{}.bin.gz\", username, filename);\n\n    // Check if file exists\n    if !std::path::Path::new(\u0026path).exists() {\n        return Html(format!(\"\u003ch1\u003eFile not found\u003c/h1\u003e\u003cp\u003ePath: {}\u003c/p\u003e\", path)).into_response();\n    }\n\n    // Try to validate the session directly from the cookie.\n    let current_user = jar\n        .get(\"session\")\n        .and_then(|cookie| crate::login::validate_session(cookie.value()));\n\n    // If current user exists and matches the owner, then mark as owner.\n    let is_owner = current_user.as_deref() == Some(\u0026username);\n\n    // If not owner, check if the sheet is public.\n    let mut is_public = false;\n    if !is_owner {\n        let list_path = format!(\"database/{}/list.json\", username);\n        if let Ok(data) = std::fs::read_to_string(\u0026list_path) {\n            if let Ok(entries) = serde_json::from_str::\u003cVec\u003ccrate::login::SheetEntry\u003e\u003e(\u0026data) {\n                is_public = entries\n                    .iter()\n                    .any(|entry| entry.name == filename \u0026\u0026 entry.status == \"public\");\n                if !is_public {\n                    return Redirect::to(\"/login\").into_response();\n                }\n            } else {\n                return Redirect::to(\"/login\").into_response();\n            }\n        } else {\n            return Redirect::to(\"/login\").into_response();\n        }\n    }\n\n    // Load the file as before\n    match std::fs::read(\u0026path) {\n        Ok(file_data) =\u003e {\n            match deserialize_from_memory(\u0026file_data) {\n                Ok(loaded_sheet) =\u003e {\n                    {\n                        let mut sheet_guard = state.sheet.lock().unwrap();\n                        *sheet_guard = loaded_sheet;\n                        let mut path_guard = state.original_path.lock().unwrap();\n                        *path_guard = Some(path);\n                    }\n                    // If the sheet is public, record it.\n                    if is_public {\n                        let mut public_sheets = state.public_sheets.lock().unwrap();\n                        public_sheets.insert(format!(\"{}/{}\", username, filename));\n                    }\n\n                    // Serve the sheet\n                    serve_sheet(\n                        Query(SheetQuery {\n                            rows: None,\n                            cols: None,\n                        }),\n                        State(Arc::clone(\u0026state)),\n                    )\n                    .await\n                    .into_response()\n                }\n                Err(_) =\u003e Html(\"\u003ch1\u003eError loading spreadsheet\u003c/h1\u003e\".to_string()).into_response(),\n            }\n        }\n        Err(_) =\u003e Html(\"\u003ch1\u003eError reading file\u003c/h1\u003e\".to_string()).into_response(),\n    }\n}\n\n/// Change the visibility status of a spreadsheet\n///\n/// Updates a spreadsheet's status to either \"public\" or \"private\".\n///\n/// # Arguments\n/// * `username` and `filename` - Path parameters identifying the file\n/// * `current_user` - The authenticated username\n/// * `form` - Form data containing the new status\n///\n/// # Returns\n/// * Redirect back to user's sheet list or error response\nasync fn change_sheet_status(\n    axum::extract::Path((username, filename)): axum::extract::Path\u003c(String, String)\u003e,\n    current_user: axum::extract::Extension\u003cString\u003e,\n    Form(form): Form\u003cChangeStatusForm\u003e,\n) -\u003e impl IntoResponse {\n    // Security check - only owner can change status\n    if username != current_user.0 {\n        return (StatusCode::UNAUTHORIZED, \"Unauthorized\").into_response();\n    }\n\n    // Ensure status is valid\n    if form.status != \"public\" \u0026\u0026 form.status != \"private\" {\n        return (StatusCode::BAD_REQUEST, \"Invalid status\").into_response();\n    }\n\n    // Update list.json\n    let list_path = format!(\"database/{}/list.json\", username);\n    let mut entries = if std::path::Path::new(\u0026list_path).exists() {\n        match std::fs::read_to_string(\u0026list_path) {\n            Ok(data) =\u003e match serde_json::from_str::\u003cVec\u003cSheetEntry\u003e\u003e(\u0026data) {\n                Ok(entries) =\u003e entries,\n                Err(_) =\u003e Vec::new(),\n            },\n            Err(_) =\u003e Vec::new(),\n        }\n    } else {\n        Vec::new()\n    };\n\n    // Find and update the entry\n    let mut found = false;\n    for entry in \u0026mut entries {\n        if entry.name == filename {\n            entry.status = form.status.clone();\n            found = true;\n            break;\n        }\n    }\n\n    // If not found, add a new entry\n    if !found {\n        entries.push(SheetEntry {\n            name: filename,\n            status: form.status,\n        });\n    }\n\n    // Save the updated list\n    if let Ok(json) = serde_json::to_string_pretty(\u0026entries) {\n        if std::fs::write(\u0026list_path, json).is_err() {\n            return (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                \"Failed to update sheet status\",\n            )\n                .into_response();\n        }\n    } else {\n        return (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"Failed to serialize sheet data\",\n        )\n            .into_response();\n    }\n\n    // Redirect back to the user's sheet list\n    Redirect::to(\u0026format!(\"/{}\", username)).into_response()\n}\n\n/// Export the current spreadsheet as a binary file\n///\n/// Serializes the spreadsheet and returns it as a downloadable binary file.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * Binary file for download or error response\nasync fn export_spreadsheet(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    // Prepare a memory buffer to receive the serialized data\n    let mut buffer = Vec::new();\n\n    // Try to serialize the spreadsheet to the buffer\n    match serialize_to_memory(\u0026sheet, \u0026mut buffer) {\n        Ok(_) =\u003e {\n            // Return the serialized data as a downloadable file\n            Response::builder()\n                .status(StatusCode::OK)\n                .header(header::CONTENT_TYPE, \"application/gzip\")\n                .body(axum::body::Body::from(Bytes::from(buffer)))\n                .unwrap()\n        }\n        Err(e) =\u003e {\n            // Return error response\n            Response::builder()\n                .status(StatusCode::INTERNAL_SERVER_ERROR)\n                .header(header::CONTENT_TYPE, \"application/json\")\n                .body(axum::body::Body::from(\n                    serde_json::to_string(\u0026SaveResponse {\n                        status: \"error\".to_string(),\n                        message: Some(e.to_string()),\n                    })\n                    .unwrap(),\n                ))\n                .unwrap()\n        }\n    }\n}\n\n/// Load a spreadsheet from an uploaded file\n///\n/// Processes a multipart form upload and loads the spreadsheet into memory.\n///\n/// # Arguments\n/// * `state` - Application state\n/// * `multipart` - Multipart form data containing the uploaded file\n///\n/// # Returns\n/// * JSON response indicating success or failure\nasync fn load_spreadsheet(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    mut multipart: Multipart,\n) -\u003e impl IntoResponse {\n    // Process the multipart form data\n    let mut file_data = Vec::new();\n    let _field_name = String::new();\n    let mut file_path = None;\n\n    while let Some(field) = multipart.next_field().await.unwrap_or(None) {\n        let field_name = field.name().unwrap_or(\"unknown\").to_string();\n\n        if field_name == \"spreadsheet\" {\n            // First get the filename before consuming the field with bytes()\n            file_path = field.file_name().map(|s| s.to_string());\n\n            // Now get the bytes (this consumes the field)\n            file_data = field.bytes().await.unwrap_or_default().to_vec();\n        }\n    }\n\n    if file_data.is_empty() {\n        return Json(SaveResponse {\n            status: \"error\".to_string(),\n            message: Some(\"No file data received\".to_string()),\n        })\n        .into_response();\n    }\n\n    // Try to deserialize the spreadsheet\n    match deserialize_from_memory(\u0026file_data) {\n        Ok(loaded_sheet) =\u003e {\n            // Update the application's spreadsheet\n            let mut sheet = state.sheet.lock().unwrap();\n            *sheet = loaded_sheet;\n\n            // Store the original file path\n            if let Some(path) = file_path {\n                let mut original_path = state.original_path.lock().unwrap();\n                *original_path = Some(path);\n            }\n\n            Json(SaveResponse {\n                status: \"ok\".to_string(),\n                message: None,\n            })\n            .into_response()\n        }\n        Err(e) =\u003e Json(SaveResponse {\n            status: \"error\".to_string(),\n            message: Some(format!(\"Failed to load spreadsheet: {}\", e)),\n        })\n        .into_response(),\n    }\n}\n\n/// Download the current spreadsheet as CSV\n///\n/// Converts the spreadsheet to CSV format and returns it as a downloadable file.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * CSV file for download or error response\nasync fn download_csv(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    match downloader::to_csv(\u0026sheet) {\n        Ok(csv_content) =\u003e Response::builder()\n            .status(StatusCode::OK)\n            .header(header::CONTENT_TYPE, \"text/csv\")\n            .header(\n                header::CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"spreadsheet.csv\\\"\",\n            )\n            .body(axum::body::Body::from(csv_content))\n            .unwrap(),\n        Err(e) =\u003e Response::builder()\n            .status(StatusCode::INTERNAL_SERVER_ERROR)\n            .header(header::CONTENT_TYPE, \"text/plain\")\n            .body(axum::body::Body::from(format!(\n                \"Error generating CSV: {}\",\n                e\n            )))\n            .unwrap(),\n    }\n}\n\n/// Download the current spreadsheet as XLSX\n///\n/// Converts the spreadsheet to XLSX format and returns it as a downloadable file.\n///\n/// # Arguments\n/// * `state` - Application state containing the spreadsheet\n///\n/// # Returns\n/// * XLSX file for download or error response\nasync fn download_xlsx(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    match downloader::to_xlsx(\u0026sheet) {\n        Ok(xlsx_data) =\u003e Response::builder()\n            .status(StatusCode::OK)\n            .header(\n                header::CONTENT_TYPE,\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            )\n            .header(\n                header::CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"spreadsheet.xlsx\\\"\",\n            )\n            .body(axum::body::Body::from(Bytes::from(xlsx_data)))\n            .unwrap(),\n        Err(e) =\u003e Response::builder()\n            .status(StatusCode::INTERNAL_SERVER_ERROR)\n            .header(header::CONTENT_TYPE, \"text/plain\")\n            .body(axum::body::Body::from(format!(\n                \"Error generating XLSX: {}\",\n                e\n            )))\n            .unwrap(),\n    }\n}\n\n/// Serialize a spreadsheet to a memory buffer\n///\n/// Compresses and serializes a spreadsheet to a memory buffer.\n///\n/// # Arguments\n/// * `spreadsheet` - The spreadsheet to serialize\n/// * `buffer` - The buffer to write to\n///\n/// # Returns\n/// * `std::io::Result\u003c()\u003e` - Success or error\nfn serialize_to_memory(spreadsheet: \u0026Spreadsheet, buffer: \u0026mut Vec\u003cu8\u003e) -\u003e std::io::Result\u003c()\u003e {\n    use bincode::serialize_into;\n    use flate2::Compression;\n    use flate2::write::GzEncoder;\n\n    let encoder = GzEncoder::new(buffer, Compression::default());\n    let mut writer = std::io::BufWriter::new(encoder);\n\n    serialize_into(\u0026mut writer, spreadsheet)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;\n\n    Ok(())\n}\n\n/// Deserialize a spreadsheet from a memory buffer\n///\n/// Decompresses and deserializes a spreadsheet from a memory buffer.\n///\n/// # Arguments\n/// * `buffer` - The buffer containing the serialized spreadsheet\n///\n/// # Returns\n/// * `std::io::Result\u003cBox\u003cSpreadsheet\u003e\u003e` - Deserialized spreadsheet or error\nfn deserialize_from_memory(buffer: \u0026[u8]) -\u003e std::io::Result\u003cBox\u003cSpreadsheet\u003e\u003e {\n    use bincode::deserialize_from;\n    use flate2::read::GzDecoder;\n    use std::io::Cursor;\n\n    let cursor = Cursor::new(buffer);\n    let decoder = GzDecoder::new(cursor);\n    let mut reader = std::io::BufReader::new(decoder);\n\n    let spreadsheet: Spreadsheet = deserialize_from(\u0026mut reader)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n    Ok(Box::new(spreadsheet))\n}\n\n/// Convert a formula to a displayable string\n///\n/// Converts the internal formula representation to a string that can be displayed\n/// in the UI or saved to a file.\n///\n/// # Arguments\n/// * `formula` - The formula to convert\n///\n/// # Returns\n/// * A string representation of the formula\nfn formula_to_string(formula: \u0026ParsedRHS) -\u003e String {\n    match formula {\n        ParsedRHS::Function {\n            name,\n            args: (arg1, arg2),\n        } =\u003e {\n            let func_name = match name {\n                FunctionName::Min =\u003e \"MIN\",\n                FunctionName::Max =\u003e \"MAX\",\n                FunctionName::Avg =\u003e \"AVG\",\n                FunctionName::Sum =\u003e \"SUM\",\n                FunctionName::Stdev =\u003e \"STDEV\",\n                FunctionName::Cut =\u003e \"CUT\",\n                FunctionName::Copy =\u003e \"COPY\",\n            };\n\n            let cell1 = match arg1 {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            let cell2 = match arg2 {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"{}({}:{})\", func_name, cell1, cell2)\n        }\n        ParsedRHS::Arithmetic { lhs, operator, rhs } =\u003e {\n            let left = match lhs {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            let right = match rhs {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"{}{}{}\", left, operator, right)\n        }\n        ParsedRHS::Sleep(operand) =\u003e {\n            let value = match operand {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"SLEEP({})\", value)\n        }\n        ParsedRHS::SingleValue(operand) =\u003e match operand {\n            Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n            Operand::Number(n) =\u003e n.to_string(),\n        },\n        ParsedRHS::None =\u003e String::new(),\n    }\n}\n\n/// Get information about the current spreadsheet\n///\n/// Returns metadata about the current spreadsheet, including whether it has been loaded\n/// from a file and the original path if applicable.\n///\n/// # Arguments\n/// * `state` - Application state\n///\n/// # Returns\n/// * JSON response with spreadsheet information\nasync fn get_sheet_info(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let original_path = state.original_path.lock().unwrap();\n\n    Json(serde_json::json!({\n        \"is_loaded\": original_path.is_some(),\n        \"original_path\": original_path.clone().unwrap_or_default(),\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","cell_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\n#[cfg(test)]\nmod cell_tests {\n    use cop::cell::{Cell, Dependents, cell_create, cell_dep_insert, cell_dep_remove};\n\n    fn cell_contains(cell: \u0026Cell, row: i16, col: i16) -\u003e bool {\n        cell.contains(row, col)\n    }\n\n    #[test]\n    fn test_basic_cell_creation() {\n        let cell = cell_create(1, 1);\n        assert_eq!(cell.row, 1);\n        assert_eq!(cell.col, 1);\n        assert_eq!(cell.value, 0);\n        assert!(!cell.error);\n        assert!(matches!(cell.formula, cop::spreadsheet::ParsedRHS::None));\n        assert!(matches!(cell.dependents, Dependents::None));\n    }\n\n    #[test]\n    fn test_cell_value_modification() {\n        let mut cell = cell_create(1, 1);\n        cell.value = 100;\n        assert_eq!(cell.value, 100);\n    }\n\n    #[test]\n    fn test_cell_formula_assignment() {\n        use cop::spreadsheet::{Operand, ParsedRHS};\n\n        let mut cell = cell_create(1, 1);\n        cell.formula = ParsedRHS::SingleValue(Operand::Number(42));\n\n        assert!(matches!(cell.formula, ParsedRHS::SingleValue(_)));\n\n        if let ParsedRHS::SingleValue(Operand::Number(value)) = cell.formula {\n            assert_eq!(value, 42);\n        } else {\n            panic!(\"Expected ParsedRHS::SingleValue(Operand::Number)\");\n        }\n    }\n\n    #[test]\n    fn test_error_flag() {\n        let mut cell = cell_create(1, 1);\n        cell.error = true;\n        assert!(cell.error);\n    }\n\n    #[test]\n    fn test_managing_dependents() {\n        let mut cell = cell_create(1, 1);\n\n        // Check whether no dependents exist\n        assert!(!cell_contains(\u0026cell, 1, 1)); // nothing should be there\n        assert!(!cell_contains(\u0026cell, 2, 1)); // nothing should be there\n        assert!(!cell_contains(\u0026cell, 2, 2)); // nothing should be there\n\n        cell_dep_insert(\u0026mut cell, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell, 3, 2); // C2\n        cell_dep_insert(\u0026mut cell, 4, 3); // D3\n\n        assert!(cell_contains(\u0026cell, 2, 1));\n        assert!(cell_contains(\u0026cell, 3, 2));\n        assert!(cell_contains(\u0026cell, 4, 3));\n        assert!(!cell_contains(\u0026cell, 5, 4)); // E4 not added\n\n        // Add more dependents such that it becomes set\n        for i in 5..=10 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n        // Ensure all dependencies are still accessible\n        for i in 5..=10 {\n            assert!(cell_contains(\u0026cell, i, i));\n        }\n    }\n\n    #[test]\n    fn test_removing_dependents() {\n        let mut cell = cell_create(1, 1);\n\n        cell_dep_insert(\u0026mut cell, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell, 3, 2); // C2\n\n        assert!(cell_contains(\u0026cell, 3, 2));\n\n        cell_dep_remove(\u0026mut cell, 3, 2);\n        assert!(!cell_contains(\u0026cell, 3, 2));\n        assert!(cell_contains(\u0026cell, 2, 1)); // B1 should still be there\n\n        // Add more cells , such that it converts to set\n        for i in 4..=11 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n\n        // remove some dependents\n        cell_dep_remove(\u0026mut cell, 4, 4);\n        cell_dep_remove(\u0026mut cell, 5, 5);\n        cell_dep_remove(\u0026mut cell, 6, 6);\n\n        // check\n        assert!(!cell_contains(\u0026cell, 4, 4));\n        assert!(!cell_contains(\u0026cell, 5, 5));\n        assert!(!cell_contains(\u0026cell, 6, 6));\n        assert!(cell_contains(\u0026cell, 7, 7));\n        assert!(cell_contains(\u0026cell, 8, 8));\n        assert!(cell_contains(\u0026cell, 9, 9));\n        assert!(cell_contains(\u0026cell, 10, 10));\n        assert!(cell_contains(\u0026cell, 11, 11));\n    }\n\n    #[test]\n    fn test_creating_multiple_cells() {\n        let mut cell1 = cell_create(1, 1);\n        let mut cell2 = cell_create(2, 3);\n\n        assert_eq!(cell1.row, 1);\n        assert_eq!(cell1.col, 1);\n        assert_eq!(cell2.row, 2);\n        assert_eq!(cell2.col, 3);\n\n        cell_dep_insert(\u0026mut cell1, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell2, 1, 1); // A1\n        cell_dep_insert(\u0026mut cell2, 10, 24); // X10\n\n        // Verify each cell has its own dependencies\n        assert!(cell_contains(\u0026cell1, 2, 1));\n        assert!(!cell_contains(\u0026cell2, 2, 1));\n        assert!(!cell_contains(\u0026cell1, 1, 1));\n        assert!(cell_contains(\u0026cell2, 1, 1));\n        assert!(cell_contains(\u0026cell2, 10, 24));\n    }\n\n    #[test]\n    fn test_dependent_conversion() {\n        let mut cell = cell_create(1, 1);\n\n        // Add 9 dependencies to trigger conversion from Vector to Set\n        for i in 1..=9 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n\n        // Ensure all dependencies are still accessible\n        for i in 1..=9 {\n            assert!(cell_contains(\u0026cell, i, i));\n        }\n\n        // Add one more and check it works\n        cell_dep_insert(\u0026mut cell, 10, 10);\n        assert!(cell_contains(\u0026cell, 10, 10));\n\n        // Remove one and check it works\n        cell_dep_remove(\u0026mut cell, 5, 5);\n        assert!(!cell_contains(\u0026cell, 5, 5));\n        assert!(cell_contains(\u0026cell, 6, 6));\n    }\n}\n\nfn main() {\n    // When run directly, this will run the tests\n    println!(\"=== Cell Test Suite ===\");\n    println!(\"Run with 'cargo test' to execute tests\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","graph_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Generate example graphs from the library - now returns file paths\n    let graphs = cop::graph::create_example_graphs();\n\n    for (name, file_path) in graphs {\n        println!(\"Created {} graph at {}\", name, file_path);\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","scroll_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\nuse cop::spreadsheet::Spreadsheet;\n\nfn execute_command(sheet: \u0026mut Box\u003cSpreadsheet\u003e, cmd: \u0026str, status: \u0026mut String) {\n    if cmd.len() == 1 \u0026\u0026 \"wasd\".contains(cmd) {\n        match cmd {\n            \"w\" if sheet.view_row \u003e 0 =\u003e {\n                sheet.view_row = (sheet.view_row - 10).max(0);\n            }\n            \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n            }\n            \"a\" if sheet.view_col \u003e 0 =\u003e {\n                sheet.view_col = (sheet.view_col - 10).max(0);\n            }\n            \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n            }\n            _ =\u003e {}\n        }\n        *status = \"ok\".to_string();\n    } else if cmd.starts_with(\"scroll_to\") {\n        let cell_name = \u0026cmd[10..];\n        if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n            sheet.view_row = row - 1;\n            sheet.view_col = col - 1;\n            *status = \"ok\".to_string();\n        } else {\n            *status = \"invalid cell\".to_string();\n        }\n    } else {\n        *status = \"invalid command\".to_string();\n    }\n}\n\nfn set_cell(sheet: \u0026mut Box\u003cSpreadsheet\u003e, cell_name: \u0026str, formula: \u0026str) {\n    let mut status = String::new();\n\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n        let (valid, _, _, rhs) = sheet.is_valid_command(cell_name, formula);\n        if valid {\n            sheet.spreadsheet_set_cell_value(row, col, rhs, \u0026mut status);\n        }\n    }\n}\n\nfn main() {\n    println!(\"Starting interactive scroll test\");\n\n    // Create a 25x25 spreadsheet\n    let mut sheet = Spreadsheet::spreadsheet_create(25, 25).unwrap();\n\n    // Fill the spreadsheet with values for easy visual testing\n    println!(\"Filling spreadsheet with test data...\");\n    for i in 1..=25 {\n        for j in 1..=25 {\n            let cell_name = Spreadsheet::get_cell_name(i, j);\n            let formula = format!(\"{}\", i * 100 + j); // Value will be row*100+col\n            set_cell(\u0026mut sheet, \u0026cell_name, \u0026formula);\n        }\n    }\n\n    let mut status = \"ok\".to_string();\n\n    println!(\"\\n=== SCROLL TEST INTERACTIVE SIMULATION ===\");\n    println!(\"Initial view (top-left corner):\");\n    sheet.spreadsheet_display();\n\n    // Test a series of commands\n    let commands = [\n        \"s\",             // scroll down\n        \"d\",             // scroll right\n        \"s\",             // scroll down more\n        \"scroll_to P20\", // jump to cell P20\n        \"w\",             // scroll up\n        \"a\",             // scroll left\n    ];\n\n    for cmd in commands.iter() {\n        println!(\"\\nExecuting command: '{}'\", cmd);\n        execute_command(\u0026mut sheet, cmd, \u0026mut status);\n        println!(\"Status: {}\", status);\n        println!(\n            \"View position: row={}, col={}\",\n            sheet.view_row, sheet.view_col\n        );\n        sheet.spreadsheet_display();\n    }\n\n    // Try boundary cases\n    println!(\"\\n=== TESTING BOUNDARY CASES ===\");\n\n    // Scroll to a corner\n    println!(\"\\nScrolling to top-left (A1):\");\n    execute_command(\u0026mut sheet, \"scroll_to A1\", \u0026mut status);\n    sheet.spreadsheet_display();\n\n    // Try to scroll beyond left boundary\n    println!(\"\\nTrying to scroll left beyond boundary ('a'):\");\n    execute_command(\u0026mut sheet, \"a\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    // Scroll to bottom-right corner\n    println!(\"\\nScrolling to bottom-right (Y25):\");\n    execute_command(\u0026mut sheet, \"scroll_to Y25\", \u0026mut status);\n    sheet.spreadsheet_display();\n\n    // Try to scroll beyond right/bottom boundary\n    println!(\"\\nTrying to scroll down beyond boundary ('s'):\");\n    execute_command(\u0026mut sheet, \"s\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    println!(\"\\nTrying to scroll right beyond boundary ('d'):\");\n    execute_command(\u0026mut sheet, \"d\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    println!(\"\\nScroll test completed successfully!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","spreadsheet_test.rs"],"content":"// #[cfg(test)]\n#![cfg(not(tarpaulin_include))]\n#[cfg(test)]\nmod spreadsheet_tests {\n    use cop::cell::{cell_contains, cell_dep_insert};\n    use cop::spreadsheet::{FunctionName, Operand, ParsedRHS, Spreadsheet};\n    // use std::collections::BTreeSet;\n    use std::time::Instant;\n\n    #[test]\n    fn test_spreadsheet_creation() {\n        // Test creating a spreadsheet with valid dimensions\n        let sheet = Spreadsheet::spreadsheet_create(10, 10);\n        assert!(sheet.is_some());\n        let sheet = sheet.unwrap();\n        assert_eq!(sheet.rows, 10);\n        assert_eq!(sheet.cols, 10);\n        assert_eq!(sheet.cells.len(), 100);\n\n        // Test cells initialization\n        for r in 1..=10 {\n            for c in 1..=10 {\n                let index = ((r - 1) as usize * 10 + (c - 1) as usize) as usize;\n                assert!(sheet.cells[index].is_some());\n            }\n        }\n        // Test creating a spreadsheet with larger dimensions\n        let sheet = Spreadsheet::spreadsheet_create(999, 18278);\n        assert!(sheet.is_some());\n        let sheet = sheet.unwrap();\n        assert_eq!(sheet.rows, 999);\n        assert_eq!(sheet.cols, 18278);\n\n        // Test cells initialization\n        for r in 1..=999 {\n            for c in 1..=18278 {\n                let index = ((r - 1) as usize * 10 + (c - 1) as usize) as usize;\n                assert!(sheet.cells[index].is_some());\n            }\n        }\n    }\n\n    #[test]\n    fn test_column_letter_conversion() {\n        // Test converting column numbers to letters\n        assert_eq!(Spreadsheet::col_to_letter(1), \"A\");\n        assert_eq!(Spreadsheet::col_to_letter(26), \"Z\");\n        assert_eq!(Spreadsheet::col_to_letter(27), \"AA\");\n        assert_eq!(Spreadsheet::col_to_letter(52), \"AZ\");\n        assert_eq!(Spreadsheet::col_to_letter(53), \"BA\");\n        assert_eq!(Spreadsheet::col_to_letter(702), \"ZZ\");\n        assert_eq!(Spreadsheet::col_to_letter(703), \"AAA\");\n        assert_eq!(Spreadsheet::col_to_letter(704), \"AAB\");\n        assert_eq!(Spreadsheet::col_to_letter(728), \"AAZ\");\n        assert_eq!(Spreadsheet::col_to_letter(729), \"ABA\");\n        assert_eq!(Spreadsheet::col_to_letter(1404), \"BAZ\");\n        assert_eq!(Spreadsheet::col_to_letter(18278), \"ZZZ\");\n\n        // Test converting letters to column numbers\n        assert_eq!(Spreadsheet::letter_to_col(\"A\"), 1);\n        assert_eq!(Spreadsheet::letter_to_col(\"Z\"), 26);\n        assert_eq!(Spreadsheet::letter_to_col(\"AA\"), 27);\n        assert_eq!(Spreadsheet::letter_to_col(\"AZ\"), 52);\n        assert_eq!(Spreadsheet::letter_to_col(\"BA\"), 53);\n        assert_eq!(Spreadsheet::letter_to_col(\"ZZ\"), 702);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAA\"), 703);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAB\"), 704);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAZ\"), 728);\n        assert_eq!(Spreadsheet::letter_to_col(\"ABA\"), 729);\n        assert_eq!(Spreadsheet::letter_to_col(\"BAZ\"), 1404);\n        assert_eq!(Spreadsheet::letter_to_col(\"ZZZ\"), 18278);\n\n        // Test round-trip conversion\n        for col in 1..=100 {\n            let letter = Spreadsheet::col_to_letter(col);\n            let back = Spreadsheet::letter_to_col(\u0026letter);\n            assert_eq!(col, back);\n        }\n    }\n\n    #[test]\n    fn test_cell_name_operations() {\n        // Test generating cell names\n        assert_eq!(Spreadsheet::get_cell_name(1, 1), \"A1\");\n        assert_eq!(Spreadsheet::get_cell_name(10, 26), \"Z10\");\n        assert_eq!(Spreadsheet::get_cell_name(100, 27), \"AA100\");\n        assert_eq!(Spreadsheet::get_cell_name(100, 100), \"CV100\");\n\n        // Test parsing cell names in a spreadsheet context\n        let sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n\n        // Valid cell names\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A1\"), Some((1, 1)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"Z10\"), Some((10, 26)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"AA100\"), Some((100, 27)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"CV100\"), Some((100, 100)));\n\n        // Invalid cell names (out of bounds)\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A0\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A101\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"CW1\"), None); // Column out of bounds\n\n        // Malformed cell names\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"1A\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A1B\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"1\"), None);\n    }\n\n    #[test]\n    fn test_is_numeric() {\n        // Test numeric strings\n        assert!(Spreadsheet::is_numeric(\"0\"));\n        assert!(Spreadsheet::is_numeric(\"123\"));\n        assert!(Spreadsheet::is_numeric(\"9876543210\"));\n        assert!(Spreadsheet::is_numeric(\"00\"));\n        assert!(Spreadsheet::is_numeric(\"0098\"));\n        assert!(Spreadsheet::is_numeric(\"0090\"));\n\n        // Test non-numeric strings\n        assert!(!Spreadsheet::is_numeric(\"\"));\n        assert!(!Spreadsheet::is_numeric(\"A\"));\n        assert!(!Spreadsheet::is_numeric(\"12A\"));\n        assert!(!Spreadsheet::is_numeric(\"A12\"));\n        assert!(!Spreadsheet::is_numeric(\"-123\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"+123\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"12.3\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"-0090\")); // Contains non-digit\n    }\n\n    #[test]\n    fn test_evaluate_expression() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup some cell values\n        let a1_idx = 0 * 10 + 0;\n        let a2_idx = 1 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n        let b2_idx = 1 * 10 + 1;\n        let c1_idx = 0 * 10 + 2;\n        let d1_idx = 0 * 10 + 3;\n        let d2_idx = 0 * 10 + 4;\n        let d3_idx = 0 * 10 + 5;\n\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 10;\n        }\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 20;\n        }\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.value = 30;\n        }\n        if let Some(cell) = sheet.cells[b2_idx].as_mut() {\n            cell.value = 40;\n        }\n        if let Some(cell) = sheet.cells[c1_idx].as_mut() {\n            cell.value = 123;\n        }\n        if let Some(cell) = sheet.cells[d1_idx].as_mut() {\n            cell.value = -234;\n        }\n        if let Some(cell) = sheet.cells[d2_idx].as_mut() {\n            cell.value = 2;\n            cell.error = true;\n        }\n        if let Some(cell) = sheet.cells[d3_idx].as_mut() {\n            cell.value = 2;\n            cell.error = false;\n        }\n\n        // Test various expressions similar to the C tests\n\n        // Test with numeric literals\n        let expr = ParsedRHS::SingleValue(Operand::Number(42));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 42);\n        assert!(!error);\n\n        // Test with positive and negative numbers\n        let expr = ParsedRHS::SingleValue(Operand::Number(-1));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -1);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(1));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 1);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(09));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 9);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(-09));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -9);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(-2_147_483_648));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -2147483648);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(2_147_483_647));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 2147483647);\n        assert!(!error);\n\n        // Test with cell references\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, 10);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 4)); // A4\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, -234);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 5)); // A4\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert!(error);\n\n        // Test for none formula i.e. default cells\n        let expr = ParsedRHS::None;\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, 0);\n        assert!(!error);\n\n        // Test basic arithmetic\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1 = 10\n            operator: '+',\n            rhs: Operand::Cell(2, 1), // A2 = 20\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 30);\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 5),\n            operator: '+',\n            rhs: Operand::Cell(1, 1),\n        }; // A5 = ERR\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert!(error);\n\n        // Test arithmetic with constants\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(3),\n            operator: '*',\n            rhs: Operand::Cell(1, 2), // B1 = 30\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 90);\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 3), // C1 = 123\n            operator: '-',\n            rhs: Operand::Number(34),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 89);\n        assert!(!error);\n\n        // Test division and error propagation\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(3),\n            operator: '/',\n            rhs: Operand::Cell(1, 1), // A1 = 10\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 0); // Integer division\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(10),\n            operator: '/',\n            rhs: Operand::Number(0),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 0);\n        assert!(error); // Division by zero error\n\n        // Test propagation of errors\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = true;\n        }\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1 (with error)\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert!(error);\n\n        // Test with range functions\n        // First, reset A1's error flag\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = false;\n        }\n\n        // Test SUM function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 100); // 10 + 20 + 30 + 40\n        assert!(!error);\n\n        // Test MIN function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 10);\n        assert!(!error);\n\n        // Test MAX function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 40);\n        assert!(!error);\n\n        // Test AVG function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 25); // (10 + 20 + 30 + 40) / 4\n        assert!(!error);\n\n        // Range can be single cell as well\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(1, 1), // A1 = 10\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 10); // (10) / 1\n        assert!(!error);\n\n        //Test STDDEV function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 11); // Standard deviation of the values\n        assert!(!error);\n\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(1, 1), // A1 = 10\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 0); // Standard deviation returns 0 for a single value\n        assert!(!error);\n\n        // Test COPY function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 0); // Copy is not implemented in this function. it should simply return 0,false\n        assert!(!error); // Copy function should return a default error\n\n        // Test error propagation with functions\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = true;\n        }\n\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 (with error)\n                Operand::Cell(2, 2), // B2\n            ),\n        };\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert!(error);\n\n        // Test for sleep function with error\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 5), // A5 = 2\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Test for sleep function without error\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 6), // A6 = 2\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 2); // Sleep function should sleep for 2 seconds\n\n        // test for sleep with cell with negative value\n        //A4 is negative value\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 4), // A4 = -234\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, -234); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Sleep with value as argument\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(2), // Sleep for 2 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 2); // Sleep function should sleep for 2 seconds\n\n        // Test for sleep with negative value\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(-2), // Sleep for -2 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, -2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Test for sleep with zero value\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(0), // Sleep for 0 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 0); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n    }\n\n    #[test]\n    fn test_cycle_detection() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Set up a cyclic dependency: A1 depends on B1, B1 depends on A1\n        let a1_idx = 0 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n\n        // First, modify A1 to depend on B1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_dep_insert(cell_a1, 1, 2);\n        }\n        assert!(sheet.first_step_find_cycle((1, 1), (1, 2), (0, 0), false));\n\n        // Then, modify B1 to depend on A1 (in a separate step)\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_mut() {\n            cell_dep_insert(cell_b1, 1, 1);\n        }\n\n        // Test cycle detection\n        assert!(sheet.first_step_find_cycle((1, 2), (1, 1), (0, 0), false));\n\n        // Test no cycle\n        let c1_idx = 0 * 10 + 2;\n\n        // First, modify C1 to depend on C2\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_mut() {\n            cell_dep_insert(cell_c1, 2, 3);\n        }\n\n        // Test no cycle detection\n        assert!(!sheet.first_step_find_cycle((1, 3), (1, 1), (1, 2), false));\n\n        // Test for is_range = true\n        // add A1 to dependencies of D1. i.e. changing D1 will change A1\n        let d1_idx = 0 * 10 + 3;\n        if let Some(cell_d1) = sheet.cells[d1_idx].as_mut() {\n            cell_dep_insert(cell_d1, 1, 1);\n        }\n\n        // Test cycle detection\n        assert!(sheet.first_step_find_cycle((1, 4), (1, 1), (2, 2), true));\n\n        let mut sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n        // In dependencies of A1, add B1 to B10 using for loop\n        for i in 1..=10 {\n            let a1_idx = 0 * 100 + 0;\n            if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n                cell_dep_insert(cell_a1, i, 2);\n            }\n        }\n        assert!(sheet.first_step_find_cycle((1, 1), (1, 2), (0, 0), false));\n    }\n\n    #[test]\n    pub fn test_dependencies_management() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup A1's formula to depend on B1 and C1\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2), // B1\n                operator: '+',\n                rhs: Operand::Cell(1, 3), // C1\n            };\n        }\n\n        // Now update the dependencies\n        sheet.update_dependencies((1, 1), (1, 2), (1, 3), false);\n\n        // Check if dependencies were correctly set up\n        let b1_idx = 0 * 10 + 1;\n        let c1_idx = 0 * 10 + 2;\n\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            assert!(cell_contains(cell_b1, 1, 1));\n        }\n\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_ref() {\n            assert!(cell_contains(cell_c1, 1, 1));\n        }\n\n        // Now change A1's formula to depend only on D1\n        sheet.remove_old_dependents(1, 1);\n\n        // Set the new formula for A1\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Cell(1, 4)); // D1\n        }\n\n        sheet.update_dependencies((1, 1), (1, 4), (0, 0), false);\n\n        // Check that old dependencies were removed\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_c1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        // Check that new dependency was added\n        let d1_idx = 0 * 10 + 3;\n        if let Some(cell_d1) = sheet.cells[d1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_d1);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n\n        // Test for larger spreadsheet\n        let mut sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n        // set A1 to 5\n        let a1_idx = 0 * 100 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 5;\n        }\n        // set A2 to 10\n        let a2_idx = 1 * 100 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 10;\n        }\n\n        //set A3 to 20\n        let a3_idx = 2 * 100 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_mut() {\n            cell.value = 20;\n        }\n        // set A4 to -5\n        let a4_idx = 3 * 100 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_mut() {\n            cell.value = -5;\n        }\n\n        //  set B1 to be equal to A1 + A2 using set_cell_value\n        let b1_idx = 0 * 100 + 1;\n        // set formula of B1 to A1 + A2\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 1), // A1\n                operator: '+',\n                rhs: Operand::Cell(2, 1), // A2\n            };\n        }\n        sheet.update_dependencies((1, 2), (1, 1), (2, 1), false);\n\n        // assign A1 to 20 using formula\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Number(20));\n        }\n        sheet.update_dependencies((1, 1), (0, 0), (0, 0), false);\n        // assign C1 to B1 * 2\n        let c1_idx = 0 * 100 + 2;\n        if let Some(cell) = sheet.cells[c1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2), // B1\n                operator: '*',\n                rhs: Operand::Number(2),\n            };\n        }\n\n        // update dependencies for C1\n        sheet.update_dependencies((1, 3), (1, 2), (0, 0), false);\n\n        // update dependencies for A2\n        // assign A2 to 10 using formula\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Number(10));\n        }\n        sheet.update_dependencies((2, 1), (0, 0), (0, 0), false);\n\n        // set D1 = MAX(A1:A4)\n        // set formula of D1\n        let d1_idx = 0 * 100 + 3;\n        if let Some(cell) = sheet.cells[d1_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Max,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D2 = MIN(A1:A4)\n        // set formula of D2\n        let d2_idx = 1 * 100 + 3;\n        if let Some(cell) = sheet.cells[d2_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Min,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D3 = SUM(A1:A4)\n        // set formula of D3\n        let d3_idx = 2 * 100 + 3;\n        if let Some(cell) = sheet.cells[d3_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Sum,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D4= AVG(A1:A4)\n        // set formula of D4\n        let d4_idx = 3 * 100 + 3;\n        if let Some(cell) = sheet.cells[d4_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Avg,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D5 = STDDEV(A1:A4)\n        // set formula of D5\n        let d5_idx = 4 * 100 + 3;\n        if let Some(cell) = sheet.cells[d5_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Stdev,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set E1= SLEEP(A1)\n        // set formula of E1\n        let e1_idx = 0 * 100 + 4;\n        if let Some(cell) = sheet.cells[e1_idx].as_mut() {\n            cell.formula = ParsedRHS::Sleep(Operand::Cell(1, 1)); // A1\n        }\n        // set E2= SLEEP(A4)\n        // set formula of E2\n        let e2_idx = 1 * 100 + 4;\n        if let Some(cell) = sheet.cells[e2_idx].as_mut() {\n            cell.formula = ParsedRHS::Sleep(Operand::Cell(4, 1)); // A4\n        }\n\n        // update dependencies for D1\n        sheet.update_dependencies((1, 4), (1, 1), (4, 1), true);\n        // update dependencies for D2\n        sheet.update_dependencies((2, 4), (1, 1), (4, 1), true);\n        // update dependencies for D3\n        sheet.update_dependencies((3, 4), (1, 1), (4, 1), true);\n        // update dependencies for D4\n        sheet.update_dependencies((4, 4), (1, 1), (4, 1), true);\n        // update dependencies for D5\n        sheet.update_dependencies((5, 4), (1, 1), (4, 1), true);\n        // update dependencies for E1\n        sheet.update_dependencies((1, 5), (1, 1), (0, 0), false);\n        // update dependencies for E2\n        sheet.update_dependencies((2, 5), (4, 1), (0, 0), false);\n        // Check that dependencies were correctly set up\n        // B1 D1-D5 E1 should be present in dependents of A1\n\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(deps.contains(\u0026(1, 2)));\n            assert!(deps.contains(\u0026(1, 4)));\n            assert!(deps.contains(\u0026(2, 4)));\n            assert!(deps.contains(\u0026(3, 4)));\n            assert!(deps.contains(\u0026(4, 4)));\n            assert!(deps.contains(\u0026(5, 4)));\n            assert!(deps.contains(\u0026(1, 5)));\n        }\n\n        // dependencies of B1 should contain C1\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(deps.contains(\u0026(1, 3)));\n        }\n\n        // test for the remove_old_dependents function\n        // remove old dependents of B1 . now B1 should not be present in A1's dependents\n        sheet.remove_old_dependents(1, 2); //B1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(1, 2)));\n        }\n\n        // remove old dependents for E2 , now E2 should not be present in A4's dependents\n        sheet.remove_old_dependents(2, 5);\n        if let Some(cell_a4) = sheet.cells[a4_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a4);\n            assert!(!deps.contains(\u0026(2, 5)));\n        }\n\n        // remove old dependents for D1 , now D1 should not be present in A1's dependents\n        sheet.remove_old_dependents(1, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(1, 4)));\n        }\n\n        // remove old dependents for D2 , now D2 should not be present in A1's dependents\n        sheet.remove_old_dependents(2, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(2, 4)));\n        }\n\n        // remove old dependents for D3 , now D3 should not be present in A1's dependents\n        sheet.remove_old_dependents(3, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(3, 4)));\n        }\n\n        // remove old dependents for D4 , now D4 should not be present in A1's dependents\n        sheet.remove_old_dependents(4, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(4, 4)));\n        }\n\n        // remove old dependents for D5 , now D5 should not be present in A1's dependents\n        sheet.remove_old_dependents(5, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(5, 4)));\n        }\n\n        // remove dependents for A1. Now A1 should not be present in any cell's dependents\n        sheet.remove_old_dependents(1, 1);\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        // Single value operand cell is left. check that as well\n        // first assign A1 to A2 let's say\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_a1.formula = ParsedRHS::SingleValue(Operand::Cell(2, 1)); // A2\n        }\n        sheet.update_dependencies((1, 1), (2, 1), (0, 0), false);\n        // check that A1 is present in A2's dependents\n        if let Some(cell_a2) = sheet.cells[a2_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a2);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n        // remove old dependents for A1 , now A1 should not be present in A2's dependents\n        sheet.remove_old_dependents(1, 1);\n        if let Some(cell_a2) = sheet.cells[a2_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a2);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        // Setup:\n        // A1 depends on B1\n        // B1 depends on C1\n        // C1 has no dependencies\n        let a1_idx = 0 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_dep_insert(cell_a1, 1, 2); // A1 points to B1\n        }\n\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_mut() {\n            cell_dep_insert(cell_b1, 1, 3); // B1 points to C1\n        }\n\n        // Perform topological sort starting from A1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let sorted = sheet.topo_sort(cell_a1);\n\n            // Check that the order is correct (should be C1, B1, A1)\n            assert_eq!(sorted.len(), 3);\n            assert_eq!(sorted[0], (1, 1)); // C1\n            assert_eq!(sorted[1], (1, 2)); // B1\n            assert_eq!(sorted[2], (1, 3)); // A1\n        }\n\n        // Test topo sort for large spreadsheet (enhanced check)\n        let mut sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n        // set_cell(sheet, \"B1\", \"SUM(A1:A10)\");\n        // set_cell(sheet, \"B2\", \"MAX(A1:A10)\");\n        // set_cell(sheet, \"B3\", \"MIN(A1:A10)\");\n        // set_cell(sheet, \"B4\", \"AVG(A1:A10)\");\n        // set_cell(sheet, \"B5\", \"STDEV(A1:A10)\");\n\n        // // Set formulas in C1:C5\n        // set_cell(sheet, \"C1\", \"SUM(B1:B5)\");\n        // set_cell(sheet, \"C2\", \"MAX(B1:B5)\");\n        // set_cell(sheet, \"C3\", \"MIN(B1:B5)\");\n        // set_cell(sheet, \"C4\", \"AVG(B1:B5)\");\n        // set_cell(sheet, \"C5\", \"STDEV(B1:B5)\");\n\n        // ADD B1 till B5 to A1:A10\n        for i in 1..=10 {\n            for j in 1..=5 {\n                let cell_idx = (i - 1) * 100;\n                if let Some(cell) = sheet.cells[cell_idx].as_mut() {\n                    cell_dep_insert(cell, j, 2);\n                }\n            }\n        }\n\n        // ADD C1 till C5 to B1:B10\n        for i in 1..=10 {\n            for j in 1..=5 {\n                let cell_idx = (i - 1) * 100 + 1;\n                if let Some(cell) = sheet.cells[cell_idx].as_mut() {\n                    cell_dep_insert(cell, j, 3);\n                }\n            }\n        }\n\n        let sorted_cells = sheet.topo_sort(\u0026sheet.cells[0].as_ref().unwrap());\n        // the vector should be something of the type... A1 then (B1 to B5 in any order) then (C1:C5 in any order)\n        assert_eq!(sorted_cells.len(), 11);\n        assert_eq!(sorted_cells[0], (1, 1)); // A1\n        for i in 1..=5 {\n            assert_eq!(sorted_cells[i], (6 - i as i16, 2)); // B1 to B5\n        }\n        for i in 1..=5 {\n            assert_eq!(sorted_cells[i + 5], (6 - i as i16, 3)); // C1 to C5\n        }\n    }\n\n    #[test]\n    fn test_set_cell_value() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Test setting a simple value\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(42));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_ref() {\n            assert_eq!(cell.value, 42);\n            assert!(!cell.error);\n        }\n\n        // Test setting a cell reference\n        let ref_expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // Reference to A1\n        sheet.spreadsheet_set_cell_value(2, 1, ref_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a2_idx = 1 * 10 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_ref() {\n            assert_eq!(cell.value, 42); // Should get value from A1\n            assert!(!cell.error);\n        }\n\n        // Test cycle detection\n        let cycle_expr = ParsedRHS::SingleValue(Operand::Cell(2, 1)); // Reference to A2, creating cycle\n        sheet.spreadsheet_set_cell_value(1, 1, cycle_expr.clone(), \u0026mut status);\n        assert_eq!(status, \"Cycle Detected\");\n\n        // Test formula with function\n        let sum_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(1, 2), // B1\n            ),\n        };\n\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(3, 1, avg_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a3_idx = 2 * 10 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert_eq!(cell.value, 42); // (42 + 42) / 2\n            assert!(!cell.error);\n        }\n\n        let min_expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 1, min_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a4_idx = 3 * 10 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_ref() {\n            assert_eq!(cell.value, 42); // min(42, 42)\n            assert!(!cell.error);\n        }\n\n        let max_expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(5, 1, max_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a5_idx = 4 * 10 + 0;\n        if let Some(cell) = sheet.cells[a5_idx].as_ref() {\n            assert_eq!(cell.value, 42); // max(42, 42)\n            assert!(!cell.error);\n        }\n\n        let stdev_expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(6, 1, stdev_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a6_idx = 5 * 10 + 0;\n        if let Some(cell) = sheet.cells[a6_idx].as_ref() {\n            assert_eq!(cell.value, 0); // stdev(42, 42) = 0\n            assert!(!cell.error);\n        }\n\n        // First set B1 to some value\n        let b1_val_expr = ParsedRHS::SingleValue(Operand::Number(58));\n        sheet.spreadsheet_set_cell_value(1, 2, b1_val_expr, \u0026mut status);\n\n        // Now set A3 to be SUM(A1:B1)\n        sheet.spreadsheet_set_cell_value(3, 1, sum_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert_eq!(cell.value, 100); // 42 + 58\n            assert!(!cell.error);\n        }\n\n        // Test for arithmetic expression type formula\n        let arith_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1\n            operator: '+',\n            rhs: Operand::Cell(2, 1), // A2\n        };\n        sheet.spreadsheet_set_cell_value(7, 1, arith_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a7_idx = 6 * 10 + 0;\n        if let Some(cell) = sheet.cells[a7_idx].as_ref() {\n            assert_eq!(cell.value, 84); // 42 + 42\n            assert!(!cell.error);\n        }\n\n        // Test for sleep type formula\n        let sleep_expr = ParsedRHS::Sleep(Operand::Number(2)); // Sleep for 2 seconds\n        sheet.spreadsheet_set_cell_value(8, 1, sleep_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a8_idx = 7 * 10 + 0;\n        if let Some(cell) = sheet.cells[a8_idx].as_ref() {\n            assert_eq!(cell.value, 2); // Sleep function should return cell value\n            assert!(!cell.error);\n        }\n\n        // Test for sleep with Operand::Cell\n        let sleep_expr = ParsedRHS::Sleep(Operand::Cell(6, 1)); // Sleep for 0 seconds\n        sheet.spreadsheet_set_cell_value(9, 1, sleep_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a9_idx = 8 * 10 + 0;\n        if let Some(cell) = sheet.cells[a9_idx].as_ref() {\n            assert_eq!(cell.value, 0); // Sleep function should return cell value\n            assert!(!cell.error);\n        }\n\n        //Test for Copy type formula\n        let copy_expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (Operand::Cell(1, 1), Operand::Cell(8, 1)),\n        };\n        sheet.spreadsheet_set_cell_value(1, 2, copy_expr, \u0026mut status);\n        // B1 should have value of A1 . B2 should have value of A2 . B3 should have value of A3...and so on. and formula of them should be None\n        assert_eq!(status, \"ok\");\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B1 should have value of A1\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b2_idx = 1 * 10 + 1;\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B2 should have value of A2\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b3_idx = 2 * 10 + 1;\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 100); // B3 should have value of A3\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(100)));\n        }\n        let b4_idx = 3 * 10 + 1;\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B4 should have value of A4\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b5_idx = 4 * 10 + 1;\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B5 should have value of A5\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b6_idx = 5 * 10 + 1;\n        if let Some(cell) = sheet.cells[b6_idx].as_ref() {\n            assert_eq!(cell.value, 0); // B6 should have value of A6\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(0)));\n        }\n        let b7_idx = 6 * 10 + 1;\n        if let Some(cell) = sheet.cells[b7_idx].as_ref() {\n            assert_eq!(cell.value, 84); // B7 should have value of A7\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(84)));\n        }\n        let b8_idx = 7 * 10 + 1;\n        if let Some(cell) = sheet.cells[b8_idx].as_ref() {\n            assert_eq!(cell.value, 2); // B8 should have value of A8\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(2)));\n        }\n    }\n\n    #[test]\n    fn test_undo_function() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Test setting a simple value\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(42));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        // Test undo\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 0); // Cell should be reset to 0\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        // should go back to 42\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 42); // Cell should be reset to 42\n\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(100));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 100); // Cell should be set to 100\n\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(200));\n        sheet.spreadsheet_set_cell_value(2, 1, val_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[10].as_ref().unwrap().value, 200); // Cell should be set to 200\n\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n\n        sheet.spreadsheet_set_cell_value(1, 3, avg_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[2].as_ref().unwrap().value, 150); // Cell should be set to 150\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[2].as_ref().unwrap().value, 0); // Cell should be reset to 0\n    }\n\n    #[test]\n    fn test_command_validation() {\n        let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Test valid commands\n\n        // Number\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"42\");\n        assert!(valid);\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(42)));\n\n        // Cell reference\n        let (valid, row, col, expr) = sheet.is_valid_command(\"B2\", \"A1\");\n        assert!(valid);\n        assert_eq!(row, 2);\n        assert_eq!(col, 2);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Cell(1, 1)));\n\n        // Arithmetic\n        let (valid, row, col, expr) = sheet.is_valid_command(\"C3\", \"A1+B2\");\n        assert!(valid);\n        assert_eq!(row, 3);\n        assert_eq!(col, 3);\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 1),\n                operator: '+',\n                rhs: Operand::Cell(2, 2),\n            }\n        );\n\n        // Function\n        // SUM\n        let (valid, row, col, expr) = sheet.is_valid_command(\"D4\", \"SUM(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 4);\n        assert_eq!(col, 4);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Sum,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // AVG\n        let (valid, row, col, expr) = sheet.is_valid_command(\"E5\", \"AVG(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 5);\n        assert_eq!(col, 5);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Avg,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // MIN\n        let (valid, row, col, expr) = sheet.is_valid_command(\"F6\", \"MIN(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 6);\n        assert_eq!(col, 6);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Min,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // MAX\n        let (valid, row, col, expr) = sheet.is_valid_command(\"G7\", \"MAX(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 7);\n        assert_eq!(col, 7);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Max,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // STDEV\n        let (valid, row, col, expr) = sheet.is_valid_command(\"H8\", \"STDEV(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 8);\n        assert_eq!(col, 8);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Stdev,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // COPY\n        let (valid, row, col, expr) = sheet.is_valid_command(\"I9\", \"COPY(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 9);\n        assert_eq!(col, 9);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Copy,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"J10\", \"COPY(A1:B2)\");\n        assert!(!valid);\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"SLEEP(2)\");\n        assert!(valid);\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::Sleep(Operand::Number(2)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"SLEEP(B2)\");\n        assert!(valid);\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::Sleep(Operand::Cell(2, 2)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"\");\n        assert!(!valid);\n        // Test invalid commands\n\n        // Invalid cell name\n        let (valid, _, _, _) = sheet.is_valid_command(\"X1\", \"42\");\n        assert!(!valid); // X1 is beyond the column limit\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"1A\", \"42\");\n        assert!(!valid); // Malformed cell name\n\n        // Invalid formula\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"A1++B1\");\n        assert!(!valid); // Malformed formula\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"SUM(A1)\");\n        assert!(!valid); // Missing second argument\n\n        // Out-of-bounds reference\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"Z100\");\n        assert!(!valid); // Z100 is beyond the sheet bounds\n\n        // Test additional invalid commands\n        let (valid, _, _, _) = sheet.is_valid_command(\"B1\", \"-A11\");\n        assert!(!valid); // A11 out of bounds\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"MAZ(B1:C5)\");\n        assert!(!valid); // Invalid function\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"SLEEP()\");\n        assert!(!valid); // Missing arguments\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"MAX()\");\n        assert!(!valid); // Missing arguments\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"\", \"\");\n        assert!(!valid); // Empty cell and formula\n\n        // Test arbitrary is_Valid commands\n        // give cell name A1 , formula = -1 , +1 , +2, -4 , 2147483647,-2147483648, 00, 09, 0090, -0090, -1*-1,-1*+1, -1+-1,-1-+1,-1/+1,-1/-1,1/0,2/0,A2*B1,-1*B1, +3*B1,B1+2,B1/0,C1-34,C1/-3,D1*-4,D1+-6,C1-+3\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"-1\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-1)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"+1\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(1)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"+2\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(2)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-4\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-4)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"2147483647\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(2147483647)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-2147483648\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-2147483648)));\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"00\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(0)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"09\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(9)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"0090\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(90)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-0090\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-90)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1+-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '+',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1-+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '-',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1/+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '/',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1/-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '/',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"1/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(1),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"2/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(2),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"A2*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(2, 1),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"+3*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(3),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"B1+2\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2),\n                operator: '+',\n                rhs: Operand::Number(2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"B1/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-34\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(34),\n            }\n        );\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1/-3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '/',\n                rhs: Operand::Number(-3),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"D1*-4\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 4),\n                operator: '*',\n                rhs: Operand::Number(-4),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"D1+-6\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 4),\n                operator: '+',\n                rhs: Operand::Number(-6),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-+3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(3),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-+3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(3),\n            }\n        );\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"\");\n        assert!(!valid); // Empty formula\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"2.3-+3\");\n        assert!(!valid); // invalid number\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"2-+3.5\");\n        assert!(!valid); // invalid number\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"A+3\");\n        assert!(!valid); // invalid number\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"A1+B\");\n        assert!(!valid); // invalid number\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"A1%B1\");\n        assert!(!valid);\n    }\n\n    #[test]\n    fn test_arithmetic_expression_validation() {\n        let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Test valid expressions\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"A1+B2\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"42-A1\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"A1*10\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"B2/2\");\n        assert!(valid);\n\n        // Test invalid expressions\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1++B2\");\n        assert!(!valid); // Invalid operator\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1+\");\n        assert!(!valid); // Missing second operand\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"+B2\");\n        assert!(!valid); // Missing first operand\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1 + B2\");\n        assert!(!valid); // Spaces not allowed\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"Z100+A1\");\n        assert!(!valid); // Out of bounds cell\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"--5\");\n        assert!(!valid); // Invalid format\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"-4+++5\");\n        assert!(!valid); // Invalid format\n    }\n\n    #[test]\n    fn test_range_functions() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Setup test data in A1-A5\n        let vals = [10, 20, 30, 40, 50];\n        for i in 0..5 {\n            let row = i + 1;\n            let expr = ParsedRHS::SingleValue(Operand::Number(vals[i]));\n            sheet.spreadsheet_set_cell_value(row as i16, 1, expr, \u0026mut status);\n            assert_eq!(status, \"ok\");\n        }\n\n        // Test SUM\n        let sum_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(1, 2, sum_expr, \u0026mut status); // B1\n        assert_eq!(status, \"ok\");\n\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 150); // 10+20+30+40+50\n            assert!(!cell.error);\n        }\n\n        // Test AVG\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(2, 2, avg_expr, \u0026mut status); // B2\n        assert_eq!(status, \"ok\");\n\n        let b2_idx = 1 * 10 + 1;\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 30); // (10+20+30+40+50)/5\n            assert!(!cell.error);\n        }\n\n        // Test MIN\n        let min_expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(3, 2, min_expr, \u0026mut status); // B3\n        assert_eq!(status, \"ok\");\n\n        let b3_idx = 2 * 10 + 1;\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 10);\n            assert!(!cell.error);\n        }\n\n        // Test MAX\n        let max_expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 2, max_expr, \u0026mut status); // B4\n        assert_eq!(status, \"ok\");\n\n        let b4_idx = 3 * 10 + 1;\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 50);\n            assert!(!cell.error);\n        }\n\n        // Test COPY\n        let copy_expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(5, 2, copy_expr, \u0026mut status); // B5\n        assert_eq!(status, \"ok\");\n\n        let b5_idx = 4 * 10 + 1;\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 10); // Copying A1\n            assert!(!cell.error);\n        }\n\n        // Update a value and check if dependencies update\n        let new_val_expr = ParsedRHS::SingleValue(Operand::Number(100));\n        sheet.spreadsheet_set_cell_value(1, 1, new_val_expr, \u0026mut status); // A1 = 100\n        assert_eq!(status, \"ok\");\n\n        // Check that SUM, AVG, MIN, MAX all updated\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 240); // 100+20+30+40+50\n        }\n\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 48); // (100+20+30+40+50)/5\n        }\n\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 20); // 20\n        }\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 100); // 100\n        }\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 10); // B5 will still be 10\n        }\n    }\n\n    #[test]\n    fn test_error_propagation() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Set up a cell with division by zero error\n        let div_zero_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(10),\n            operator: '/',\n            rhs: Operand::Number(0),\n        };\n        sheet.spreadsheet_set_cell_value(1, 1, div_zero_expr, \u0026mut status); // A1\n        assert_eq!(status, \"ok\");\n\n        // Verify error state\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Reference the error cell\n        let ref_expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1\n        sheet.spreadsheet_set_cell_value(2, 1, ref_expr, \u0026mut status); // A2\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a2_idx = 1 * 10 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Use in arithmetic\n        let arith_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1 (error)\n            operator: '+',\n            rhs: Operand::Number(5),\n        };\n        sheet.spreadsheet_set_cell_value(3, 1, arith_expr, \u0026mut status); // A3\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a3_idx = 2 * 10 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Use in function\n        let func_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 (error)\n                Operand::Cell(1, 2), // B1\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 1, func_expr, \u0026mut status); // A4\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a4_idx = 3 * 10 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_ref() {\n            assert!(cell.error);\n        }\n    }\n\n    #[test]\n    fn test_spreadsheet_display() {\n        use std::io::{self, Write};\n\n        // Create a spreadsheet for testing display\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup cells with various values and error states\n        let a1_idx = 0 * 10 + 0; // A1\n        let a2_idx = 1 * 10 + 0; // A2\n        let b1_idx = 0 * 10 + 1; // B1\n        let b2_idx = 1 * 10 + 1; // B2\n\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 42;\n            cell.error = false;\n        }\n\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 100;\n            cell.error = false;\n        }\n\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.value = 0; // Value doesn't matter when error=true\n            cell.error = true;\n        }\n\n        if let Some(cell) = sheet.cells[b2_idx].as_mut() {\n            cell.value = 200;\n            cell.error = false;\n        }\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            // Redirect stdout to our buffer temporarily\n            let original_stdout = io::stdout();\n            let mut handle = original_stdout.lock();\n\n            // Call spreadsheet_display\n            sheet.spreadsheet_display();\n\n            // Flush to ensure all output is captured\n            handle.flush().unwrap();\n        }\n\n        // Convert captured output to string\n        let output_str = String::from_utf8_lossy(\u0026output);\n\n        // Basic verification of output structure\n        // Note: We can't fully test the exact output string since it's being\n        // printed directly to stdout and we're not capturing it in this test.\n        // In a real test, we'd use something like `std::io::Cursor` to capture the output.\n\n        // Instead, we'll just verify the function doesn't panic\n        // A more comprehensive test would use a crate like `rexpect` or modify\n        // spreadsheet_display to accept a writer parameter.\n\n        // For now, this test just ensures the function runs without panicking\n        assert!(true);\n    }\n\n    #[test]\n    fn test_spreadsheet_display_view_window() {\n        // Test the view window functionality of spreadsheet_display\n        let mut sheet = Spreadsheet::spreadsheet_create(20, 20).unwrap();\n\n        // Set up some cell values\n        for r in 1..=20 {\n            for c in 1..=20 {\n                let index = (r - 1) as usize * 20 + (c - 1) as usize;\n                if let Some(cell) = sheet.cells[index].as_mut() {\n                    cell.value = (r * 100 + c) as i32;\n                }\n            }\n        }\n\n        // Test default view (0,0)\n        assert_eq!(sheet.view_row, 0);\n        assert_eq!(sheet.view_col, 0);\n\n        // Change view window\n        sheet.view_row = 5;\n        sheet.view_col = 5;\n\n        // Call display - this just tests it doesn't crash\n        sheet.spreadsheet_display();\n\n        // The displayed cells should now start from row 6, col 6\n        // Verify view window state\n        assert_eq!(sheet.view_row, 5);\n        assert_eq!(sheet.view_col, 5);\n\n        // Test with view at the edge\n        sheet.view_row = 15; // Should show rows 16-20\n        sheet.view_col = 15; // Should show cols 16-20\n\n        // Call display\n        sheet.spreadsheet_display();\n\n        // Verify window state\n        assert_eq!(sheet.view_row, 15);\n        assert_eq!(sheet.view_col, 15);\n    }\n    #[test]\n    fn test_undo_function_new() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Test setting a simple value\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(42));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        // Check initial state\n        let a1_idx = 0;\n        assert_eq!(sheet.cells[a1_idx].as_ref().unwrap().value, 42);\n\n        // Test undo\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[a1_idx].as_ref().unwrap().value, 0); // Cell should be reset to 0\n\n        // Second call to undo will redo the operation (revert to 42)\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[a1_idx].as_ref().unwrap().value, 42); // Cell should be reset to 42\n\n        // Set A1 to 100\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(100));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(sheet.cells[a1_idx].as_ref().unwrap().value, 100); // Cell should be set to 100\n\n        // Set A2 to 200\n        let a2_idx = 10; // row 2, col 1 (0-indexed)\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(200));\n        sheet.spreadsheet_set_cell_value(2, 1, val_expr, \u0026mut status);\n        assert_eq!(sheet.cells[a2_idx].as_ref().unwrap().value, 200); // Cell should be set to 200\n\n        // Set C1 to AVG(A1:A2)\n        let c1_idx = 2; // row 1, col 3 (0-indexed)\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.undo_stack.clear();\n        sheet.spreadsheet_set_cell_value(1, 3, avg_expr, \u0026mut status);\n        // eprintln!(\"value forÇ is {:?}\", sheet.cells[c1_idx]);\n        assert_eq!(sheet.cells[c1_idx].as_ref().unwrap().value, 150); // Cell should be set to 150\n\n        // Undo the AVG function in C1\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[c1_idx].as_ref().unwrap().value, 0); // Cell should be reset to 0\n\n        // Test undo with arithmetic operations\n        // Set A3 to A1 + 50\n        let a3_idx = 20; // row 3, col 1 (0-indexed)\n        let arith_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1),\n            operator: '+',\n            rhs: Operand::Number(50),\n        };\n        sheet.spreadsheet_set_cell_value(3, 1, arith_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        eprintln!(\"value of a3 is {:?}\", sheet.cells[a3_idx]);\n        assert_eq!(sheet.cells[a3_idx].as_ref().unwrap().value, 150); // 100 + 50\n\n        // Test undo with range functions\n        // Set A4 to SUM(A1:A3)\n        let a4_idx = 30; // row 4, col 1 (0-indexed)\n        let sum_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(3, 1), // A3\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 1, sum_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        assert_eq!(sheet.cells[a4_idx].as_ref().unwrap().value, 450); // 100 + 200 + 150\n\n        // Test undo of A4 SUM function\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[a4_idx].as_ref().unwrap().value, 0); // Reset A4 to 0\n\n        // Redo the SUM function in A4\n        sheet.spreadsheet_undo(\u0026mut status);\n        // The correct expected value is 450 because our implementation of undo is actually toggling\n        // between the two most recent states\n        assert_eq!(sheet.cells[a4_idx].as_ref().unwrap().value, 450); // A4 should be back to 450\n\n        // Test undo with SLEEP function\n        let a5_idx = 40; // row 5, col 1 (0-indexed)\n        let sleep_expr = ParsedRHS::Sleep(Operand::Number(1));\n        sheet.spreadsheet_set_cell_value(5, 1, sleep_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        assert_eq!(sheet.cells[a5_idx].as_ref().unwrap().value, 1);\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[a5_idx].as_ref().unwrap().value, 0);\n\n        // Test undo after setting a cell to an error state\n        let a6_idx = 50; // row 6, col 1 (0-indexed)\n        let div_zero_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(10),\n            operator: '/',\n            rhs: Operand::Number(0),\n        };\n        sheet.spreadsheet_set_cell_value(6, 1, div_zero_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        assert!(sheet.cells[a6_idx].as_ref().unwrap().error);\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert!(!sheet.cells[a6_idx].as_ref().unwrap().error);\n        assert_eq!(sheet.cells[a6_idx].as_ref().unwrap().value, 0);\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","cell.rs"],"content":"/// Module for handling individual spreadsheet cells and their dependencies.\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeSet;\n\nuse crate::spreadsheet::ParsedRHS; // Using BTreeSet as an AVL-tree-like ordered collection\n\n/// Represents a cell in a spreadsheet with its value, formula, and dependency information.\n///\n/// Each cell knows its position, current value, and which cells depend on it for calculations.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Cell {\n    /// Row index of the cell (1-based)\n    pub row: i16,\n    /// Column index of the cell (1-based)\n    pub col: i16,\n    /// Whether the cell contains an error\n    pub error: bool,\n    /// Current numeric value of the cell\n    pub value: i32,\n    /// Formula defining how the cell's value is calculated\n    pub formula: ParsedRHS,\n    /// Collection of cells that depend on this cell\n    pub dependents: Dependents,\n}\n\n/// Represents the collection of cells that depend on a particular cell.\n///\n/// This enum provides optimizations for different numbers of dependencies:\n/// - None for cells with no dependents\n/// - Vector for cells with few dependents (more efficient for small numbers)\n/// - Set for cells with many dependents (more efficient for lookups in large collections)\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub enum Dependents {\n    /// A vector of (row, column) pairs for efficient storage of small numbers of dependents\n    Vector(Vec\u003c(i16, i16)\u003e),\n    /// A sorted tree set for efficient lookups with many dependents\n    Set(BTreeSet\u003c(i16, i16)\u003e),\n    /// No dependencies\n    None,\n}\n\nimpl Cell {\n    /// Creates a new cell at the specified row and column.\n    ///\n    /// The cell is initialized with a value of 0, no error, no formula, and no dependents.\n    ///\n    /// # Arguments\n    /// * `row` - The row index (1-based)\n    /// * `col` - The column index (1-based)\n    ///\n    /// # Returns\n    /// A new Cell initialized at the specified position with default values.\n    ///\n    /// # Default Values\n    /// - value: 0\n    /// - error: false\n    /// - formula: None\n    /// - dependents: None\n    ///\n    /// # Example\n    /// ```\n    /// let cell = Cell::create(1, 1);\n    /// assert_eq!(cell.row, 1);\n    /// assert_eq!(cell.col, 1);\n    /// assert_eq!(cell.value, 0);\n    /// assert_eq!(cell.error, false);\n    /// ```\n    pub fn create(row: i16, col: i16) -\u003e Self {\n        Cell {\n            row,\n            col,\n            value: 0,\n            error: false,\n            formula: ParsedRHS::None,\n            dependents: Dependents::None,\n        }\n    }\n\n    /// Adds a dependency to this cell.\n    ///\n    /// Records that the cell at (row, col) depends on this cell's value.\n    /// Automatically upgrades from None to Vector to Set as needed for performance.\n    ///\n    /// # Arguments\n    /// * `row` - Row of the dependent cell\n    /// * `col` - Column of the dependent cell\n    ///\n    /// # Data Structure Optimization\n    /// This method implements a dynamic optimization strategy for tracking dependents:\n    /// - For 0 dependents: Uses `Dependents::None` (most memory efficient)\n    /// - For 1-7 dependents: Uses `Dependents::Vector` (fast for small numbers)\n    /// - For 8+ dependents: Upgrades to `Dependents::Set` (faster lookup for many items)\n    ///\n    /// # Performance Considerations\n    /// - Vector is more efficient for small numbers of dependents (faster iteration)\n    /// - BTreeSet is more efficient for larger numbers of dependents (faster lookup)\n    /// - The threshold of 7 was chosen based on empirical performance testing\n    pub fn dep_insert(\u0026mut self, row: i16, col: i16) {\n        // Set the initialised flag to 1 whenever a dependency is added\n        let key = (row, col);\n\n        match \u0026mut self.dependents {\n            Dependents::None =\u003e {\n                let v = vec![key];\n                self.dependents = Dependents::Vector(v);\n            }\n            Dependents::Vector(vec) =\u003e {\n                if vec.len() \u003e 7 {\n                    // Convert to OrderedSet\n                    let mut set = BTreeSet::new();\n                    for item in vec.iter() {\n                        set.insert(*item);\n                    }\n                    set.insert(key);\n                    self.dependents = Dependents::Set(set);\n                    // self.container = 1;\n                } else {\n                    vec.push(key);\n                }\n            }\n            Dependents::Set(set) =\u003e {\n                set.insert(key);\n            }\n        }\n    }\n\n    /// Removes a dependency from this cell.\n    ///\n    /// Removes the record that the cell at (row, col) depends on this cell's value.\n    ///\n    /// # Arguments\n    /// * `row` - Row of the no-longer-dependent cell\n    /// * `col` - Column of the no-longer-dependent cell\n    ///\n    /// # Behavior\n    /// - For `Dependents::Vector`: Uses retain to filter out the specified cell\n    /// - For `Dependents::Set`: Uses the set's remove method\n    /// - For `Dependents::None`: Does nothing\n    ///\n    /// # Note\n    /// This method does not downgrade from Set to Vector or Vector to None\n    /// when dependents are removed, as this would add complexity with minimal benefit.\n    pub fn dep_remove(\u0026mut self, row: i16, col: i16) {\n        let key = (row, col);\n        match \u0026mut self.dependents {\n            Dependents::Vector(vec) =\u003e {\n                vec.retain(|k| k != \u0026key);\n            }\n            Dependents::Set(set) =\u003e {\n                set.remove(\u0026key);\n            }\n            Dependents::None =\u003e {}\n        }\n    }\n\n    /// Checks if a cell depends on this cell.\n    ///\n    /// # Arguments\n    /// * `row` - Row of the cell to check\n    /// * `col` - Column of the cell to check\n    ///\n    /// # Returns\n    /// `true` if the specified cell depends on this cell, `false` otherwise\n    ///\n    /// # Performance\n    /// - For `Dependents::Vector`: O(n) lookup time\n    /// - For `Dependents::Set`: O(log n) lookup time\n    /// - For `Dependents::None`: O(1) (always returns false)\n    pub fn contains(\u0026self, row: i16, col: i16) -\u003e bool {\n        let key = (row, col);\n        match \u0026self.dependents {\n            Dependents::Vector(vec) =\u003e vec.iter().any(|k| k == \u0026key),\n            Dependents::Set(set) =\u003e set.contains(\u0026key),\n            Dependents::None =\u003e false,\n        }\n    }\n}\n\n// Public interface functions that match the C API\n\n/// Creates a new cell at the specified row and column.\n///\n/// This function provides a C-compatible interface for creating cells,\n/// returning a Box\u003cCell\u003e instead of a plain Cell to match external API expectations.\n///\n/// # Arguments\n/// * `row` - The row index (1-based)\n/// * `col` - The column index (1-based)\n///\n/// # Returns\n/// A boxed Cell for use with external API calls\n///\n/// # Example\n/// ```\n/// let cell = cell_create(1, 1);\n/// assert_eq!(cell.row, 1);\n/// assert_eq!(cell.col, 1);\n/// ```\npub fn cell_create(row: i16, col: i16) -\u003e Box\u003cCell\u003e {\n    Box::new(Cell::create(row, col))\n}\n\n/// Adds a dependency to a cell.\n///\n/// This function provides a C-compatible interface for the Cell::dep_insert method.\n/// It records that the cell at (row, col) depends on the given cell's value.\n///\n/// # Arguments\n/// * `cell` - The cell that is being depended on (the dependency)\n/// * `row` - Row of the dependent cell (the cell that depends on `cell`)\n/// * `col` - Column of the dependent cell (the cell that depends on `cell`)\n///\n/// # Example\n/// ```\n/// let mut cell_a1 = cell_create(1, 1);\n/// // Record that B2 depends on A1\n/// cell_dep_insert(\u0026mut cell_a1, 2, 2);\n/// ```\npub fn cell_dep_insert(cell: \u0026mut Cell, row: i16, col: i16) {\n    cell.dep_insert(row, col);\n}\n\n/// Removes a dependency from a cell.\n///\n/// This function provides a C-compatible interface for the Cell::dep_remove method.\n/// It removes the record that the cell at (row, col) depends on the given cell's value.\n///\n/// # Arguments\n/// * `cell` - The cell that was being depended on (the dependency)\n/// * `row` - Row of the no-longer-dependent cell\n/// * `col` - Column of the no-longer-dependent cell\n///\n/// # Example\n/// ```\n/// let mut cell_a1 = cell_create(1, 1);\n/// // Record that B2 no longer depends on A1\n/// cell_dep_remove(\u0026mut cell_a1, 2, 2);\n/// ```\npub fn cell_dep_remove(cell: \u0026mut Cell, row: i16, col: i16) {\n    cell.dep_remove(row, col);\n}\n\n/// Checks if a cell depends on the given cell.\n///\n/// This function provides a C-compatible interface for the Cell::contains method.\n///\n/// # Arguments\n/// * `cell` - The cell that may be depended on\n/// * `row` - Row of the cell to check\n/// * `col` - Column of the cell to check\n///\n/// # Returns\n/// `true` if the specified cell depends on the given cell, `false` otherwise\n///\n/// # Example\n/// ```\n/// let mut cell_a1 = cell_create(1, 1);\n/// cell_dep_insert(\u0026mut cell_a1, 2, 2);\n/// assert!(cell_contains(\u0026cell_a1, 2, 2));\n/// assert!(!cell_contains(\u0026cell_a1, 3, 3));\n/// ```\npub fn cell_contains(cell: \u0026Cell, row: i16, col: i16) -\u003e bool {\n    cell.contains(row, col)\n}\n","traces":[{"line":68,"address":[],"length":0,"stats":{"Line":18301431}},{"line":98,"address":[],"length":0,"stats":{"Line":235}},{"line":100,"address":[],"length":0,"stats":{"Line":235}},{"line":102,"address":[],"length":0,"stats":{"Line":235}},{"line":103,"address":[],"length":0,"stats":{"Line":56}},{"line":104,"address":[],"length":0,"stats":{"Line":56}},{"line":105,"address":[],"length":0,"stats":{"Line":56}},{"line":107,"address":[],"length":0,"stats":{"Line":177}},{"line":108,"address":[],"length":0,"stats":{"Line":177}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":68}},{"line":112,"address":[],"length":0,"stats":{"Line":32}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":173}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":89}},{"line":144,"address":[],"length":0,"stats":{"Line":89}},{"line":145,"address":[],"length":0,"stats":{"Line":89}},{"line":146,"address":[],"length":0,"stats":{"Line":77}},{"line":147,"address":[],"length":0,"stats":{"Line":286}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":43}},{"line":170,"address":[],"length":0,"stats":{"Line":43}},{"line":171,"address":[],"length":0,"stats":{"Line":43}},{"line":172,"address":[],"length":0,"stats":{"Line":36}},{"line":173,"address":[],"length":0,"stats":{"Line":26}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":199,"address":[],"length":0,"stats":{"Line":18301431}},{"line":200,"address":[],"length":0,"stats":{"Line":18301431}},{"line":219,"address":[],"length":0,"stats":{"Line":235}},{"line":220,"address":[],"length":0,"stats":{"Line":235}},{"line":239,"address":[],"length":0,"stats":{"Line":89}},{"line":240,"address":[],"length":0,"stats":{"Line":89}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}}],"covered":39,"coverable":39},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","downloader.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse crate::spreadsheet::Spreadsheet;\nuse std::error::Error;\n\n/// Convert spreadsheet to CSV format\n///\n/// This function exports a spreadsheet to CSV (Comma-Separated Values) format.\n/// It creates a string with the spreadsheet data where:\n/// - Column headers are letters (A, B, C, etc.)\n/// - Values are comma-separated\n/// - Special characters (commas, quotes, newlines) are properly escaped\n///\n/// # Arguments\n/// * `sheet` - Reference to the spreadsheet to convert\n///\n/// # Returns\n/// * `Result\u003cString, Box\u003cdyn Error\u003e\u003e` - CSV content as a string or an error\n///\n/// # Examples\n/// ```\n/// use cop::spreadsheet::Spreadsheet;\n/// use cop::downloader::to_csv;\n///\n/// let sheet = Spreadsheet::spreadsheet_create(5, 5).unwrap();\n/// match to_csv(\u0026sheet) {\n///     Ok(csv) =\u003e println!(\"CSV generated: {} bytes\", csv.len()),\n///     Err(e) =\u003e eprintln!(\"Failed to generate CSV: {}\", e),\n/// }\n/// ```\npub fn to_csv(sheet: \u0026Spreadsheet) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n    let mut csv_content = String::new();\n\n    // Add header row with column letters\n    for c in 1..=sheet.cols {\n        if c \u003e 1 {\n            csv_content.push(',');\n        }\n        csv_content.push_str(\u0026column_to_letter(c as u16));\n    }\n    csv_content.push('\\n');\n\n    // Add data rows\n    for r in 1..=sheet.rows {\n        for c in 1..=sheet.cols {\n            if c \u003e 1 {\n                csv_content.push(',');\n            }\n\n            let index = ((r - 1) * sheet.cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                // Handle value - escape commas, quotes, newlines as needed\n                let value = cell.value.to_string();\n                if value.contains(',') || value.contains('\"') || value.contains('\\n') {\n                    let escaped = value.replace(\"\\\"\", \"\\\"\\\"\");\n                    csv_content.push_str(\u0026format!(\"\\\"{}\\\"\", escaped));\n                } else {\n                    csv_content.push_str(\u0026value);\n                }\n            }\n        }\n        csv_content.push('\\n');\n    }\n\n    Ok(csv_content)\n}\n\n/// Convert spreadsheet to XLSX format\n///\n/// This function exports a spreadsheet to XLSX (Excel) format using the rust_xlsxwriter library.\n/// It preserves all cell values in a format that Microsoft Excel and other spreadsheet applications can open.\n///\n/// # Arguments\n/// * `sheet` - Reference to the spreadsheet to convert\n///\n/// # Returns\n/// * `Result\u003cVec\u003cu8\u003e, Box\u003cdyn Error\u003e\u003e` - XLSX file content as bytes or an error\n///\n/// # Examples\n/// ```\n/// use cop::spreadsheet::Spreadsheet;\n/// use cop::downloader::to_xlsx;\n///\n/// let sheet = Spreadsheet::spreadsheet_create(5, 5).unwrap();\n/// match to_xlsx(\u0026sheet) {\n///     Ok(xlsx_data) =\u003e println!(\"XLSX generated: {} bytes\", xlsx_data.len()),\n///     Err(e) =\u003e eprintln!(\"Failed to generate XLSX: {}\", e),\n/// }\n/// ```\npub fn to_xlsx(sheet: \u0026Spreadsheet) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn Error\u003e\u003e {\n    use rust_xlsxwriter::{Workbook, Worksheet};\n\n    // Create a new workbook and worksheet\n    let mut workbook = Workbook::new();\n    let mut worksheet = Worksheet::new();\n\n    // Write cell data\n    for r in 1..=sheet.rows {\n        for c in 1..=sheet.cols {\n            let index = ((r - 1) * sheet.cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                worksheet.write_number((r - 1) as u32, (c - 1) as u16, cell.value)?;\n            }\n        }\n    }\n\n    workbook.push_worksheet(worksheet);\n\n    // Save to memory buffer - corrected method call\n    let buffer = workbook.save_to_buffer()?;\n\n    Ok(buffer)\n}\n\n/// Convert column number to letter (A=1, B=2, etc.)\n///\n/// Helper function that converts a numerical column index to a spreadsheet-style\n/// column letter (A, B, C, ..., Z, AA, AB, etc.).\n///\n/// # Arguments\n/// * `col` - Column number (1-based)\n///\n/// # Returns\n/// * `String` - Column letter (A, B, C, etc.)\n///\n/// # Examples\n/// ```\n/// use cop::downloader::column_to_letter;\n///\n/// assert_eq!(column_to_letter(1), \"A\");\n/// assert_eq!(column_to_letter(26), \"Z\");\n/// assert_eq!(column_to_letter(27), \"AA\");\n/// assert_eq!(column_to_letter(52), \"AZ\");\n/// ```\nfn column_to_letter(col: u16) -\u003e String {\n    let mut name = String::new();\n    let mut n = col;\n\n    while n \u003e 0 {\n        n -= 1;\n        name.insert(0, (b'A' + (n % 26) as u8) as char);\n        n /= 26;\n    }\n\n    name\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","graph.rs"],"content":"#![cfg(not(tarpaulin_include))]\nuse crate::spreadsheet::Spreadsheet;\nuse plotters::prelude::*;\nuse std::fs::remove_file;\n\n/// Available graph types supported by the application\n///\n/// This enum defines the different visualization formats that can be generated\n/// from spreadsheet data.\n#[derive(Clone, Debug)]\npub enum GraphType {\n    /// Line graph - Shows trends over time or continuous data with lines\n    /// connecting data points\n    Line,\n\n    /// Bar graph - Compares values across different categories with rectangular bars\n    Bar,\n\n    /// Scatter plot - Shows the relationship between two variables with points\n    Scatter,\n\n    /// Area graph - Similar to line graphs but with the area below the line filled in\n    Area,\n}\n\n/// Configuration options for graph generation\n///\n/// This structure contains all the customizable properties for generating\n/// different types of graphs.\n#[derive(Clone, Debug)]\npub struct GraphOptions {\n    /// Title displayed at the top of the graph\n    pub title: String,\n\n    /// Label for the X-axis\n    pub x_label: String,\n\n    /// Label for the Y-axis\n    pub y_label: String,\n\n    /// Width of the graph in pixels\n    pub width: u32,\n\n    /// Height of the graph in pixels\n    pub height: u32,\n\n    /// Type of graph to generate\n    pub graph_type: GraphType,\n}\n\nimpl Default for GraphOptions {\n    /// Creates a default configuration for graph generation\n    ///\n    /// # Returns\n    /// * `GraphOptions` - Default configuration with:\n    ///   - Line graph type\n    ///   - 800x600 pixel dimensions\n    ///   - Generic labels\n    fn default() -\u003e Self {\n        Self {\n            title: \"Graph\".to_string(),\n            x_label: \"X Axis\".to_string(),\n            y_label: \"Y Axis\".to_string(),\n            width: 800,\n            height: 600,\n            graph_type: GraphType::Line,\n        }\n    }\n}\n\n/// Creates a graph from spreadsheet data\n///\n/// This is the main entry point for generating graphs from spreadsheet data.\n/// It parses cell ranges, extracts data, and delegates to the appropriate graph type generator.\n///\n/// # Arguments\n/// * `spreadsheet` - Reference to the spreadsheet containing the data\n/// * `x_range` - Range for X values (e.g., \"A1:A10\")\n/// * `y_range` - Range for Y values (e.g., \"B1:B10\")\n/// * `options` - Graph styling and type options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes or an error\n///\n/// # Examples\n/// ```\n/// use cop::spreadsheet::Spreadsheet;\n/// use cop::graph::{GraphOptions, GraphType, create_graph};\n///\n/// let spreadsheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n///\n/// let options = GraphOptions {\n///     title: \"Sample Graph\".to_string(),\n///     x_label: \"X Values\".to_string(),\n///     y_label: \"Y Values\".to_string(),\n///     width: 800,\n///     height: 600,\n///     graph_type: GraphType::Line,\n/// };\n///\n/// match create_graph(\u0026spreadsheet, \"A1:A5\", \"B1:B5\", options) {\n///     Ok(png_data) =\u003e println!(\"Graph created successfully: {} bytes\", png_data.len()),\n///     Err(e) =\u003e eprintln!(\"Failed to create graph: {}\", e),\n/// }\n/// ```\npub fn create_graph(\n    spreadsheet: \u0026Spreadsheet,\n    x_range: \u0026str,\n    y_range: \u0026str,\n    options: GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse the ranges to get the actual cells\n    let (x_cells, y_cells) = parse_ranges(spreadsheet, x_range, y_range)?;\n\n    // Extract the data from the cells\n    let data: Vec\u003c(i32, i32)\u003e = x_cells\n        .iter()\n        .zip(y_cells.iter())\n        .map(|(x, y)| (*x, *y))\n        .collect();\n\n    match options.graph_type {\n        GraphType::Line =\u003e create_line_graph(data, \u0026options),\n        GraphType::Bar =\u003e create_bar_graph(data, \u0026options),\n        GraphType::Scatter =\u003e create_scatter_graph(data, \u0026options),\n        // GraphType::Pie =\u003e create_pie_graph(data, \u0026options),\n        GraphType::Area =\u003e create_area_graph(data, \u0026options),\n    }\n}\n\n/// Parses the range strings and returns the cell values\n///\n/// This function extracts numerical data from spreadsheet ranges for graphing purposes.\n/// It supports both column ranges (A1:A10) and row ranges (A1:J1).\n///\n/// # Arguments\n/// * `spreadsheet` - Reference to the spreadsheet to extract data from\n/// * `x_range` - Range specification for X values (e.g., \"A1:A10\")\n/// * `y_range` - Range specification for Y values (e.g., \"B1:B10\")\n///\n/// # Returns\n/// * A Result containing vectors of extracted X and Y values or an error\n///\n/// # Errors\n/// * Returns an error if the range format is invalid\n/// * Returns an error if the ranges have different lengths\n///\n/// # Notes\n/// * Empty cells in the range will be treated as having a value of 0\nfn parse_ranges(\n    spreadsheet: \u0026Spreadsheet,\n    x_range: \u0026str,\n    y_range: \u0026str,\n) -\u003e Result\u003c(Vec\u003ci32\u003e, Vec\u003ci32\u003e), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Split the range at the colon\n    let x_parts: Vec\u003c\u0026str\u003e = x_range.split(':').collect();\n    let y_parts: Vec\u003c\u0026str\u003e = y_range.split(':').collect();\n\n    if x_parts.len() != 2 || y_parts.len() != 2 {\n        return Err(\"Invalid range format. Expected format: A1:A10\".into());\n    }\n\n    // Parse the cell coordinates\n    let (x_start_row, x_start_col) = match spreadsheet.spreadsheet_parse_cell_name(x_parts[0]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid start cell in X range\".into()),\n    };\n\n    let (x_end_row, x_end_col) = match spreadsheet.spreadsheet_parse_cell_name(x_parts[1]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid end cell in X range\".into()),\n    };\n\n    let (y_start_row, y_start_col) = match spreadsheet.spreadsheet_parse_cell_name(y_parts[0]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid start cell in Y range\".into()),\n    };\n\n    let (y_end_row, y_end_col) = match spreadsheet.spreadsheet_parse_cell_name(y_parts[1]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid end cell in Y range\".into()),\n    };\n\n    // Ensure the ranges have the same length\n    let x_len = if x_start_col == x_end_col {\n        (x_end_row - x_start_row + 1) as usize\n    } else {\n        (x_end_col - x_start_col + 1) as usize\n    };\n\n    let y_len = if y_start_col == y_end_col {\n        (y_end_row - y_start_row + 1) as usize\n    } else {\n        (y_end_col - y_start_col + 1) as usize\n    };\n\n    if x_len != y_len {\n        return Err(\"X and Y ranges must have the same length\".into());\n    }\n\n    // Extract values\n    let mut x_values = Vec::with_capacity(x_len);\n    let mut y_values = Vec::with_capacity(y_len);\n\n    // Handle vertical ranges (same column)\n    if x_start_col == x_end_col {\n        for row in x_start_row..=x_end_row {\n            let index = ((row - 1) * spreadsheet.cols + (x_start_col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                x_values.push(cell.value);\n            } else {\n                x_values.push(0);\n            }\n        }\n    } else {\n        // Handle horizontal ranges (same row)\n        for col in x_start_col..=x_end_col {\n            let index = ((x_start_row - 1) * spreadsheet.cols + (col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                x_values.push(cell.value);\n            } else {\n                x_values.push(0);\n            }\n        }\n    }\n\n    // Do the same for Y values\n    if y_start_col == y_end_col {\n        for row in y_start_row..=y_end_row {\n            let index = ((row - 1) * spreadsheet.cols + (y_start_col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                y_values.push(cell.value);\n            } else {\n                y_values.push(0);\n            }\n        }\n    } else {\n        for col in y_start_col..=y_end_col {\n            let index = ((y_start_row - 1) * spreadsheet.cols + (col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                y_values.push(cell.value);\n            } else {\n                y_values.push(0);\n            }\n        }\n    }\n\n    Ok((x_values, y_values))\n}\n\n/// Creates a line graph from data points\n///\n/// Generates a line graph showing the trend between X and Y values with connected lines.\n/// Line graphs are ideal for showing trends over continuous data.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes or an error\n///\n/// # Implementation Notes\n/// * Creates a temporary file to store the image before reading it back\n/// * Automatically scales axes based on data range\n/// * Uses blue color for the line series\nfn create_line_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        chart.draw_series(LineSeries::new(\n            data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            \u0026BLUE,\n        ))?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let mut file = std::fs::File::open(filename)?;\n    let mut buffer = Vec::new();\n    use std::io::Read;\n    file.read_to_end(\u0026mut buffer)?;\n    remove_file(filename)?;\n    Ok(buffer)\n}\n\n/// Saves a line graph to a file\n///\n/// Creates a line graph and saves it directly to the specified file path.\n/// Useful for generating examples or saving graphs without returning the image data.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n/// * `path` - File path where the graph should be saved\n///\n/// # Returns\n/// * A Result indicating success or failure\nfn save_line_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    chart.draw_series(LineSeries::new(\n        data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n        \u0026RED,\n    ))?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates a bar graph from data points\n///\n/// Generates a bar graph showing values as vertical bars.\n/// Bar graphs are ideal for comparing values across different categories.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points, where x is the category position and y is the value\n/// * `options` - Graph styling options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes or an error\n///\n/// # Implementation Notes\n/// * Creates a temporary file to store the image before reading it back\n/// * Uses blue color for bars with solid fill\n/// * Each x-value positions a bar with the height of the corresponding y-value\nfn create_bar_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x..*max_x + 1;\n        let y_range = 0..*max_y + 1;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        // Draw wider bars with solid fill and clear borders\n        chart.draw_series(\n            data.iter()\n                .map(|\u0026(x, y)| Rectangle::new([(x - 2, 0), (x + 2, y)], BLUE.filled())),\n        )?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let png_data = std::fs::read(filename)?;\n\n    // Clean up\n    remove_file(filename)?;\n\n    Ok(png_data)\n}\n\n/// Saves a bar graph to a file\n///\n/// Creates a bar graph and saves it directly to the specified file path.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n/// * `path` - File path where the graph should be saved\n///\n/// # Returns\n/// * A Result indicating success or failure\n///\n/// # Implementation Notes\n/// * Bars are sized based on the x value - adjacent x values will create adjacent bars\n/// * Bar width is set to 0.8 units (from x-0.4 to x+0.4) for visual clarity\nfn save_bar_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x..*max_x + 1;\n    let y_range = 0..*max_y + 1;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart.draw_series(data.iter().map(|\u0026(x, y)| {\n        Rectangle::new(\n            [((x as f64 - 0.4) as i32, 0), ((x as f64 + 0.4) as i32, y)],\n            BLUE.filled(),\n        )\n    }))?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates a scatter plot from data points\n///\n/// Generates a scatter plot showing individual data points without connecting lines.\n/// Scatter plots are ideal for visualizing the relationship between two variables.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes or an error\n///\n/// # Implementation Notes\n/// * Creates a temporary file to store the image before reading it back\n/// * Uses green circles with 5-pixel radius for data points\n/// * Automatically scales axes based on data range\nfn create_scatter_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        chart.draw_series(\n            data.iter()\n                .map(|\u0026(x, y)| Circle::new((x as f64, y as f64), 5, GREEN.filled())),\n        )?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let png_data = std::fs::read(filename)?;\n\n    // Clean up\n    remove_file(filename)?;\n\n    Ok(png_data)\n}\n\n/// Saves a scatter plot to a file\n///\n/// Creates a scatter plot and saves it directly to the specified file path.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n/// * `path` - File path where the graph should be saved\n///\n/// # Returns\n/// * A Result indicating success or failure\nfn save_scatter_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    chart.draw_series(\n        data.iter()\n            .map(|\u0026(x, y)| Circle::new((x as f64, y as f64), 5, GREEN.filled())),\n    )?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates an area graph from data points\n///\n/// Generates an area graph showing values with the area under the line filled in.\n/// Area graphs are good for emphasizing the magnitude of changes over time.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes or an error\n///\n/// # Implementation Notes\n/// * Creates a temporary file to store the image before reading it back\n/// * Uses semi-transparent blue for the area fill\n/// * Sorts data points by x-value to ensure proper area filling\n/// * Area is filled between the line and y=0\nfn create_area_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260).min(\u00260); // Ensure we include 0\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range.clone(), y_range.clone())?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        // Sort data by x to ensure proper area graph\n        let mut sorted_data = data.clone();\n        sorted_data.sort_by_key(|\u0026(x, _)| x);\n\n        use plotters::series::AreaSeries;\n        use plotters::style::RGBAColor;\n\n        // Draw the area graph\n        chart.draw_series(AreaSeries::new(\n            sorted_data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            0.0,\n            RGBAColor(30, 144, 255, 0.5), // semi-transparent blue\n        ))?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let mut file = std::fs::File::open(filename)?;\n    let mut buffer = Vec::new();\n    use std::io::Read;\n    file.read_to_end(\u0026mut buffer)?;\n    remove_file(filename)?;\n    Ok(buffer)\n}\n\n/// Saves an area graph to a file\n///\n/// Creates an area graph and saves it directly to the specified file path.\n///\n/// # Arguments\n/// * `data` - Vector of (x,y) data points\n/// * `options` - Graph styling options\n/// * `path` - File path where the graph should be saved\n///\n/// # Returns\n/// * A Result indicating success or failure\n///\n/// # Implementation Notes\n/// * Sorts data by x-value to ensure proper area filling\n/// * Uses 20% opacity blue fill with blue border\nfn save_area_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260).min(\u00260); // Ensure we include 0\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    // Sort data by x to ensure proper area graph\n    let mut sorted_data = data.clone();\n    sorted_data.sort_by_key(|\u0026(x, _)| x);\n\n    chart.draw_series(\n        AreaSeries::new(\n            sorted_data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            0.0,\n            BLUE.mix(0.2),\n        )\n        .border_style(BLUE),\n    )?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates example graphs for demonstration purposes\n///\n/// Generates a set of example graphs (line, bar, scatter, area) using sample data\n/// and saves them to disk in the \"graph_output\" directory.\n///\n/// # Returns\n/// * A vector of tuples containing graph type name and file path\n///\n/// # Examples\n/// ```\n/// use cop::graph::create_example_graphs;\n///\n/// let examples = create_example_graphs();\n/// for (graph_type, path) in examples {\n///     println!(\"Created {} graph at {}\", graph_type, path);\n/// }\n/// ```\n///\n/// # Implementation Notes\n/// * Creates a directory \"graph_output\" if it doesn't exist\n/// * Generates a sample dataset with 7 data points\n/// * Creates one graph of each type with standard options\npub fn create_example_graphs() -\u003e Vec\u003c(String, String)\u003e {\n    let mut result = Vec::new();\n\n    // Create output directory if it doesn't exist\n    let output_dir = \"graph_output\";\n    std::fs::create_dir_all(output_dir).unwrap_or_else(|_| {\n        eprintln!(\"Output directory already exists or couldn't be created\");\n    });\n\n    // Create sample data\n    let data: Vec\u003c(i32, i32)\u003e = vec![\n        (1, 10),\n        (2, 25),\n        (3, 15),\n        (4, 30),\n        (5, 22),\n        (6, 40),\n        (7, 35),\n    ];\n\n    // Standard options for all examples\n    let base_options = GraphOptions {\n        title: \"Example Graph\".to_string(),\n        x_label: \"X Values\".to_string(),\n        y_label: \"Y Values\".to_string(),\n        width: 600,\n        height: 400,\n        graph_type: GraphType::Line,\n    };\n\n    // Line graph\n    let mut line_options = base_options.clone();\n    line_options.title = \"Example Line Graph\".to_string();\n    line_options.graph_type = GraphType::Line;\n    let line_path = format!(\"{}/line_graph.png\", output_dir);\n    if save_line_graph(data.clone(), \u0026line_options, \u0026line_path).is_ok() {\n        result.push((\"Line\".to_string(), line_path));\n    }\n\n    // Bar graph\n    let mut bar_options = base_options.clone();\n    bar_options.title = \"Example Bar Graph\".to_string();\n    bar_options.graph_type = GraphType::Bar;\n    let bar_path = format!(\"{}/bar_graph.png\", output_dir);\n    if save_bar_graph(data.clone(), \u0026bar_options, \u0026bar_path).is_ok() {\n        result.push((\"Bar\".to_string(), bar_path));\n    }\n\n    // Scatter graph\n    let mut scatter_options = base_options.clone();\n    scatter_options.title = \"Example Scatter Graph\".to_string();\n    scatter_options.graph_type = GraphType::Scatter;\n    let scatter_path = format!(\"{}/scatter_graph.png\", output_dir);\n    if save_scatter_graph(data.clone(), \u0026scatter_options, \u0026scatter_path).is_ok() {\n        result.push((\"Scatter\".to_string(), scatter_path));\n    }\n\n    // Area graph\n    let mut area_options = base_options.clone();\n    area_options.title = \"Example Area Graph\".to_string();\n    area_options.graph_type = GraphType::Area;\n    let area_path = format!(\"{}/area_graph.png\", output_dir);\n    if save_area_graph(data.clone(), \u0026area_options, \u0026area_path).is_ok() {\n        result.push((\"Area\".to_string(), area_path));\n    }\n\n    result\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","lib.rs"],"content":"/*!\n# Spreadsheet Application\n\nA browser-based spreadsheet application with Excel-like functionality, fully implemented in Rust.\n\nThis application is a complete rewrite of a legacy spreadsheet tool from C to Rust, enhanced with modern features and a browser GUI using WebAssembly. It features a modular, maintainable, and performant design with support for advanced operations like dependency-tracked formulas, graph plotting, and file sharing.\n\n---\n\n## 📦 Project Summary\n\n- **Frontend**: HTML, CSS, WebAssembly (via `eframe`)\n- **Backend**: Rust (via `actix-web`)\n- **Persistence**: Gzip + Bincode for `.bin.gz`; CSV/XLSX support\n- **Graph Support**: Line, bar, area, scatter via `plotters`\n- **Authentication**: Sessions, password reset, cookie-based auth\n- **Key Features**: Copy/paste, undo/redo, formula evaluation, dependency graph, public/private sheet sharing\n\n---\n\n## 🏗️ Architecture\n\n### Frontend Layer\n- Written in HTML/CSS + WebAssembly using `eframe`\n- Renders a 10×10 visible grid window\n- Formula bar component for inline editing\n- Handles mouse, keyboard, and touchpad interactions\n- Sends commands to backend via WebAssembly bindings\n\n### Backend Layer\n- Built using `actix-web`\n- Contains spreadsheet logic, cell storage, command processing\n- Manages dependencies, error handling, and formula evaluation\n- Ensures recalculations respect topological order\n- Implements cell cycle detection and error propagation\n\n### Data Persistence Layer\n- Custom binary format with `.bin.gz` extension\n- Serialization via `bincode` + `serde`, compression with `gzip`\n- File versioning supports undo/redo state tracking\n- CSV and XLSX export via `downloader` module\n\n---\n\n## 🔧 Modules\n\n### `cell` Module\n- Core `Cell` structure storing value, formula, dependents\n- Methods for dependency management (insert, remove, check)\n- Formula parsing and validation\n- Location tracking via row/column coordinates\n\n### `spreadsheet` Module\n- Main logic; manages grid, evaluation, updates\n- Formula evaluation engine with function support\n- Dependency tracking with cycle detection\n- Topological sorting for correct update order\n- Command processing (set cell, copy/paste, undo/redo)\n- Error handling and propagation\n\n### `login` Module\n- User registration, session validation, password reset\n- Cookie-based authentication system\n- User data persistence via JSON\n- File access permission management\n\n### `mailer` Module\n- Sends password reset links via email\n- Template-based email generation\n- SMTP connection management\n\n### `saving` Module\n- Save/load logic with gzip+bincode\n- File version management\n- State tracking for undo/redo operations\n- Compressed binary format for efficient storage\n\n### `downloader` Module\n- Data export in CSV/XLSX formats\n- Format conversion utilities\n- Download request handling\n\n### `graph` Module\n- Graph plotting via `plotters`\n- Support for line, bar, area, scatter charts\n- Customizable titles, labels, and dimensions\n- Image data generation for browser display\n\n---\n\n## 🌐 Webserver\n\n### Public Endpoints\n- **Authentication**: `/login`, `/signup`, `/logout`, `/reset-password`, `/forgot-password`, `/change-password`\n- **Public Access**: `/:username/:sheet_name` for read-only sheet access\n- **API Access**: `/api/sheet`, `/api/cell/:cell_name`, `/api/sheet_info` for read-only data\n- **Static Content**: Static assets from `/static`\n\n### Protected Endpoints\n- **Sheet Management**: `/sheet` for editing UI\n- **Data Operations**: `/api/update_cell`, `/api/save`, `/api/load`, `/api/graph`, `/api/export`\n- **Downloads**: `/api/download/csv`, `/api/download/xlsx`\n- **File Operations**: `/:username` (file listing), `/:username/create` (create new sheet),\n  `/:username/:sheet_name/status` (update access), `/:username/:sheet_name/delete` (deletion)\n\n### Middleware Logic\n- Auth checks via `require_auth` middleware for protected endpoints\n- Session map maintained for user state with expiration time\n- Public/private file access logic via metadata in `list.json`\n- Redirection to login page for unauthorized access attempts\n\n---\n\n## 🔍 Features\n\n### Formula Support\n- Basic operations: `+`, `-`, `*`, `/`\n- Functions: `SUM`, `AVG`, `MAX`, `MIN`, `STDEV`, `SLEEP`\n- Formula processing with regex-based parsing\n- One-time parsing optimization for performance\n\n### Dependency Management\n- Dependency graph with automated updating\n- Cycle detection algorithm to prevent circular references\n- Topological sort for ordered recalculation\n- Error propagation through dependent cells\n\n### User Interface\n- Copy/paste support with range validation\n- Undo/redo through versioned states\n- Navigation via keyboard/mouse/touchpad\n- Formula bar for direct formula editing\n\n### Error Handling\n- Division by zero detection and propagation\n- Syntax error identification in formulas\n- Cycle detection with clear error messages\n- Cascading errors through dependent cells\n\n### Data Visualization\n- Graph plotting with customizable options\n- Support for multiple chart types\n- Title and axis labeling\n- Dimension configuration\n\n### Sharing \u0026 Access Control\n- Public/private spreadsheet access\n- Spreadsheet sharing by URL\n- User-based access control\n- Metadata tracking of file ownership\n\n---\n\n## 🔒 Security Model\n\n- Input sanitization for formulas and commands\n- Public/private access enforcement via metadata\n- Session-based access control with expiration\n- Authentication middleware for protected endpoints\n- Cookie validation for session management\n\n---\n\n## 🧠 Key Design Decisions\n\n### Data Structures\n- `Spreadsheet`: Container for cells, viewport management, undo stack\n- `Cell`: Value, formula, dependents, location storage\n- `Formula` enum: Extensible function handling with variant types\n- Hybrid approach for dependency tracking:\n  - `Vec` for initial, small dependency lists\n  - `OrderedSet` (AVL tree) for larger dependency collections\n- Tuple indices `(row, col)` instead of strings for memory efficiency\n\n### Optimizations\n- `regex` for one-time formula parsing (no repeated parsing)\n- `lazy_static!` for precompiled regexes\n- Topological sort for dependency-ordered recalculation\n- `u16` for index compression to save memory\n- Stack-based recursion elimination\n- Sparse cell storage to reduce memory footprint\n\n### Communication Flow\n1. User actions trigger WebAssembly functions\n2. WebAssembly communicates with Rust backend\n3. Backend processes commands and updates state\n4. Dependency resolution triggers recalculation\n5. Updated state returns to frontend for rendering\n6. Changes persist to storage in compressed format\n\n---\n\n## 📉 Performance Optimizations\n\n- Reduced memory footprint with sparse cell storage\n- Use of `u16` for row/column indices instead of larger types\n- Optimized dependency graph updates with topological ordering\n- No redundant formula parsing (one-time evaluation)\n- Precompiled regex + tuple indices for faster dependency lookups\n- Profiling with `flamegraph` used to identify and improve bottlenecks\n- Optimized memory allocation by reusing data structures\n\n---\n\n## ⚠️ Covered Edge Cases\n\n### Circular Dependencies\n- Direct cycles (e.g., A1 = B1, B1 = A1)\n- Indirect cycles through multiple cells\n- Self-referential cells (e.g., A1 = A1)\n- Non-obvious cycles (e.g., A1 = 0*B1, B1 = A1)\n\n### Formula Errors\n- Invalid formula syntax (e.g., 1++1, unrecognized functions)\n- Missing arguments (e.g., MAX(), SLEEP())\n- Division by zero and error cascading\n- Out-of-bounds cell references\n\n### Sleep Functions\n- Normal sleep operation\n- Cascaded SLEEP cells\n- Negative sleep values\n- Error propagation through sleep functions\n\n### General Edge Cases\n- Empty/invalid commands\n- Large scrolling behavior\n- Dependency graph correctness\n- Error propagation through complex dependencies\n\n---\n\n## 🧪 Primary Data Structures\n\n- **Spreadsheet**: Core container storing cells, viewport, and undo stack\n- **Cell**: Stores formula, value, dependents, and location\n- **Formula (enum)**: Represents different formula types with variant data\n- **Vector**: Used for temporary storage and initial dependency lists\n- **OrderedSet (AVL Tree)**: For efficient storage of large dependency collections\n- **Directed Acyclic Graph**: Models dependencies between cells\n- **Linked List**: Used for topological sort ordering\n- **Stack**: Implements undo/redo logic and eliminates recursion\n\n---\n\n## ➕ Future Enhancements\n\n- Multicellular formulas (e.g., `SUM(A1:B3)`)\n- Drag and drop support in GUI\n- VLOOKUP/HLOOKUP and more Excel functions\n- Multi-cell selection in GUI\n- Floating-point formula support (e.g., `f32` vs `i32`)\n- Further performance optimizations for large spreadsheets\n\n---\n\n## 🔗 GitHub Repository\n\n[https://github.com/SamyakSS83/cop](https://github.com/SamyakSS83/cop)\n*/\n\n// Re-export all modules so they appear in the documentation\npub mod cell;\npub mod downloader;\npub mod graph;\npub mod login;\npub mod mailer;\npub mod saving;\npub mod spreadsheet;\n\n/// Re-export everything from these modules to make it easier to use\npub use cell::*;\npub use downloader::*;\npub use graph::*;\npub use login::*;\npub use mailer::*;\npub use saving::*;\npub use spreadsheet::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","login.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\n#[cfg(feature = \"web\")]\nuse crate::mailer::{Mailer, generate_reset_code};\n#[cfg(feature = \"web\")]\nuse crate::saving;\n#[cfg(feature = \"web\")]\nuse crate::spreadsheet::Spreadsheet;\nuse argon2::{\n    Argon2,\n    password_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\n#[cfg(feature = \"web\")]\nuse axum::extract::FromRef;\n#[cfg(feature = \"web\")]\nuse axum::{\n    Form,\n    Json,\n    extract::{Path as AxumPath, Query, State}, // Rename to avoid conflict\n    http::{StatusCode, header},\n    response::{Html, IntoResponse, Redirect, Response},\n    routing::{get, post},\n};\n#[cfg(feature = \"web\")]\nuse axum_extra::extract::cookie::{Cookie, CookieJar};\nuse lazy_static::lazy_static;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs::{self, File, create_dir_all};\nuse std::io::{Read, Write};\nuse std::path::Path; // Keep this import\n#[cfg(feature = \"web\")]\nuse std::path::PathBuf;\nuse std::sync::RwLock;\nuse std::time::{Duration, SystemTime};\n#[cfg(feature = \"web\")]\nuse urlencoding;\nuse uuid::Uuid;\n\n/// User data structure representing a registered application user\n///\n/// This structure contains all the information about a registered user,\n/// including authentication details and password reset information.\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct User {\n    /// Username (unique identifier for the user)\n    pub username: String,\n\n    /// Email address (used for password recovery)\n    pub email: String,\n\n    /// Argon2 hash of the user's password\n    pub password_hash: String,\n\n    /// Password reset code (if a reset has been requested)\n    pub reset_code: Option\u003cString\u003e,\n\n    /// Expiration time for the reset code\n    pub reset_code_expires: Option\u003cSystemTime\u003e,\n}\n\n/// Credential data for login and registration\n///\n/// Used to receive login and registration form data from the client.\n#[derive(Debug, Serialize, Deserialize)]\npub struct UserCredentials {\n    /// Username for login/registration\n    pub username: String,\n\n    /// Email address (optional for login, required for registration)\n    #[serde(default)]\n    pub email: String,\n\n    /// Password in plaintext (only transmitted, never stored)\n    pub password: String,\n}\n\n/// Password reset request data\n///\n/// Used to receive a password reset request form containing just an email address.\n#[cfg(feature = \"web\")]\n#[derive(Debug, Serialize, Deserialize)]\npub struct PasswordResetRequest {\n    /// Email address to send the reset code to\n    pub email: String,\n}\n\n/// Password reset confirmation data\n///\n/// Used to receive a password reset confirmation form with the reset code and new password.\n#[cfg(feature = \"web\")]\n#[derive(Debug, Serialize, Deserialize)]\npub struct PasswordResetConfirm {\n    /// Email address that requested the reset\n    pub email: String,\n\n    /// Reset code that was sent to the email\n    pub reset_code: String,\n\n    /// New password to set\n    pub new_password: String,\n}\n\n/// Password change request data\n///\n/// Used to receive a password change form from an authenticated user.\n#[cfg(feature = \"web\")]\n#[derive(Debug, Serialize, Deserialize)]\npub struct PasswordChangeRequest {\n    /// Username of the user changing their password\n    pub username: String,\n\n    /// Current password for verification\n    pub old_password: String,\n\n    /// New password to set\n    pub new_password: String,\n\n    /// Confirmation of the new password (must match new_password)\n    pub confirm_password: String,\n}\n\n/// User file metadata\n///\n/// Represents a file owned by a user in the system.\n#[derive(Debug, Serialize, Deserialize)]\npub struct UserFile {\n    /// Name of the file\n    pub name: String,\n\n    /// Path to the file on disk\n    pub path: String,\n\n    /// Creation timestamp\n    pub created: SystemTime,\n\n    /// Last modification timestamp\n    pub modified: SystemTime,\n}\n\n/// Spreadsheet entry for user's file listing\n///\n/// Used to store information about a user's spreadsheet files.\n#[cfg(feature = \"web\")]\n#[derive(Debug, Serialize, Deserialize)]\npub struct SheetEntry {\n    /// Name of the spreadsheet\n    pub name: String,\n\n    /// Visibility status: \"public\" or \"private\"\n    pub status: String,\n}\n\n/// User session data\n///\n/// Represents an authenticated user session.\n#[derive(Debug, Clone)]\npub struct Session {\n    /// Username of the authenticated user\n    pub user_id: String,\n\n    /// Time when the session expires\n    pub expires_at: SystemTime,\n}\n\n/// Global sessions storage\n///\n/// Stores all active user sessions in a thread-safe map.\nlazy_static! {\n    static ref SESSIONS: RwLock\u003cHashMap\u003cString, Session\u003e\u003e = RwLock::new(HashMap::new());\n}\n\n// Constants\nconst USERS_FILE: \u0026str = \"database/users.json\";\nconst DATABASE_DIR: \u0026str = \"database\";\nconst SESSION_DURATION: u64 = 24 * 60 * 60; // 24 hours in seconds\n\n/// Initialize the database structure\n///\n/// Creates the database directory and users file if they don't exist.\n/// This should be called before any other database operations.\n///\n/// # Returns\n/// * `std::io::Result\u003c()\u003e` - Success or an IO error\n///\n/// # Examples\n/// ```\n/// use cop::login::init_database;\n///\n/// if let Err(e) = init_database() {\n///     eprintln!(\"Failed to initialize database: {}\", e);\n/// }\n/// ```\npub fn init_database() -\u003e std::io::Result\u003c()\u003e {\n    // Create database directory if it doesn't exist\n    if !std::path::Path::new(DATABASE_DIR).exists() {\n        create_dir_all(DATABASE_DIR)?;\n    }\n\n    // Create users.json if it doesn't exist\n    let users_path = std::path::Path::new(USERS_FILE);\n    if !users_path.exists() {\n        let mut file = File::create(users_path)?;\n        file.write_all(b\"{}\")?;\n    }\n\n    Ok(())\n}\n\n/// Get all registered users\n///\n/// Reads the users file and returns a map of all registered users.\n///\n/// # Returns\n/// * `Result\u003cHashMap\u003cString, User\u003e, String\u003e` - Map of usernames to user objects, or an error\n///\n/// # Errors\n/// * Returns an error if the users file cannot be opened, read, or parsed\npub fn get_users() -\u003e Result\u003cHashMap\u003cString, User\u003e, String\u003e {\n    let mut file = match File::open(USERS_FILE) {\n        Ok(file) =\u003e file,\n        Err(_) =\u003e return Err(\"Failed to open users file\".to_string()),\n    };\n\n    let mut contents = String::new();\n    if file.read_to_string(\u0026mut contents).is_err() {\n        return Err(\"Failed to read users file\".to_string());\n    }\n\n    match serde_json::from_str(\u0026contents) {\n        Ok(users) =\u003e Ok(users),\n        Err(_) =\u003e Err(\"Failed to parse users data\".to_string()),\n    }\n}\n\n/// Save the users map to disk\n///\n/// Writes the users map to the users file.\n///\n/// # Arguments\n/// * `users` - The users map to save\n///\n/// # Returns\n/// * `Result\u003c(), String\u003e` - Success or an error message\n///\n/// # Errors\n/// * Returns an error if the users file cannot be created or written to\npub fn save_users(users: \u0026HashMap\u003cString, User\u003e) -\u003e Result\u003c(), String\u003e {\n    let json = match serde_json::to_string_pretty(users) {\n        Ok(json) =\u003e json,\n        Err(_) =\u003e return Err(\"Failed to serialize users data\".to_string()),\n    };\n\n    let mut file = match File::create(USERS_FILE) {\n        Ok(file) =\u003e file,\n        Err(_) =\u003e return Err(\"Failed to create users file\".to_string()),\n    };\n\n    if file.write_all(json.as_bytes()).is_err() {\n        return Err(\"Failed to write users data\".to_string());\n    }\n\n    Ok(())\n}\n\n/// Register a new user\n///\n/// Creates a new user account with the provided username, email, and password.\n/// The password is hashed before storage.\n///\n/// # Arguments\n/// * `username` - Unique username for the new account\n/// * `email` - Email address for the user\n/// * `password` - Plain text password (will be hashed)\n///\n/// # Returns\n/// * `Result\u003c(), String\u003e` - Success or an error message\n///\n/// # Errors\n/// * Returns an error if the username or email is already in use\n/// * Returns an error if any required fields are empty\npub fn register_user(username: \u0026str, email: \u0026str, password: \u0026str) -\u003e Result\u003c(), String\u003e {\n    if username.is_empty() || password.is_empty() || email.is_empty() {\n        return Err(\"Username, email and password cannot be empty\".to_string());\n    }\n\n    // Check if username already exists\n    let mut users = get_users()?;\n    if users.contains_key(username) {\n        return Err(\"Username already exists\".to_string());\n    }\n\n    // Check if email is already in use\n    if users.values().any(|user| user.email == email) {\n        return Err(\"Email address is already registered\".to_string());\n    }\n\n    // Hash the password\n    let password_hash = hash_password(password)?;\n\n    // Create user directory\n    let user_dir = std::path::Path::new(DATABASE_DIR).join(username);\n    if create_dir_all(\u0026user_dir).is_err() {\n        return Err(\"Failed to create user directory\".to_string());\n    }\n\n    // Add user to users.json\n    let user = User {\n        username: username.to_string(),\n        email: email.to_string(),\n        password_hash,\n        reset_code: None,\n        reset_code_expires: None,\n    };\n\n    users.insert(username.to_string(), user);\n    save_users(\u0026users)?;\n\n    Ok(())\n}\n\n/// Verify user credentials\n///\n/// Checks whether the provided username and password match a registered user.\n///\n/// # Arguments\n/// * `username` - Username to verify\n/// * `password` - Password to verify\n///\n/// # Returns\n/// * `Result\u003cbool, String\u003e` - True if credentials are valid, false if invalid, or an error\n///\n/// # Errors\n/// * Returns an error if there is a problem accessing the user database\npub fn verify_user(username: \u0026str, password: \u0026str) -\u003e Result\u003cbool, String\u003e {\n    let users = get_users()?;\n\n    if let Some(user) = users.get(username) {\n        verify_password(password, \u0026user.password_hash)\n    } else {\n        Ok(false)\n    }\n}\n\n/// Hash a password using Argon2\n///\n/// Creates a cryptographically secure hash of a password using Argon2id.\n///\n/// # Arguments\n/// * `password` - The plaintext password to hash\n///\n/// # Returns\n/// * `Result\u003cString, String\u003e` - The password hash or an error\n///\n/// # Errors\n/// * Returns an error if the password hashing fails\nfn hash_password(password: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n    let argon2 = Argon2::default();\n\n    match argon2.hash_password(password.as_bytes(), \u0026salt) {\n        Ok(hash) =\u003e Ok(hash.to_string()),\n        Err(_) =\u003e Err(\"Password hashing failed\".to_string()),\n    }\n}\n\n/// Verify a password against a stored hash\n///\n/// Checks if a plaintext password matches a stored Argon2 hash.\n///\n/// # Arguments\n/// * `password` - The plaintext password to verify\n/// * `hash` - The stored password hash to check against\n///\n/// # Returns\n/// * `Result\u003cbool, String\u003e` - True if the password matches, false if not, or an error\n///\n/// # Errors\n/// * Returns an error if the hash is in an invalid format\nfn verify_password(password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, String\u003e {\n    let parsed_hash = match PasswordHash::new(hash) {\n        Ok(hash) =\u003e hash,\n        Err(_) =\u003e return Err(\"Invalid password hash format\".to_string()),\n    };\n\n    match Argon2::default().verify_password(password.as_bytes(), \u0026parsed_hash) {\n        Ok(_) =\u003e Ok(true),\n        Err(_) =\u003e Ok(false), // Password didn't match\n    }\n}\n\n/// Create a new user session\n///\n/// Creates and stores a new session for an authenticated user.\n///\n/// # Arguments\n/// * `username` - The username to create a session for\n///\n/// # Returns\n/// * `String` - A unique session ID\npub fn create_session(username: \u0026str) -\u003e String {\n    let session_id = Uuid::new_v4().to_string();\n    let expires_at = SystemTime::now() + Duration::from_secs(SESSION_DURATION);\n\n    let session = Session {\n        user_id: username.to_string(),\n        expires_at,\n    };\n\n    let mut sessions = SESSIONS.write().unwrap();\n    sessions.insert(session_id.clone(), session);\n\n    session_id\n}\n\n/// Validate a session\n///\n/// Checks if a session is valid and not expired.\n///\n/// # Arguments\n/// * `session_id` - The session ID to validate\n///\n/// # Returns\n/// * `Option\u003cString\u003e` - The username for the session if valid, None otherwise\npub fn validate_session(session_id: \u0026str) -\u003e Option\u003cString\u003e {\n    let sessions = SESSIONS.read().unwrap();\n\n    if let Some(session) = sessions.get(session_id) {\n        if session.expires_at \u003e SystemTime::now() {\n            return Some(session.user_id.clone());\n        }\n    }\n\n    None\n}\n\n/// Get a list of user's files\n///\n/// Retrieves metadata for all spreadsheet files owned by a user.\n///\n/// # Arguments\n/// * `username` - The username to get files for\n///\n/// # Returns\n/// * `Vec\u003cUserFile\u003e` - List of user's files with metadata\npub fn get_user_files(username: \u0026str) -\u003e Vec\u003cUserFile\u003e {\n    let mut files = Vec::new();\n    let user_dir = Path::new(DATABASE_DIR).join(username);\n\n    if let Ok(entries) = fs::read_dir(user_dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_file() \u0026\u0026 path.extension().and_then(|ext| ext.to_str()) == Some(\"gz\") {\n                if let Some(filename) = path.file_name().and_then(|name| name.to_str()) {\n                    let metadata = match fs::metadata(\u0026path) {\n                        Ok(meta) =\u003e meta,\n                        Err(_) =\u003e continue, // Skip this file if we can't get metadata\n                    };\n                    let created = metadata.created().unwrap_or(SystemTime::now());\n                    let modified = metadata.modified().unwrap_or(SystemTime::now());\n\n                    files.push(UserFile {\n                        name: filename.to_string(),\n                        path: path.to_string_lossy().to_string(),\n                        created,\n                        modified,\n                    });\n                }\n            }\n        }\n    }\n\n    files\n}\n\n// Web handler functions below (only compiled with \"web\" feature)\n\n/// Serve the login page HTML\n///\n/// # Returns\n/// * `Html\u003c\u0026'static str\u003e` - The login page HTML\n#[cfg(feature = \"web\")]\npub async fn serve_login_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/login.html\"))\n}\n\n/// Serve the signup page HTML\n///\n/// # Returns\n/// * `Html\u003c\u0026'static str\u003e` - The signup page HTML\n#[cfg(feature = \"web\")]\npub async fn serve_signup_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/signup.html\"))\n}\n\n/// Handle user login requests\n///\n/// Processes login form submissions, validates credentials, and creates a session if valid.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for storing the session cookie\n/// * `credentials` - Form data containing the username and password\n///\n/// # Returns\n/// * `Response` - Redirect to user page if successful, or error message if not\n#[cfg(feature = \"web\")]\n#[axum::debug_handler]\npub async fn handle_login(jar: CookieJar, Form(credentials): Form\u003cUserCredentials\u003e) -\u003e Response {\n    // We don't need email for login\n    match verify_user(\u0026credentials.username, \u0026credentials.password) {\n        Ok(true) =\u003e {\n            let session_id = create_session(\u0026credentials.username);\n            let cookie = Cookie::new(\"session\", session_id);\n            (\n                jar.add(cookie),\n                Redirect::to(\u0026format!(\"/{}\", credentials.username)),\n            )\n                .into_response()\n        }\n        Ok(false) =\u003e (StatusCode::UNAUTHORIZED, \"Invalid username or password\").into_response(),\n        Err(_) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, \"Authentication error\").into_response(),\n    }\n}\n\n/// Handle user registration\n///\n/// Processes signup form submissions and creates a new user account.\n///\n/// # Arguments\n/// * `credentials` - Form data containing the username, email, and password\n///\n/// # Returns\n/// * `Result\u003cRedirect, (StatusCode, String)\u003e` - Redirect to login page or error message\n#[cfg(feature = \"web\")]\npub async fn handle_signup(\n    Form(credentials): Form\u003cUserCredentials\u003e,\n) -\u003e Result\u003cRedirect, (StatusCode, String)\u003e {\n    match register_user(\n        \u0026credentials.username,\n        \u0026credentials.email,\n        \u0026credentials.password,\n    ) {\n        Ok(_) =\u003e Ok(Redirect::to(\"/login?registered=true\")),\n        Err(e) =\u003e Err((StatusCode::BAD_REQUEST, e)),\n    }\n}\n\n/// Handle user logout\n///\n/// Clears the session cookie and redirects to the login page.\n///\n/// # Arguments\n/// * `jar` - Cookie jar containing the session cookie\n///\n/// # Returns\n/// * `(CookieJar, Redirect)` - Modified cookie jar and redirect response\n#[cfg(feature = \"web\")]\npub async fn handle_logout(jar: CookieJar) -\u003e (CookieJar, Redirect) {\n    // Remove session cookie\n    let cookie = Cookie::new(\"session\", \"\");\n\n    (jar.add(cookie), Redirect::to(\"/login\"))\n}\n\n/// Authentication middleware\n///\n/// Checks if a request is authenticated and allows or redirects accordingly.\n/// Also handles public access to public spreadsheets.\n///\n/// # Arguments\n/// * `jar` - Cookie jar containing session information\n/// * `request` - The incoming request\n/// * `next` - Next middleware in the chain\n///\n/// # Returns\n/// * `Response` - Either passes the request through or redirects to login\n#[cfg(feature = \"web\")]\npub async fn require_auth(\n    jar: CookieJar,\n    mut request: axum::extract::Request,\n    next: axum::middleware::Next,\n) -\u003e Response {\n    // First, if a valid session exists, allow the request.\n    if let Some(session_cookie) = jar.get(\"session\") {\n        if let Some(username) = validate_session(session_cookie.value()) {\n            request.extensions_mut().insert(username);\n            return next.run(request).await;\n        }\n    }\n\n    // No valid session; if the call is for an API endpoint, check if the sheet is public.\n    let uri = request.uri().path();\n    if uri.starts_with(\"/api/\") {\n        let parts: Vec\u003c\u0026str\u003e = uri.split('/').filter(|s| !s.is_empty()).collect();\n        let (owner, sheet_name) = if parts.len() \u003e= 3 {\n            (\n                parts[1].to_string(),\n                parts[2].trim_end_matches(\".bin.gz\").to_string(),\n            )\n        } else {\n            (String::new(), String::new())\n        };\n\n        // If there's an authenticated user matching the owner, allow access.\n        if let Some(auth_user) = request.extensions().get::\u003cString\u003e() {\n            if *auth_user == owner {\n                return next.run(request).await;\n            }\n        }\n\n        if !owner.is_empty() \u0026\u0026 !sheet_name.is_empty() {\n            let list_path = format!(\"database/{}/list.json\", owner);\n            if let Ok(data) = std::fs::read_to_string(\u0026list_path) {\n                if let Ok(entries) = serde_json::from_str::\u003cVec\u003ccrate::login::SheetEntry\u003e\u003e(\u0026data) {\n                    let is_public = entries\n                        .iter()\n                        .any(|entry| entry.name == sheet_name \u0026\u0026 entry.status == \"public\");\n                    if is_public {\n                        return next.run(request).await;\n                    }\n                }\n            }\n        }\n    }\n\n    // Failing the above, redirect to login.\n    Redirect::to(\"/login\").into_response()\n}\n\n/// List a user's spreadsheet files\n///\n/// Displays a page with all spreadsheets owned by a user.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for authentication\n/// * `username` - Path parameter containing the username\n///\n/// # Returns\n/// * `Result\u003cHtml\u003cString\u003e, (StatusCode, \u0026'static str)\u003e` - HTML page or error\n#[cfg(feature = \"web\")]\npub async fn list_files(\n    jar: CookieJar,\n    AxumPath(username): AxumPath\u003cString\u003e,\n) -\u003e Result\u003cHtml\u003cString\u003e, (StatusCode, \u0026'static str)\u003e {\n    // 1) auth check\n    if let Some(cookie) = jar.get(\"session\") {\n        if let Some(current) = validate_session(cookie.value()) {\n            if current == username {\n                // 2) load list.json\n                let user_dir = PathBuf::from(DATABASE_DIR).join(\u0026username);\n                let list_path = user_dir.join(\"list.json\");\n                let entries: Vec\u003cSheetEntry\u003e = if list_path.exists() {\n                    let data = fs::read_to_string(\u0026list_path).unwrap_or_default();\n                    serde_json::from_str(\u0026data).unwrap_or_default()\n                } else {\n                    Vec::new()\n                };\n\n                // 3) Get the template and inject the data\n                let mut template = include_str!(\"./static/list.html\").to_string();\n\n                // Insert the sheets data as JavaScript\n                let sheets_json =\n                    serde_json::to_string(\u0026entries).unwrap_or_else(|_| \"[]\".to_string());\n\n                template = template.replace(\n                    \"\u003c/head\u003e\",\n                    \u0026format!(\n                        \"    \u003cscript\u003econst SHEETS_DATA = {};\u003c/script\u003e\\n\u003c/head\u003e\",\n                        sheets_json\n                    ),\n                );\n\n                return Ok(Html(template));\n            }\n        }\n    }\n    Err((StatusCode::UNAUTHORIZED, \"Unauthorized\"))\n}\n\n/// Serve the create sheet form\n///\n/// Redirects to the user's list page which contains the create sheet form.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for authentication\n/// * `username` - Path parameter containing the username\n///\n/// # Returns\n/// * `Result\u003cRedirect, (StatusCode, \u0026'static str)\u003e` - Redirect response or error\n#[cfg(feature = \"web\")]\npub async fn serve_create_sheet_form(\n    jar: CookieJar,\n    AxumPath(username): AxumPath\u003cString\u003e,\n) -\u003e Result\u003cRedirect, (StatusCode, \u0026'static str)\u003e {\n    // Redirect back to the list page - the form is now in the modal\n    Ok(Redirect::to(\u0026format!(\"/{}\", username)))\n}\n\n/// Handle creating a new spreadsheet\n///\n/// Creates a new spreadsheet with the specified dimensions and saves it to the user's directory.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for authentication\n/// * `username` - Path parameter containing the username\n/// * `form` - Form data containing the sheet name, dimensions, and visibility\n///\n/// # Returns\n/// * `Redirect` - Redirect back to the user's sheet list\n#[cfg(feature = \"web\")]\npub async fn handle_create_sheet(\n    jar: CookieJar,\n    AxumPath(username): AxumPath\u003cString\u003e,\n    Form(form): Form\u003cCreateSheetForm\u003e,\n) -\u003e Redirect {\n    // 1) Create the directory if it doesn't exist\n    let user_dir = PathBuf::from(DATABASE_DIR).join(\u0026username);\n    let _ = create_dir_all(\u0026user_dir);\n\n    // 2) Create and save the spreadsheet\n    let filename = format!(\"{}.bin.gz\", form.name);\n    let path = user_dir.join(\u0026filename);\n    let sheet = Spreadsheet::spreadsheet_create(form.rows as i16, form.cols as i16)\n        .expect(\"Failed to create spreadsheet\");\n    saving::save_spreadsheet(\u0026sheet, path.to_str().unwrap()).expect(\"Failed to save spreadsheet\");\n\n    // 3) Update list.json\n    let list_path = user_dir.join(\"list.json\");\n    let mut entries: Vec\u003cSheetEntry\u003e = if list_path.exists() {\n        let data = fs::read_to_string(\u0026list_path).unwrap_or_default();\n        serde_json::from_str(\u0026data).unwrap_or_default()\n    } else {\n        Vec::new()\n    };\n    entries.push(SheetEntry {\n        name: form.name,\n        status: form.status,\n    });\n    fs::write(\u0026list_path, serde_json::to_string_pretty(\u0026entries).unwrap())\n        .expect(\"Failed to write list.json\");\n\n    Redirect::to(\u0026format!(\"/{}\", username))\n}\n\n/// Handle deleting a spreadsheet\n///\n/// Deletes a user's spreadsheet file and updates the file listing.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for authentication\n/// * `path_params` - Path parameters containing username and sheet name\n///\n/// # Returns\n/// * `Redirect` - Redirect back to the user's sheet list\n#[cfg(feature = \"web\")]\npub async fn handle_delete_sheet(\n    jar: CookieJar,\n    AxumPath((username, sheet_name)): AxumPath\u003c(String, String)\u003e,\n) -\u003e Redirect {\n    // 1) Delete the spreadsheet file\n    let user_dir = PathBuf::from(DATABASE_DIR).join(\u0026username);\n    let file_path = user_dir.join(format!(\"{}.bin.gz\", sheet_name));\n    let _ = fs::remove_file(\u0026file_path);\n\n    // 2) Update list.json\n    let list_path = user_dir.join(\"list.json\");\n    if list_path.exists() {\n        if let Ok(data) = fs::read_to_string(\u0026list_path) {\n            if let Ok(mut entries) = serde_json::from_str::\u003cVec\u003cSheetEntry\u003e\u003e(\u0026data) {\n                entries.retain(|entry| entry.name != sheet_name);\n                let _ = fs::write(\u0026list_path, serde_json::to_string_pretty(\u0026entries).unwrap());\n            }\n        }\n    }\n\n    Redirect::to(\u0026format!(\"/{}\", username))\n}\n\n/// Handle password reset requests\n///\n/// Processes a request to reset a forgotten password by sending a reset code via email.\n///\n/// # Arguments\n/// * `reset_req` - Form data containing the email address\n///\n/// # Returns\n/// * `Response` - Redirect to password reset form or error page\n#[cfg(feature = \"web\")]\npub async fn handle_forgot_password(\n    Form(reset_req): Form\u003cPasswordResetRequest\u003e,\n) -\u003e impl IntoResponse {\n    let mut users = match get_users() {\n        Ok(users) =\u003e users,\n        Err(_) =\u003e {\n            return Redirect::to(\"/forgot-password?error=Server+error\").into_response();\n        }\n    };\n\n    // Find user by email\n    let user = users.values_mut().find(|u| u.email == reset_req.email);\n\n    if let Some(user) = user {\n        let reset_code = generate_reset_code();\n        let expires = SystemTime::now() + Duration::from_secs(3600); // 1 hour\n\n        // Update user with reset code\n        user.reset_code = Some(reset_code.clone());\n        user.reset_code_expires = Some(expires);\n\n        // Save updated users\n        if save_users(\u0026users).is_err() {\n            return Redirect::to(\"/forgot-password?error=Failed+to+generate+reset+code\")\n                .into_response();\n        }\n\n        // Send email\n        match Mailer::new() {\n            Ok(mailer) =\u003e {\n                if let Err(_) = mailer.send_password_reset(\u0026reset_req.email, \u0026reset_code) {\n                    return Redirect::to(\"/forgot-password?error=Failed+to+send+email\")\n                        .into_response();\n                }\n            }\n            Err(_) =\u003e {\n                return Redirect::to(\"/forgot-password?error=Failed+to+initialize+mailer\")\n                    .into_response();\n            }\n        }\n\n        // Redirect to reset form with success message\n        Redirect::to(\u0026format!(\n            \"/reset-password?email_sent=true\u0026email={}\",\n            urlencoding::encode(\u0026reset_req.email)\n        ))\n        .into_response()\n    } else {\n        Redirect::to(\"/forgot-password?error=Email+not+found\").into_response()\n    }\n}\n\n/// Handle password reset confirmation\n///\n/// Processes a submitted password reset code and updates the user's password if valid.\n///\n/// # Arguments\n/// * `reset_confirm` - Form data containing the email, reset code, and new password\n///\n/// # Returns\n/// * `Response` - Redirect to login page on success or error page on failure\n#[cfg(feature = \"web\")]\npub async fn handle_reset_password(\n    Form(reset_confirm): Form\u003cPasswordResetConfirm\u003e,\n) -\u003e impl IntoResponse {\n    let mut users = match get_users() {\n        Ok(users) =\u003e users,\n        Err(_) =\u003e {\n            return Redirect::to(\"/reset-password?error=Server+error\").into_response();\n        }\n    };\n\n    // Find user by email\n    let user = users.values_mut().find(|u| u.email == reset_confirm.email);\n\n    if let Some(user) = user {\n        // Verify reset code\n        if let Some(stored_code) = \u0026user.reset_code {\n            if let Some(expires) = user.reset_code_expires {\n                if SystemTime::now() \u003e expires {\n                    return Redirect::to(\"/reset-password?error=Reset+code+expired\")\n                        .into_response();\n                }\n\n                if stored_code != \u0026reset_confirm.reset_code {\n                    return Redirect::to(\"/reset-password?error=Invalid+reset+code\")\n                        .into_response();\n                }\n\n                // Update password\n                match hash_password(\u0026reset_confirm.new_password) {\n                    Ok(hash) =\u003e {\n                        user.password_hash = hash;\n                        user.reset_code = None;\n                        user.reset_code_expires = None;\n\n                        if save_users(\u0026users).is_err() {\n                            return Redirect::to(\n                                \"/reset-password?error=Failed+to+save+new+password\",\n                            )\n                            .into_response();\n                        }\n\n                        Redirect::to(\"/login?success=Password+reset+successful\").into_response()\n                    }\n                    Err(_) =\u003e Redirect::to(\"/reset-password?error=Failed+to+hash+password\")\n                        .into_response(),\n                }\n            } else {\n                Redirect::to(\"/reset-password?error=Reset+code+expired\").into_response()\n            }\n        } else {\n            Redirect::to(\"/reset-password?error=No+reset+code+found\").into_response()\n        }\n    } else {\n        Redirect::to(\"/reset-password?error=Email+not+found\").into_response()\n    }\n}\n\n/// Handle password change for authenticated users\n///\n/// Allows authenticated users to change their password by providing their current password.\n///\n/// # Arguments\n/// * `jar` - Cookie jar for authentication\n/// * `change_req` - Form data containing the old and new passwords\n///\n/// # Returns\n/// * `Response` - Success message or error response\n#[cfg(feature = \"web\")]\npub async fn handle_change_password(\n    jar: CookieJar,\n    Form(change_req): Form\u003cPasswordChangeRequest\u003e,\n) -\u003e impl IntoResponse {\n    // Verify current user is authenticated\n    if let Some(cookie) = jar.get(\"session\") {\n        if let Some(current_user) = validate_session(cookie.value()) {\n            if current_user != change_req.username {\n                return (StatusCode::UNAUTHORIZED, \"Unauthorized\").into_response();\n            }\n\n            // Verify old password and update to new password\n            let mut users = match get_users() {\n                Ok(users) =\u003e users,\n                Err(_) =\u003e {\n                    return (StatusCode::INTERNAL_SERVER_ERROR, \"Server error\").into_response();\n                }\n            };\n\n            if let Some(user) = users.get_mut(\u0026change_req.username) {\n                // Verify old password\n                match verify_password(\u0026change_req.old_password, \u0026user.password_hash) {\n                    Ok(true) =\u003e {\n                        // Verify new passwords match\n                        if change_req.new_password != change_req.confirm_password {\n                            return (StatusCode::BAD_REQUEST, \"New passwords don't match\")\n                                .into_response();\n                        }\n\n                        // Update password\n                        match hash_password(\u0026change_req.new_password) {\n                            Ok(hash) =\u003e {\n                                user.password_hash = hash;\n                                if save_users(\u0026users).is_err() {\n                                    return (\n                                        StatusCode::INTERNAL_SERVER_ERROR,\n                                        \"Failed to save new password\",\n                                    )\n                                        .into_response();\n                                }\n                                (StatusCode::OK, \"Password changed successfully\").into_response()\n                            }\n                            Err(_) =\u003e {\n                                (StatusCode::INTERNAL_SERVER_ERROR, \"Failed to hash password\")\n                                    .into_response()\n                            }\n                        }\n                    }\n                    Ok(false) =\u003e (StatusCode::BAD_REQUEST, \"Invalid old password\").into_response(),\n                    Err(_) =\u003e (\n                        StatusCode::INTERNAL_SERVER_ERROR,\n                        \"Password verification failed\",\n                    )\n                        .into_response(),\n                }\n            } else {\n                (StatusCode::NOT_FOUND, \"User not found\").into_response()\n            }\n        } else {\n            (StatusCode::UNAUTHORIZED, \"Invalid session\").into_response()\n        }\n    } else {\n        (StatusCode::UNAUTHORIZED, \"No session found\").into_response()\n    }\n}\n\n/// Serve the password forgot/reset page\n///\n/// # Returns\n/// * `Html\u003c\u0026'static str\u003e` - The password management page HTML\n#[cfg(feature = \"web\")]\npub async fn serve_forgot_password_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/password.html\"))\n}\n\n/// Serve the password reset page\n///\n/// # Returns\n/// * `Html\u003c\u0026'static str\u003e` - The password management page HTML\n#[cfg(feature = \"web\")]\npub async fn serve_reset_password_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/password.html\"))\n}\n\n/// Serve the password change page\n///\n/// # Returns\n/// * `Html\u003c\u0026'static str\u003e` - The password management page HTML\n#[cfg(feature = \"web\")]\npub async fn serve_change_password_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/password.html\"))\n}\n\n/// Form data for spreadsheet creation\n///\n/// Contains parameters for creating a new spreadsheet.\n#[cfg(feature = \"web\")]\n#[derive(Debug, Deserialize)]\npub struct CreateSheetForm {\n    /// Name for the new spreadsheet\n    pub name: String,\n\n    /// Number of rows to create\n    pub rows: u16,\n\n    /// Number of columns to create\n    pub cols: u16,\n\n    /// Visibility status (\"public\" or \"private\")\n    pub status: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","mailer.rs"],"content":"#[cfg(feature = \"web\")]\nuse lettre::transport::smtp::authentication::Credentials;\n#[cfg(feature = \"web\")]\nuse lettre::transport::smtp::client::{Tls, TlsParameters};\n#[cfg(feature = \"web\")]\nuse lettre::{Message, SmtpTransport, Transport};\n#[cfg(feature = \"web\")]\nuse rand::Rng;\n#[cfg(feature = \"web\")]\nuse std::error::Error;\n#[cfg(feature = \"web\")]\nuse std::fs;\n\n/// Email sending functionality for the application\n///\n/// This module provides email capabilities for the web application,\n/// specifically for password reset functionality. It is only compiled\n/// when the \"web\" feature is enabled.\n#[cfg(feature = \"web\")]\npub struct Mailer {\n    /// SMTP transport client configured for sending emails\n    smtp: SmtpTransport,\n}\n\n#[cfg(feature = \"web\")]\nimpl Mailer {\n    /// Creates a new Mailer instance\n    ///\n    /// Initializes a new mailer by reading credentials from a config file\n    /// and setting up the SMTP transport with TLS.\n    ///\n    /// # Returns\n    /// * `Result\u003cSelf, Box\u003cdyn Error\u003e\u003e` - A new Mailer instance or an error\n    ///\n    /// # Errors\n    /// * Returns an error if credentials cannot be read from the config file\n    /// * Returns an error if the SMTP relay cannot be configured\n    ///\n    /// # Configuration\n    /// Requires a file at \"config/mail_credentials.txt\" with:\n    /// - Email address on the first line\n    /// - Password on the second line\n    pub fn new() -\u003e Result\u003cSelf, Box\u003cdyn Error\u003e\u003e {\n        // Read the email credentials from a config file.\n        // The file \"config/mail_credentials.txt\" should have the email on the first line and the password on the second.\n        let creds_data = fs::read_to_string(\"config/mail_credentials.txt\")?;\n        let mut lines = creds_data.lines();\n        let email = lines.next().unwrap_or(\"\").trim().to_string();\n        let password = lines.next().unwrap_or(\"\").trim().to_string();\n        \n        if email.is_empty() || password.is_empty() {\n            return Err(\"Invalid mail credentials in config file\".into());\n        }\n\n        let creds = Credentials::new(email, password);\n\n        let tls_parameters = TlsParameters::new(\"smtp.iitd.ac.in\".to_string())?;\n\n        let smtp = SmtpTransport::relay(\"smtp.iitd.ac.in\")?\n            .credentials(creds)\n            .port(465)\n            .tls(Tls::Wrapper(tls_parameters))\n            .build();\n\n        Ok(Mailer { smtp })\n    }\n\n    /// Sends a password reset email\n    ///\n    /// Composes and sends an email containing a password reset code to the specified\n    /// email address.\n    ///\n    /// # Arguments\n    /// * `to_email` - The recipient's email address\n    /// * `reset_code` - The generated password reset code\n    ///\n    /// # Returns\n    /// * `Result\u003c(), Box\u003cdyn Error\u003e\u003e` - Success or an error\n    ///\n    /// # Errors\n    /// * Returns an error if the email address is invalid\n    /// * Returns an error if the SMTP transport fails to send the email\n    pub fn send_password_reset(\n        \u0026self,\n        to_email: \u0026str,\n        reset_code: \u0026str,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let email = Message::builder()\n            .from(\"Rusty \u003ccs1230807@iitd.ac.in\u003e\".parse()?)\n            .to(to_email.parse()?)\n            .subject(\"Password Reset Request\")\n            .body(format!(\n                \"Your password reset code is: {}\\nThis code will expire in 1 hour.\",\n                reset_code\n            ))?;\n\n        self.smtp.send(\u0026email)?;\n        Ok(())\n    }\n}\n\n/// Generates a random reset code for password recovery\n///\n/// Creates an 8-character alphanumeric code (uppercase letters and numbers)\n/// for use in the password reset process.\n///\n/// # Returns\n/// * `String` - A randomly generated 8-character code\n///\n/// # Example\n/// ```\n/// use cop::mailer::generate_reset_code;\n/// \n/// let reset_code = generate_reset_code();\n/// assert_eq!(reset_code.len(), 8);\n/// ```\n#[cfg(feature = \"web\")]\npub fn generate_reset_code() -\u003e String {\n    const CHARSET: \u0026[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    let mut rng = rand::thread_rng();\n\n    (0..8)\n        .map(|_| {\n            let idx = rng.gen_range(0..CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","main.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse cop::spreadsheet::Spreadsheet;\n\n// use crate::spreadsheet::{Spreadsheet, Spreadsheet as SpreadsheetTrait};\nuse std::env;\nuse std::io::{self, Write};\n// use std::os::macos::raw::stat;\nuse std::time::Instant;\n\n// #[tokio::main]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let s = Instant::now(); // Start time for the entire program\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    // if args.len() \u003e 1 \u0026\u0026 args[1] == \"-dassi_nahi_to_rassi\" {\n    //     // Run the web application\n    //     let mut rows = 10;\n    //     let mut cols = 10;\n\n    //     if args.len() \u003e= 4 {\n    //         rows = args[2].parse().unwrap_or(10);\n    //         cols = args[3].parse().unwrap_or(10);\n    //     }\n\n    //     app::run(rows, cols).await?;\n    // } else {\n    // Run the spreadsheet functionality\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003crows\u003e \u003ccols\u003e\", args[0]);\n        return Ok(());\n    }\n\n    let rows: i32 = args[1].parse().unwrap_or(0);\n    let cols: i32 = args[2].parse().unwrap_or(0);\n\n    if !(1..=999).contains(\u0026rows) || !(1..=18278).contains(\u0026cols) {\n        eprintln!(\"Error: Invalid dimensions\");\n        return Ok(());\n    }\n\n    let mut start_time = Instant::now(); // Start time for the first command\n    let mut sheet = Spreadsheet::spreadsheet_create(rows as i16, cols as i16).unwrap();\n    let mut elapsed_time;\n    let mut status = String::from(\"ok\");\n    let mut show = true;\n    loop {\n        if show {\n            sheet.spreadsheet_display();\n        }\n\n        elapsed_time = start_time.elapsed().as_secs_f64(); // Calculate time since the last command\n        print!(\"[{:.1}] ({}) \u003e \", elapsed_time, status);\n        io::stdout().flush().unwrap();\n\n        let mut command = String::new();\n        if io::stdin().read_line(\u0026mut command).is_err() {\n            break;\n        }\n        let command = command.trim();\n\n        start_time = Instant::now(); // Reset the start time for the next command\n\n        if command.is_empty() {\n            status = String::from(\"invalid command\");\n            continue;\n        }\n\n        if command == \"help\" {\n            println!(\"Commands:\");\n            println!(\"  q: Quit\");\n            println!(\"  w: Move up\");\n            println!(\"  s: Move down\");\n            println!(\"  a: Move left\");\n            println!(\"  d: Move right\");\n            println!(\"  disable_output: Disable output display\");\n            println!(\"  enable_output: Enable output display\");\n            println!(\"  scroll_to \u003ccell\u003e: Scroll to the specified cell\");\n            println!(\"  \u003ccell\u003e=\u003cformula\u003e: Set the formula for the specified cell\");\n            continue;\n        }\n\n        if command == \"q\" {\n            break;\n        } else if command.len() == 1 \u0026\u0026 \"wasd\".contains(command) {\n            match command {\n                \"w\" if sheet.view_row \u003e 0 =\u003e {\n                    sheet.view_row = (sheet.view_row - 10).max(0);\n                }\n                \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                    sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n                }\n                \"a\" if sheet.view_col \u003e 0 =\u003e {\n                    sheet.view_col = (sheet.view_col - 10).max(0);\n                }\n                \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                    sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n                }\n                _ =\u003e {}\n            }\n            status = String::from(\"ok\");\n        } else if command == \"disable_output\" {\n            show = false;\n            status = String::from(\"ok\");\n        } else if command == \"enable_output\" {\n            show = true;\n            status = String::from(\"ok\");\n        } else if command.starts_with(\"scroll_to\") {\n            let cell_name = command[10..].trim();\n            if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n                sheet.view_row = row - 1;\n                sheet.view_col = col - 1;\n                status = String::from(\"ok\");\n            } else {\n                status = String::from(\"invalid cell\");\n            }\n        } else if let Some(equal_pos) = command.find('=') {\n            sheet.undo_stack.clear();\n            let cell_name = \u0026command[..equal_pos];\n            let formula = \u0026command[equal_pos + 1..];\n            let (valid, row, col, rhs) = sheet.is_valid_command(cell_name, formula);\n            if !valid {\n                status = String::from(\"invalid command\");\n            } else {\n                sheet.spreadsheet_set_cell_value(row, col, rhs, \u0026mut status);\n            }\n        } else if command == \"UNDO\" {\n            if sheet.undo_stack.is_empty() {\n                status = String::from(\"no undo\");\n            } else {\n                sheet.spreadsheet_undo(\u0026mut status);\n            }\n        // } else if command == \"REDO\" {\n        //     if sheet.redo_stack.is_empty() {\n        //         status = String::from(\"no redo\");\n        //     } else {\n        //         sheet.spreadsheet_redo();\n        //         status = String::from(\"ok\");\n        //     }\n        } else {\n            status = String::from(\"invalid command 3\");\n        }\n\n        // Update the start_time after processing the command\n        // start_time = Instant::now();\n    }\n    // }\n    let e = s.elapsed().as_secs_f64(); // Calculate total elapsed time\n    println!(\"Total elapsed time: {:.1} seconds\", e);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","saving.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse bincode::{deserialize_from, serialize_into};\nuse flate2::Compression;\nuse flate2::read::GzDecoder;\nuse flate2::write::GzEncoder;\nuse std::fs::File;\n\nuse crate::spreadsheet::Spreadsheet;\n\n/// Saves a spreadsheet to a file\n///\n/// This function serializes a spreadsheet and saves it to a file with compression.\n/// The spreadsheet is first serialized using bincode, then compressed using gzip.\n///\n/// # Arguments\n/// * `spreadsheet` - Reference to the spreadsheet to save\n/// * `filename` - Path to the file where the spreadsheet should be saved\n///\n/// # Returns\n/// * `std::io::Result\u003c()\u003e` - Success or an IO error\n///\n/// # Examples\n/// ```\n/// use cop::spreadsheet::Spreadsheet;\n/// use cop::saving::save_spreadsheet;\n///\n/// let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n/// let result = save_spreadsheet(\u0026sheet, \"my_spreadsheet.bin.gz\");\n/// ```\npub fn save_spreadsheet(spreadsheet: \u0026Spreadsheet, filename: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n    let file = File::create(filename)?;\n    let encoder = GzEncoder::new(file, Compression::default());\n    let mut writer = std::io::BufWriter::new(encoder);\n\n    serialize_into(\u0026mut writer, spreadsheet)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;\n\n    Ok(())\n}\n\n/// Loads a spreadsheet from a file\n///\n/// This function deserializes a spreadsheet from a compressed file.\n/// The file is first decompressed using gzip, then deserialized using bincode.\n///\n/// # Arguments\n/// * `filename` - Path to the file containing the saved spreadsheet\n///\n/// # Returns\n/// * `std::io::Result\u003cSpreadsheet\u003e` - The loaded spreadsheet or an IO error\n///\n/// # Examples\n/// ```\n/// use cop::saving::load_spreadsheet;\n///\n/// match load_spreadsheet(\"my_spreadsheet.bin.gz\") {\n///     Ok(sheet) =\u003e println!(\"Loaded spreadsheet with {} rows and {} columns\", sheet.rows, sheet.cols),\n///     Err(e) =\u003e eprintln!(\"Failed to load spreadsheet: {}\", e),\n/// }\n/// ```\npub fn load_spreadsheet(filename: \u0026str) -\u003e std::io::Result\u003cSpreadsheet\u003e {\n    let file = File::open(filename)?;\n    let decoder = GzDecoder::new(file);\n    let mut reader = std::io::BufReader::new(decoder);\n\n    let spreadsheet: Spreadsheet = deserialize_from(\u0026mut reader)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n    Ok(spreadsheet)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","spreadsheet.rs"],"content":"/// Module for spreadsheet functionality including cell management, formula evaluation and dependency tracking.\nuse crate::cell::{Cell, cell_create};\nuse lazy_static::lazy_static;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeSet;\n\nlazy_static! {\n    /// Regular expression for matching function syntax, e.g., SUM(A1:B2)\n    static ref FUNC_REGEX: Regex = Regex::new(r\"^([A-Za-z]+)\\((.*)\\)$\").unwrap();\n    /// Regular expression for matching arithmetic expressions, e.g., A1+B2 or 10-5\n    static ref ARITH_EXPR_REGEX: Regex = Regex::new(\n        r\"^(([+-]?[0-9]+)|([A-Za-z]+[0-9]+))([+\\-*/])(([+-]?[0-9]+)|([A-Za-z]+[0-9]+))$\"\n    )\n    .unwrap();\n}\n\n/// Represents a spreadsheet with cells, dimensions, and view settings.\n///\n/// The spreadsheet tracks cell values, formulas, and dependencies between cells.\n/// It also maintains an undo stack for operation history.\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Spreadsheet {\n    /// Number of rows in the spreadsheet\n    pub rows: i16,\n    /// Number of columns in the spreadsheet\n    pub cols: i16,\n    /// Current top row of the view (for scrolling)\n    pub view_row: i16,\n    /// Current leftmost column of the view (for scrolling)\n    pub view_col: i16,\n    /// Matrix of cells stored as a flat vector\n    pub cells: Vec\u003cOption\u003cBox\u003cCell\u003e\u003e\u003e,\n    /// Stack of previous cell states for undo functionality\n    pub undo_stack: Vec\u003c(ParsedRHS, i16, i16)\u003e,\n}\n\n/// Represents the parsed right-hand side of a cell formula.\n///\n/// This enum captures the various types of expressions that can be used\n/// in a spreadsheet cell, such as functions, arithmetic operations, or simple values.\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, PartialEq)]\npub enum ParsedRHS {\n    /// A function with a name and arguments\n    Function {\n        name: FunctionName,\n        args: (Operand, Operand),\n    },\n    /// A sleep operation with a duration\n    Sleep(Operand),\n    /// An arithmetic operation with left-hand side, operator, and right-hand side\n    Arithmetic {\n        lhs: Operand,\n        operator: char,\n        rhs: Operand,\n    },\n    /// A single value (number or cell reference)\n    SingleValue(Operand),\n    /// No operation\n    None,\n}\n\n/// Represents an operand in a formula, which can be a number or a cell reference.\n#[derive(Clone, serde::Serialize, serde::Deserialize, Debug, PartialEq)]\npub enum Operand {\n    /// A numeric value\n    Number(i32),\n    /// A cell reference with row and column\n    Cell(i16, i16),\n}\n\n/// Represents the name of a function that can be used in a formula.\n#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]\npub enum FunctionName {\n    Min,\n    Max,\n    Avg,\n    Sum,\n    Stdev,\n    Cut,\n    Copy,\n}\n\nimpl FunctionName {\n    /// Converts a string to a FunctionName enum variant.\n    pub fn from_strng(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name.to_uppercase().as_str() {\n            \"MIN\" =\u003e Some(FunctionName::Min),\n            \"MAX\" =\u003e Some(FunctionName::Max),\n            \"AVG\" =\u003e Some(FunctionName::Avg),\n            \"SUM\" =\u003e Some(FunctionName::Sum),\n            \"STDEV\" =\u003e Some(FunctionName::Stdev),\n            \"COPY\" =\u003e Some(FunctionName::Copy),\n            _ =\u003e None,\n        }\n    }\n    /// Checks if the function is a copy operation.\n    pub fn is_copy(\u0026self) -\u003e bool {\n        matches!(self, FunctionName::Copy)\n    }\n}\n\nimpl Spreadsheet {\n    /// Creates a new spreadsheet with the specified number of rows and columns.\n    ///\n    /// This function initializes a new spreadsheet with the given dimensions and creates\n    /// all cells within the specified range. Each cell is created with default values.\n    ///\n    /// # Arguments\n    /// * `rows` - Number of rows in the spreadsheet\n    /// * `cols` - Number of columns in the spreadsheet\n    ///\n    /// # Returns\n    /// * `Some(Box\u003cSelf\u003e)` - A boxed Spreadsheet instance if creation was successful\n    /// * `None` - If creation failed (should not occur under normal circumstances)\n    ///\n    /// # Example\n    /// ```\n    /// let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n    /// assert_eq!(sheet.rows, 10);\n    /// assert_eq!(sheet.cols, 10);\n    /// ```\n    pub fn spreadsheet_create(rows: i16, cols: i16) -\u003e Option\u003cBox\u003cSelf\u003e\u003e {\n        let mut sheet = Box::new(Spreadsheet {\n            rows,\n            cols,\n            view_row: 0,\n            view_col: 0,\n            cells: Vec::with_capacity(rows as usize * cols as usize),\n            undo_stack: Vec::new(),\n        });\n\n        for _ in 0..(rows as usize * cols as usize) {\n            sheet.cells.push(None);\n        }\n\n        for r in 1..=rows {\n            for c in 1..=cols {\n                let index = ((r - 1) as usize) * (cols as usize) + ((c - 1) as usize);\n                sheet.cells[index] = Some(cell_create(r, c));\n            }\n        }\n\n        Some(sheet)\n    }\n\n    /// Converts a column number to its corresponding letter representation.\n    ///\n    /// This function converts a 1-based column index to an Excel-style column name.\n    /// For example, 1 becomes \"A\", 2 becomes \"B\", 27 becomes \"AA\", etc.\n    ///\n    /// # Arguments\n    /// * `col` - The column number (1-based)\n    ///\n    /// # Returns\n    /// A string representing the column letter(s)\n    ///\n    /// # Example\n    /// ```\n    /// assert_eq!(Spreadsheet::col_to_letter(1), \"A\");\n    /// assert_eq!(Spreadsheet::col_to_letter(26), \"Z\");\n    /// assert_eq!(Spreadsheet::col_to_letter(27), \"AA\");\n    /// ```\n    pub fn col_to_letter(col: i16) -\u003e String {\n        let mut col = col;\n        let mut result = String::new();\n        while col \u003e 0 {\n            col -= 1;\n            result.push(((col % 26) as u8 + b'A') as char);\n            col /= 26;\n        }\n        result.chars().rev().collect()\n    }\n\n    /// Converts a column letter representation to its corresponding number.\n    ///\n    /// This function converts an Excel-style column name to a 1-based column index.\n    /// For example, \"A\" becomes 1, \"B\" becomes 2, \"AA\" becomes 27, etc.\n    ///\n    /// # Arguments\n    /// * `letters` - The string containing the column letters\n    ///\n    /// # Returns\n    /// The column number (1-based)\n    ///\n    /// # Example\n    /// ```\n    /// assert_eq!(Spreadsheet::letter_to_col(\"A\"), 1);\n    /// assert_eq!(Spreadsheet::letter_to_col(\"Z\"), 26);\n    /// assert_eq!(Spreadsheet::letter_to_col(\"AA\"), 27);\n    /// ```\n    pub fn letter_to_col(letters: \u0026str) -\u003e i16 {\n        letters\n            .chars()\n            .fold(0, |acc, c| acc * 26 + (c as i16 - 'A' as i16 + 1))\n    }\n\n    /// Returns the cell name for the given row and column.\n    ///\n    /// This function formats a row and column into a standard spreadsheet cell reference\n    /// (e.g., \"A1\", \"B2\", \"AA10\").\n    ///\n    /// # Arguments\n    /// * `row` - The row number (1-based)\n    /// * `col` - The column number (1-based)\n    ///\n    /// # Returns\n    /// A string containing the formatted cell name\n    ///\n    /// # Example\n    /// ```\n    /// assert_eq!(Spreadsheet::get_cell_name(1, 1), \"A1\");\n    /// assert_eq!(Spreadsheet::get_cell_name(10, 2), \"B10\");\n    /// ```\n    pub fn get_cell_name(row: i16, col: i16) -\u003e String {\n        format!(\"{}{}\", Self::col_to_letter(col), row)\n    }\n\n    /// Parses a cell name and returns its row and column.\n    ///\n    /// This function takes a cell reference (e.g., \"A1\", \"B10\") and converts it to\n    /// row and column indices. It also validates that the referenced cell exists within\n    /// the spreadsheet's dimensions.\n    ///\n    /// # Arguments\n    /// * `cell_name` - The cell reference (e.g., \"A1\", \"B10\")\n    ///\n    /// # Returns\n    /// * `Some((row, col))` - The row and column indices if the cell name is valid\n    /// * `None` - If the cell name is invalid or refers to a cell outside the spreadsheet\n    ///\n    /// # Example\n    /// ```\n    /// let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n    /// assert_eq!(sheet.spreadsheet_parse_cell_name(\"A1\"), Some((1, 1)));\n    /// assert_eq!(sheet.spreadsheet_parse_cell_name(\"B10\"), Some((10, 2)));\n    /// assert_eq!(sheet.spreadsheet_parse_cell_name(\"K11\"), None); // Outside dimensions\n    /// ```\n    pub fn spreadsheet_parse_cell_name(\u0026self, cell_name: \u0026str) -\u003e Option\u003c(i16, i16)\u003e {\n        let mut letters = String::new();\n        let mut digits = String::new();\n        let mut found_digit = false;\n\n        for c in cell_name.chars() {\n            if c.is_ascii_alphabetic() {\n                if found_digit {\n                    return None;\n                }\n                letters.push(c);\n            } else if c.is_ascii_digit() {\n                found_digit = true;\n                digits.push(c);\n            } else {\n                return None;\n            }\n        }\n\n        if letters.is_empty() || digits.is_empty() {\n            return None;\n        }\n\n        let col = Self::letter_to_col(\u0026letters);\n        let row = digits.parse::\u003ci16\u003e().ok()?;\n\n        if col \u003e self.cols || row \u003e self.rows || row == 0 {\n            return None;\n        }\n        Some((row, col))\n    }\n\n    /// Checks if a string is numeric.\n    ///\n    /// This utility function checks if a string contains only numeric digits.\n    /// It returns false for empty strings or strings with non-digit characters.\n    ///\n    /// # Arguments\n    /// * `s` - The string to check\n    ///\n    /// # Returns\n    /// `true` if the string contains only digits, `false` otherwise\n    ///\n    /// # Example\n    /// ```\n    /// assert!(Spreadsheet::is_numeric(\"123\"));\n    /// assert!(!Spreadsheet::is_numeric(\"12a\"));\n    /// assert!(!Spreadsheet::is_numeric(\"\"));\n    /// ```\n    pub fn is_numeric(s: \u0026str) -\u003e bool {\n        !s.is_empty() \u0026\u0026 s.chars().all(|c| c.is_ascii_digit())\n    }\n\n    /// Evaluates a parsed right-hand side expression and returns its value and error status.\n    ///\n    /// This complex function evaluates different types of expressions:\n    /// - Functions like SUM, MIN, MAX, AVG, STDEV\n    /// - Sleep operations\n    /// - Arithmetic expressions\n    /// - Single value references\n    ///\n    /// It handles cell references, numeric values, and produces appropriate error states.\n    ///\n    /// # Arguments\n    /// * `expr` - The parsed expression to evaluate\n    /// * `_row` - Row of the cell containing the expression (for context)\n    /// * `_col` - Column of the cell containing the expression (for context)\n    ///\n    /// # Returns\n    /// A tuple containing:\n    /// * The calculated value\n    /// * Whether an error occurred during evaluation\n    ///\n    /// # Error Handling\n    /// Returns an error state (second tuple element = true) for:\n    /// - Division by zero\n    /// - References to cells in error state\n    /// - Invalid operations\n    pub fn spreadsheet_evaluate_expression(\n        \u0026self,\n        expr: \u0026ParsedRHS,\n        _row: i16,\n        _col: i16,\n    ) -\u003e (i32, bool) {\n        match expr {\n            ParsedRHS::Function { name, args } =\u003e {\n                let mut error = false;\n                let (arg1, arg2) = args;\n                let (r1, c1) = match arg1 {\n                    Operand::Cell(r, c) =\u003e (*r, *c),\n                    Operand::Number(_) =\u003e (0, 0),\n                };\n                let (r2, c2) = match arg2 {\n                    Operand::Cell(r, c) =\u003e (*r, *c),\n                    Operand::Number(_) =\u003e (0, 0),\n                };\n\n                let mut values =\n                    Vec::with_capacity((r2 - r1 + 1) as usize * (c2 - c1 + 1) as usize);\n\n                for i in r1..=r2 {\n                    for j in c1..=c2 {\n                        let index = (i - 1) as usize * self.cols as usize + (j - 1) as usize;\n                        if index \u003c self.cells.len() {\n                            if let Some(ref c) = self.cells[index] {\n                                if c.error {\n                                    error = true;\n                                    return (0, error);\n                                }\n                                values.push(c.value);\n                            }\n                        }\n                    }\n                }\n\n                match name {\n                    FunctionName::Min =\u003e {\n                        error = false;\n                        return (*values.iter().min().unwrap_or(\u00260), error);\n                    }\n                    FunctionName::Max =\u003e {\n                        error = false;\n                        return (*values.iter().max().unwrap_or(\u00260), error);\n                    }\n                    FunctionName::Sum =\u003e {\n                        error = false;\n                        return (values.iter().sum(), error);\n                    }\n                    FunctionName::Avg =\u003e {\n                        error = false;\n                        let sum: i32 = values.iter().sum();\n                        return (sum / values.len() as i32, error);\n                    }\n                    FunctionName::Stdev =\u003e {\n                        if values.len() \u003c 2 {\n                            return (0, error);\n                        }\n\n                        let mean = values.iter().sum::\u003ci32\u003e() as f64 / values.len() as f64;\n                        let variance = values\n                            .iter()\n                            .map(|\u0026x| {\n                                let diff = x as f64 - mean;\n                                diff * diff\n                            })\n                            .sum::\u003cf64\u003e()\n                            / values.len() as f64;\n\n                        error = false;\n                        return ((variance.sqrt().round()) as i32, error);\n                    }\n                    _ =\u003e {}\n                }\n\n                (0, error)\n            }\n            ParsedRHS::Sleep(op) =\u003e {\n                let mut val = 0;\n                let error = false;\n\n                match op {\n                    Operand::Number(n) =\u003e {\n                        val = *n;\n                    }\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        if let Some(cell) = self.cells.get(index).and_then(|c| c.as_ref()) {\n                            val = cell.value;\n                            if cell.error {\n                                return (val, true);\n                            }\n                        }\n                    }\n                }\n\n                if val \u003e 0 {\n                    std::thread::sleep(std::time::Duration::from_secs(val as u64));\n                }\n\n                (val, error)\n            }\n            ParsedRHS::Arithmetic { lhs, operator, rhs } =\u003e {\n                let (lhs_val, lhs_err) = match lhs {\n                    Operand::Number(n) =\u003e (*n, false),\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        self.cells[index]\n                            .as_ref()\n                            .map_or((0, true), |cell| (cell.value, cell.error))\n                    }\n                };\n\n                let (rhs_val, rhs_err) = match rhs {\n                    Operand::Number(n) =\u003e (*n, false),\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        self.cells[index]\n                            .as_ref()\n                            .map_or((0, true), |cell| (cell.value, cell.error))\n                    }\n                };\n\n                let mut has_error = lhs_err || rhs_err;\n\n                let result = match operator {\n                    '+' =\u003e lhs_val + rhs_val,\n                    '-' =\u003e lhs_val - rhs_val,\n                    '*' =\u003e lhs_val * rhs_val,\n                    '/' =\u003e {\n                        if rhs_val == 0 {\n                            has_error = true;\n                            0\n                        } else {\n                            lhs_val / rhs_val\n                        }\n                    }\n                    _ =\u003e {\n                        has_error = true;\n                        0\n                    }\n                };\n\n                (result, has_error)\n            }\n\n            ParsedRHS::SingleValue(num) =\u003e match num {\n                Operand::Cell(r, c) =\u003e {\n                    let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                    self.cells[index]\n                        .as_ref()\n                        .map_or((0, false), |cell| (cell.value, cell.error))\n                }\n                Operand::Number(x) =\u003e (*x, false),\n            },\n            ParsedRHS::None =\u003e (0, false),\n        }\n    }\n\n    /// Recursively finds cycles in the dependency graph using a stack.\n    ///\n    /// This function implements cycle detection in the cell dependency graph to prevent\n    /// circular references. It uses a stack-based approach rather than recursion for\n    /// better performance with deep dependency chains.\n    ///\n    /// # Arguments\n    /// * `(r1, r2)` - Row range to check\n    /// * `(c1, c2)` - Column range to check\n    /// * `range_bool` - Whether checking a range (true) or specific cells (false)\n    /// * `visited` - Set of already visited cells to prevent re-processing\n    /// * `stack` - Stack of cells to process\n    ///\n    /// # Returns\n    /// `true` if a cycle is detected, `false` otherwise\n    pub fn rec_find_cycle_using_stack\u003c'a\u003e(\n        \u0026'a self,\n        (r1, r2): (i16, i16),\n        (c1, c2): (i16, i16),\n        range_bool: bool,\n        visited: \u0026mut BTreeSet\u003c(i16, i16)\u003e,\n        stack: \u0026mut Vec\u003c\u0026'a Cell\u003e,\n    ) -\u003e bool {\n        while let Some(my_node) = stack.pop() {\n            if visited.contains(\u0026(my_node.row, my_node.col)) {\n                continue;\n            }\n            visited.insert((my_node.row, my_node.col));\n            let in_range = if range_bool {\n                my_node.row \u003e= r1 \u0026\u0026 my_node.row \u003c= r2 \u0026\u0026 my_node.col \u003e= c1 \u0026\u0026 my_node.col \u003c= c2\n            } else {\n                (my_node.row == r1 \u0026\u0026 my_node.col == c1) || (my_node.row == r2 \u0026\u0026 my_node.col == c2)\n            };\n\n            if in_range {\n                return true;\n            } else {\n                let dependent_names = self.get_dependent_names(my_node);\n                for dependent_name in \u0026dependent_names {\n                    if !visited.contains(dependent_name) {\n                        let r = dependent_name.0;\n                        let c = dependent_name.1;\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        if index \u003c self.cells.len() {\n                            if let Some(ref neighbor_node) = self.cells[index] {\n                                stack.push(neighbor_node);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        false\n    }\n\n    /// Returns the names of cells that depend on the given cell.\n    ///\n    /// This function extracts the list of dependent cells from a cell's dependency tracker,\n    /// handling the different internal representations (Vector, Set, None) transparently.\n    ///\n    /// # Arguments\n    /// * `cell` - The cell to get dependents for\n    ///\n    /// # Returns\n    /// A vector of (row, column) pairs representing the cells that depend on the given cell\n    pub fn get_dependent_names(\u0026self, cell: \u0026Cell) -\u003e Vec\u003c(i16, i16)\u003e {\n        match \u0026cell.dependents {\n            crate::cell::Dependents::Vector(vec) =\u003e vec.clone(),\n            crate::cell::Dependents::Set(set) =\u003e set.iter().cloned().collect(),\n            crate::cell::Dependents::None =\u003e Vec::new(),\n        }\n    }\n\n    /// Initiates the cycle detection process for a given cell and range.\n    ///\n    /// This function sets up the cycle detection by creating initial state and delegating\n    /// to the stack-based cycle detection algorithm. It's used to check if adding a\n    /// dependency would create a circular reference.\n    ///\n    /// # Arguments\n    /// * `(r_, c_)` - The cell initiating the dependency\n    /// * `(r1, c1)` - Start of range or first specific cell\n    /// * `(r2, c2)` - End of range or second specific cell\n    /// * `range_bool` - Whether checking a range (true) or specific cells (false)\n    ///\n    /// # Returns\n    /// `true` if a cycle would be created, `false` otherwise\n    pub fn first_step_find_cycle(\n        \u0026self,\n        (r_, c_): (i16, i16),\n        (r1, c1): (i16, i16),\n        (r2, c2): (i16, i16),\n        range_bool: bool,\n    ) -\u003e bool {\n        let index = (r_ - 1) as usize * self.cols as usize + (c_ - 1) as usize;\n\n        let start_node = self.cells[index].as_ref().unwrap();\n\n        let mut visited = BTreeSet::new();\n        let mut stack = vec![\u0026**start_node];\n\n        self.rec_find_cycle_using_stack((r1, r2), (c1, c2), range_bool, \u0026mut visited, \u0026mut stack)\n    }\n\n    /// Removes old dependencies for a cell.\n    ///\n    /// This function cleans up existing dependencies before assigning a new formula to a cell.\n    /// It examines the cell's current formula and removes the cell from the dependents lists\n    /// of all cells it currently depends on.\n    ///\n    /// # Arguments\n    /// * `r` - Row of the cell having dependencies removed\n    /// * `c` - Column of the cell having dependencies removed\n    pub fn remove_old_dependents(\u0026mut self, r: i16, c: i16) {\n        let formula = {\n            let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n            let curr_cell = self.cells[index].as_ref().unwrap();\n            curr_cell.formula.clone()\n        };\n\n        match formula {\n            ParsedRHS::Function { name, args } =\u003e {\n                if !name.is_copy() {\n                    let (arg1, arg2) = args;\n                    let (start_row, start_col) = match arg1 {\n                        Operand::Cell(row, col) =\u003e (row, col),\n                        Operand::Number(_) =\u003e (0, 0),\n                    };\n                    let (end_row, end_col) = match arg2 {\n                        Operand::Cell(row, col) =\u003e (row, col),\n                        Operand::Number(_) =\u003e (0, 0), // Placeholder\n                    };\n\n                    for dep_r in start_row..=end_row {\n                        for dep_c in start_col..=end_col {\n                            let dep_index =\n                                (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                            if let Some(dep_cell) =\n                                self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut())\n                            {\n                                crate::cell::cell_dep_remove(dep_cell, r, c);\n                            }\n                        }\n                    }\n                }\n            }\n            ParsedRHS::Arithmetic {\n                lhs,\n                operator: _,\n                rhs,\n            } =\u003e {\n                if let Operand::Cell(dep_r, dep_c) = lhs {\n                    let dep_cell = self.cells\n                        [(dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize]\n                        .as_mut()\n                        .unwrap();\n                    crate::cell::cell_dep_remove(dep_cell, r, c);\n                }\n                if let Operand::Cell(dep_r, dep_c) = rhs {\n                    let dep_cell = self.cells\n                        [(dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize]\n                        .as_mut()\n                        .unwrap();\n                    crate::cell::cell_dep_remove(dep_cell, r, c);\n                }\n            }\n            ParsedRHS::SingleValue(Operand::Cell(dep_r, dep_c)) =\u003e {\n                let dep_index = (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n                let dep_cell = self.cells[dep_index].as_mut().unwrap();\n                crate::cell::cell_dep_remove(dep_cell, r, c);\n            }\n            ParsedRHS::Sleep(Operand::Cell(dep_r, dep_c)) =\u003e {\n                let dep_index = (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                let dep_cell = self.cells[dep_index].as_mut().unwrap();\n                crate::cell::cell_dep_remove(dep_cell, r, c);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Updates the dependencies for a cell.\n    ///\n    /// This function establishes new dependencies after a cell's formula changes.\n    /// It first removes old dependencies, then adds the cell as a dependent to all\n    /// cells it now depends on based on its new formula.\n    ///\n    /// # Arguments\n    /// * `(r, c)` - The cell being updated\n    /// * `(start_row, start_col)` - Start of range or first specific cell\n    /// * `(end_row, end_col)` - End of range or second specific cell\n    /// * `is_range` - Whether dealing with a range (true) or specific cells (false)\n    ///\n    /// # Returns\n    /// Always returns 0 (legacy return value maintained for compatibility)\n    pub fn update_dependencies(\n        \u0026mut self,\n        (r, c): (i16, i16),\n        (start_row, start_col): (i16, i16),\n        (end_row, end_col): (i16, i16),\n        is_range: bool,\n    ) -\u003e i32 {\n        self.remove_old_dependents(r, c);\n\n        if is_range {\n            for r_it in start_row..=end_row {\n                for c_it in start_col..=end_col {\n                    let dep_index = (r_it - 1) as usize * self.cols as usize + (c_it - 1) as usize;\n                    let dep_cell = self.cells[dep_index].as_mut().unwrap();\n                    crate::cell::cell_dep_insert(dep_cell, r, c);\n                }\n            }\n        } else {\n            if start_row \u003e 0 {\n                let dep_index =\n                    (start_row - 1) as usize * self.cols as usize + (start_col - 1) as usize;\n                let dep_cell = self.cells[dep_index].as_mut().unwrap();\n                crate::cell::cell_dep_insert(dep_cell, r, c);\n            }\n            if end_row \u003e 0 {\n                let dep_index =\n                    (end_row - 1) as usize * self.cols as usize + (end_col - 1) as usize;\n\n                let dep_cell = self.cells[dep_index].as_mut().unwrap();\n                crate::cell::cell_dep_insert(dep_cell, r, c);\n            }\n        }\n        0\n    }\n\n    /// Performs a topological sort on the dependency graph starting from a given cell.\n    ///\n    /// This function sorts cells in dependency order, ensuring that cells are evaluated\n    /// only after all their dependencies have been evaluated. This is crucial for\n    /// correctly propagating value changes through the dependency chain.\n    ///\n    /// # Arguments\n    /// * `starting` - The cell to start the topological sort from\n    ///\n    /// # Returns\n    /// A boxed vector of (row, column) pairs in topological order\n    pub fn topo_sort(\u0026self, starting: \u0026Cell) -\u003e Box\u003cVec\u003c(i16, i16)\u003e\u003e {\n        let mut sorted_nodes = Box::new(Vec::new());\n        let mut stack = Box::new(Vec::new());\n        stack.push(starting.clone());\n\n        let mut visited = Box::new(BTreeSet::new());\n\n        let mut work_stack = Box::new(Vec::new());\n        work_stack.push(Box::new((starting.row, starting.col)));\n\n        while let Some(current) = work_stack.pop() {\n            let current = *current;\n            if visited.contains(\u0026current) {\n                continue;\n            }\n\n            let index = (current.0 - 1) as usize * self.cols as usize + (current.1 - 1) as usize;\n            if let Some(cell) = self.cells.get(index).and_then(|opt| opt.as_ref()) {\n                let dependent_keys = self.get_dependent_names(cell);\n                let mut all_dependents_visited = true;\n\n                for dep_key in \u0026dependent_keys {\n                    if !visited.contains(dep_key) {\n                        let (r, c) = *dep_key;\n                        work_stack.push(Box::new(current));\n                        work_stack.push(Box::new((r, c)));\n                        all_dependents_visited = false;\n                        break;\n                    }\n                }\n\n                if all_dependents_visited {\n                    visited.insert(current);\n                    sorted_nodes.push(current);\n                }\n            }\n        }\n        sorted_nodes.reverse();\n        sorted_nodes\n    }\n\n    /// Sets the value of a cell and updates dependencies and dependent cells.\n    ///\n    /// This is the main function for updating a cell's formula. It:\n    /// 1. Handles special cases like COPY function\n    /// 2. Checks for circular references\n    /// 3. Updates dependencies\n    /// 4. Evaluates the new formula\n    /// 5. Propagates changes to dependent cells\n    /// 6. Updates the undo stack\n    ///\n    /// # Arguments\n    /// * `row` - Row of the cell to update\n    /// * `col` - Column of the cell to update\n    /// * `rhs` - The new formula for the cell\n    /// * `status_out` - Output parameter for operation status message\n    ///\n    /// # Side Effects\n    /// - Updates the cell's value and error state\n    /// - Updates dependent cells' values\n    /// - Adds to the undo stack\n    /// - Modifies `status_out` to indicate success or failure\n    pub fn spreadsheet_set_cell_value(\n        \u0026mut self,\n        row: i16,\n        col: i16,\n        rhs: ParsedRHS,\n        status_out: \u0026mut String,\n    ) {\n        let index = (row - 1) as usize * self.cols as usize + (col - 1) as usize;\n\n        if let ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (Operand::Cell(start_row, start_col), Operand::Cell(end_row, end_col)),\n        } = rhs\n        {\n            let dest_row = row;\n            let dest_col = col;\n            let row_offset = dest_row as isize - start_row as isize;\n            let col_offset = dest_col as isize - start_col as isize;\n\n            let mut src_val: Vec\u003ci32\u003e = Vec::new();\n            let mut src_err: Vec\u003cbool\u003e = Vec::new();\n            for r in start_row..=end_row {\n                for c in start_col..=end_col {\n                    let src_index = ((r - 1) * self.cols + (c - 1)) as usize;\n                    let src_cell = self.cells[src_index].as_ref().unwrap();\n                    src_val.push(src_cell.value);\n                    src_err.push(src_cell.error);\n                }\n            }\n            let mut cnter = 0;\n            for r in start_row..=end_row {\n                for c in start_col..=end_col {\n                    self.update_dependencies((r, c), (0, 0), (0, 0), false);\n                    let dest_index = ((r as isize + row_offset - 1) * self.cols as isize\n                        + (c as isize + col_offset - 1))\n                        as usize;\n                    if dest_index \u003c self.cells.len() {\n                        let dest_cell = self.cells[dest_index].as_mut().unwrap();\n                        self.undo_stack.push((\n                            dest_cell.formula.clone(),\n                            dest_cell.row,\n                            dest_cell.col,\n                        ));\n                        dest_cell.value = src_val[cnter];\n                        dest_cell.formula =\n                            ParsedRHS::SingleValue(Operand::Number(dest_cell.value));\n                        dest_cell.error = src_err[cnter];\n                        cnter += 1;\n                    }\n                }\n            }\n            *status_out = \"ok\".to_string();\n            return;\n        }\n\n        let mut r1 = 0;\n        let mut r2 = 0;\n        let mut c1 = 0;\n        let mut c2 = 0;\n        let mut is_range = false;\n        match \u0026rhs {\n            ParsedRHS::Function {\n                args: (Operand::Cell(w, x), Operand::Cell(y, z)),\n                ..\n            } =\u003e {\n                r1 = *w;\n                r2 = *y;\n                c1 = *x;\n                c2 = *z;\n                is_range = true;\n            }\n            ParsedRHS::Arithmetic { lhs, rhs, .. } =\u003e {\n                if let Operand::Cell(w, x) = lhs {\n                    r1 = *w;\n                    c1 = *x;\n                }\n                if let Operand::Cell(y, z) = rhs {\n                    r2 = *y;\n                    c2 = *z;\n                }\n            }\n            ParsedRHS::Sleep(Operand::Cell(r, c)) =\u003e {\n                r1 = *r;\n                c1 = *c;\n            }\n            ParsedRHS::SingleValue(Operand::Cell(r, c)) =\u003e {\n                r1 = *r;\n                c1 = *c;\n            }\n            _ =\u003e {}\n        };\n\n        if self.first_step_find_cycle((row, col), (r1, c1), (r2, c2), is_range) {\n            *status_out = \"Cycle Detected\".to_string();\n            return;\n        }\n\n        self.update_dependencies((row, col), (r1, c1), (r2, c2), is_range);\n        let cell = self.cells[index].as_mut().unwrap();\n        self.undo_stack\n            .push((cell.formula.clone(), cell.row, cell.col));\n\n        cell.formula = rhs;\n        let cell = self.cells[index].as_ref().unwrap();\n\n        let sorted_cells = self.topo_sort(cell);\n\n        for (row, col) in sorted_cells.iter() {\n            let sorted_index = (*row - 1) as usize * self.cols as usize + (*col - 1) as usize;\n\n            let formula = \u0026self.cells[sorted_index].as_ref().unwrap().formula;\n\n            let (value, error_cell) = self.spreadsheet_evaluate_expression(formula, *row, *col);\n\n            let sorted_cell = self.cells[sorted_index].as_mut().unwrap();\n            sorted_cell.value = value;\n            sorted_cell.error = error_cell;\n        }\n\n        *status_out = \"ok\".to_string();\n    }\n\n    /// Undoes the last operation by restoring the previous cell states.\n    ///\n    /// This function reverts the spreadsheet to its previous state by popping operations\n    /// from the undo stack and applying them in reverse. It handles the entire undo operation\n    /// as a single atomic action.\n    ///\n    /// # Arguments\n    /// * `status_out` - Output parameter for operation status message\n    ///\n    /// # Side Effects\n    /// - Modifies multiple cells back to their previous states\n    /// - Clears the current undo stack\n    /// - Rebuilds dependencies based on the restored formulas\n    pub fn spreadsheet_undo(\u0026mut self, status_out: \u0026mut String) {\n        let mut undo_stack = self.undo_stack.clone();\n        self.undo_stack.clear();\n        for _ in 0..undo_stack.len() {\n            let (formula_new, row, col) = undo_stack.pop().unwrap();\n\n            self.spreadsheet_set_cell_value(row, col, formula_new, status_out);\n        }\n    }\n\n    /// Displays the current state of the spreadsheet.\n    ///\n    /// This function prints a formatted view of the spreadsheet to the console,\n    /// showing a window of cells based on the current view_row and view_col settings.\n    /// It displays at most 10 rows and 10 columns at a time.\n    ///\n    /// # Format\n    /// - Column headers are shown as letters (A, B, C, ...)\n    /// - Row headers are shown as numbers (1, 2, 3, ...)\n    /// - Cell values are displayed in the grid\n    /// - Cells with errors show \"ERR\" instead of their value\n    pub fn spreadsheet_display(\u0026self) {\n        let end_row = if self.view_row + 10 \u003c self.rows {\n            self.view_row + 10\n        } else {\n            self.rows\n        };\n\n        let end_col = if self.view_col + 10 \u003c self.cols {\n            self.view_col + 10\n        } else {\n            self.cols\n        };\n\n        print!(\"\\t\\t\");\n        for col in (self.view_col + 1)..=end_col {\n            print!(\"{}\\t\\t\", Self::col_to_letter(col));\n        }\n        println!();\n        for row in (self.view_row + 1)..=end_row {\n            print!(\"{}\\t\\t\", row);\n            for col in (self.view_col + 1)..=end_col {\n                let index = (row - 1) as usize * self.cols as usize + (col - 1) as usize;\n                if let Some(cell) = self.cells.get(index).and_then(|opt| opt.as_ref()) {\n                    if cell.error {\n                        print!(\"ERR\\t\\t\");\n                    } else {\n                        print!(\"{:\u003c16}\", cell.value);\n                    }\n                } else {\n                    print!(\"0\\t\\t\");\n                }\n            }\n            println!();\n        }\n    }\n\n    /// Checks if a command is valid and returns the parsed result.\n    ///\n    /// This function parses and validates a cell update command, such as \"A1=B1+C1\" or\n    /// \"D5=SUM(A1:A10)\". It ensures the cell reference is valid and the formula can be parsed.\n    ///\n    /// # Arguments\n    /// * `cell_name` - The name of the cell to update (e.g., \"A1\")\n    /// * `formula` - The formula to assign to the cell\n    ///\n    /// # Returns\n    /// A tuple containing:\n    /// * Whether the command is valid\n    /// * The row of the target cell\n    /// * The column of the target cell\n    /// * The parsed formula\n    ///\n    /// # Example\n    /// ```\n    /// let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n    /// let (valid, row, col, formula) = sheet.is_valid_command(\"A1\", \"10\");\n    /// assert!(valid);\n    /// assert_eq!(row, 1);\n    /// assert_eq!(col, 1);\n    /// // formula will be ParsedRHS::SingleValue(Operand::Number(10))\n    /// ```\n    pub fn is_valid_command(\u0026self, cell_name: \u0026str, formula: \u0026str) -\u003e (bool, i16, i16, ParsedRHS) {\n        let mut ret = (false, 0, 0, ParsedRHS::None);\n        if cell_name.is_empty() || formula.is_empty() {\n            return ret;\n        }\n\n        if let Some((row, col)) = self.spreadsheet_parse_cell_name(cell_name) {\n            ret.1 = row;\n            ret.2 = col;\n        } else {\n            return ret;\n        }\n        if formula.is_empty() {\n            return ret;\n        }\n        if let Some(captures) = FUNC_REGEX.captures(formula) {\n            let func = captures.get(1).unwrap().as_str();\n            let args = captures.get(2).unwrap().as_str();\n\n            if func.eq_ignore_ascii_case(\"SLEEP\") {\n                if args.is_empty() {\n                    return ret;\n                }\n                if let Ok(value) = args.parse::\u003ci32\u003e() {\n                    ret.0 = true;\n                    ret.3 = ParsedRHS::Sleep(Operand::Number(value));\n                    return ret;\n                }\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(args) {\n                    ret.0 = true;\n                    ret.3 = ParsedRHS::Sleep(Operand::Cell(row, col));\n                    return ret;\n                }\n                return ret;\n            } else {\n                if let Some(colon_pos) = args.find(':') {\n                    let (start, end) = args.split_at(colon_pos);\n                    let end = \u0026end[1..];\n\n                    if let (Some((start_row, start_col)), Some((end_row, end_col))) = (\n                        self.spreadsheet_parse_cell_name(start),\n                        self.spreadsheet_parse_cell_name(end),\n                    ) {\n                        if start_row \u003c= end_row \u0026\u0026 start_col \u003c= end_col {\n                            if let Some(fname) = FunctionName::from_strng(func) {\n                                if func == \"COPY\" {\n                                    let dest_row = ret.1;\n                                    let dest_col = ret.2;\n                                    let row_offset = dest_row - start_row;\n                                    let col_offset = dest_col - start_col;\n                                    let final_row = end_row + row_offset;\n                                    let final_col = end_col + col_offset;\n\n                                    if final_row \u003e 0\n                                        \u0026\u0026 final_row \u003c= self.rows\n                                        \u0026\u0026 final_col \u003e 0\n                                        \u0026\u0026 final_col \u003c= self.cols\n                                    {\n                                        ret.0 = true;\n                                        ret.3 = ParsedRHS::Function {\n                                            name: fname,\n                                            args: (\n                                                Operand::Cell(start_row, start_col),\n                                                Operand::Cell(end_row, end_col),\n                                            ),\n                                        };\n                                        return ret;\n                                    } else {\n                                        ret.0 = false;\n                                        return ret;\n                                    }\n                                }\n                                ret.0 = true;\n                                ret.3 = ParsedRHS::Function {\n                                    name: fname,\n                                    args: (\n                                        Operand::Cell(start_row, start_col),\n                                        Operand::Cell(end_row, end_col),\n                                    ),\n                                };\n                                return ret;\n                            }\n                        }\n                    }\n                }\n                return ret;\n            }\n        }\n\n        if let Some((row, col)) = self.spreadsheet_parse_cell_name(formula) {\n            ret.0 = true;\n            ret.3 = ParsedRHS::SingleValue(Operand::Cell(row, col));\n            return ret;\n        }\n\n        if let Ok(value) = formula.parse::\u003ci32\u003e() {\n            ret.0 = true;\n            ret.3 = ParsedRHS::SingleValue(Operand::Number(value));\n            return ret;\n        }\n        let (b, x) = self.is_valid_arithmetic_expression(formula);\n        if b {\n            ret.0 = true;\n            ret.3 = x;\n            ret\n        } else {\n            ret.0 = false;\n            ret\n        }\n    }\n\n    /// Checks if an arithmetic expression is valid and returns the parsed result.\n    ///\n    /// This function parses expressions like \"A1+B2\", \"10-5\", \"C3*D4\", or \"E5/F6\".\n    /// It validates the operands and operator, and constructs a ParsedRHS if valid.\n    ///\n    /// # Arguments\n    /// * `expr` - The arithmetic expression to parse\n    ///\n    /// # Returns\n    /// A tuple containing:\n    /// * Whether the expression is valid\n    /// * The parsed expression as a ParsedRHS\n    ///\n    /// # Recognized Formats\n    /// - Cell reference + Cell reference: \"A1+B2\"\n    /// - Cell reference + Number: \"A1+10\"\n    /// - Number + Cell reference: \"10+A1\"\n    /// - Number + Number: \"10+20\"\n    /// - Operators: +, -, *, /\n    pub fn is_valid_arithmetic_expression(\u0026self, expr: \u0026str) -\u003e (bool, ParsedRHS) {\n        let mut ret = (false, ParsedRHS::None);\n        if let Some(captures) = ARITH_EXPR_REGEX.captures(expr) {\n            let first_operand = captures.get(1).unwrap().as_str();\n            let operator = captures.get(4).unwrap().as_str();\n            let second_operand = captures.get(5).unwrap().as_str();\n\n            let oprnd1 = if first_operand.chars().next().unwrap().is_ascii_alphabetic() {\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(first_operand) {\n                    Operand::Cell(row, col)\n                } else {\n                    return (false, ParsedRHS::None);\n                }\n            } else if let Ok(value) = first_operand.parse::\u003ci32\u003e() {\n                Operand::Number(value)\n            } else {\n                return (false, ParsedRHS::None);\n            };\n\n            let oprnd2 = if second_operand.chars().next().unwrap().is_ascii_alphabetic() {\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(second_operand) {\n                    Operand::Cell(row, col)\n                } else {\n                    return (false, ParsedRHS::None);\n                }\n            } else if let Ok(value) = second_operand.parse::\u003ci32\u003e() {\n                Operand::Number(value)\n            } else {\n                return (false, ParsedRHS::None);\n            };\n            if let Some(op_char) = operator.chars().next() {\n                if \"+-*/\".contains(op_char) {\n                    ret.0 = true;\n                    ret.1 = ParsedRHS::Arithmetic {\n                        lhs: oprnd1,\n                        operator: op_char,\n                        rhs: oprnd2,\n                    };\n                }\n            } else {\n                return (false, ParsedRHS::None);\n            }\n\n            ret\n        } else {\n            ret\n        }\n    }\n}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":7}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":21}},{"line":99,"address":[],"length":0,"stats":{"Line":42}},{"line":123,"address":[],"length":0,"stats":{"Line":19}},{"line":124,"address":[],"length":0,"stats":{"Line":19}},{"line":125,"address":[],"length":0,"stats":{"Line":19}},{"line":126,"address":[],"length":0,"stats":{"Line":19}},{"line":127,"address":[],"length":0,"stats":{"Line":19}},{"line":128,"address":[],"length":0,"stats":{"Line":19}},{"line":129,"address":[],"length":0,"stats":{"Line":19}},{"line":130,"address":[],"length":0,"stats":{"Line":19}},{"line":133,"address":[],"length":0,"stats":{"Line":18301441}},{"line":134,"address":[],"length":0,"stats":{"Line":18301422}},{"line":137,"address":[],"length":0,"stats":{"Line":1568}},{"line":138,"address":[],"length":0,"stats":{"Line":36604393}},{"line":139,"address":[],"length":0,"stats":{"Line":18301422}},{"line":140,"address":[],"length":0,"stats":{"Line":18301422}},{"line":144,"address":[],"length":0,"stats":{"Line":19}},{"line":164,"address":[],"length":0,"stats":{"Line":141}},{"line":165,"address":[],"length":0,"stats":{"Line":141}},{"line":166,"address":[],"length":0,"stats":{"Line":141}},{"line":167,"address":[],"length":0,"stats":{"Line":607}},{"line":168,"address":[],"length":0,"stats":{"Line":233}},{"line":169,"address":[],"length":0,"stats":{"Line":233}},{"line":170,"address":[],"length":0,"stats":{"Line":233}},{"line":172,"address":[],"length":0,"stats":{"Line":141}},{"line":192,"address":[],"length":0,"stats":{"Line":212}},{"line":193,"address":[],"length":0,"stats":{"Line":212}},{"line":195,"address":[],"length":0,"stats":{"Line":729}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":239,"address":[],"length":0,"stats":{"Line":144}},{"line":240,"address":[],"length":0,"stats":{"Line":144}},{"line":241,"address":[],"length":0,"stats":{"Line":144}},{"line":242,"address":[],"length":0,"stats":{"Line":144}},{"line":244,"address":[],"length":0,"stats":{"Line":452}},{"line":245,"address":[],"length":0,"stats":{"Line":308}},{"line":246,"address":[],"length":0,"stats":{"Line":122}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":119}},{"line":250,"address":[],"length":0,"stats":{"Line":339}},{"line":251,"address":[],"length":0,"stats":{"Line":153}},{"line":252,"address":[],"length":0,"stats":{"Line":153}},{"line":254,"address":[],"length":0,"stats":{"Line":33}},{"line":258,"address":[],"length":0,"stats":{"Line":209}},{"line":259,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":100}},{"line":263,"address":[],"length":0,"stats":{"Line":100}},{"line":265,"address":[],"length":0,"stats":{"Line":191}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":268,"address":[],"length":0,"stats":{"Line":94}},{"line":288,"address":[],"length":0,"stats":{"Line":14}},{"line":289,"address":[],"length":0,"stats":{"Line":63}},{"line":317,"address":[],"length":0,"stats":{"Line":98}},{"line":323,"address":[],"length":0,"stats":{"Line":98}},{"line":324,"address":[],"length":0,"stats":{"Line":30}},{"line":325,"address":[],"length":0,"stats":{"Line":30}},{"line":326,"address":[],"length":0,"stats":{"Line":30}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":30}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":30}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":82}},{"line":340,"address":[],"length":0,"stats":{"Line":177}},{"line":341,"address":[],"length":0,"stats":{"Line":95}},{"line":342,"address":[],"length":0,"stats":{"Line":95}},{"line":343,"address":[],"length":0,"stats":{"Line":190}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":93}},{"line":354,"address":[],"length":0,"stats":{"Line":28}},{"line":356,"address":[],"length":0,"stats":{"Line":4}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":4}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":7}},{"line":365,"address":[],"length":0,"stats":{"Line":7}},{"line":368,"address":[],"length":0,"stats":{"Line":9}},{"line":369,"address":[],"length":0,"stats":{"Line":9}},{"line":370,"address":[],"length":0,"stats":{"Line":9}},{"line":373,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":8}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":382,"address":[],"length":0,"stats":{"Line":6}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":10}},{"line":396,"address":[],"length":0,"stats":{"Line":10}},{"line":397,"address":[],"length":0,"stats":{"Line":10}},{"line":399,"address":[],"length":0,"stats":{"Line":10}},{"line":400,"address":[],"length":0,"stats":{"Line":6}},{"line":401,"address":[],"length":0,"stats":{"Line":6}},{"line":403,"address":[],"length":0,"stats":{"Line":4}},{"line":404,"address":[],"length":0,"stats":{"Line":4}},{"line":405,"address":[],"length":0,"stats":{"Line":16}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":14}},{"line":415,"address":[],"length":0,"stats":{"Line":5}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":13}},{"line":421,"address":[],"length":0,"stats":{"Line":26}},{"line":422,"address":[],"length":0,"stats":{"Line":5}},{"line":423,"address":[],"length":0,"stats":{"Line":8}},{"line":424,"address":[],"length":0,"stats":{"Line":8}},{"line":425,"address":[],"length":0,"stats":{"Line":8}},{"line":427,"address":[],"length":0,"stats":{"Line":24}},{"line":431,"address":[],"length":0,"stats":{"Line":26}},{"line":432,"address":[],"length":0,"stats":{"Line":8}},{"line":433,"address":[],"length":0,"stats":{"Line":5}},{"line":434,"address":[],"length":0,"stats":{"Line":5}},{"line":435,"address":[],"length":0,"stats":{"Line":5}},{"line":437,"address":[],"length":0,"stats":{"Line":15}},{"line":441,"address":[],"length":0,"stats":{"Line":37}},{"line":443,"address":[],"length":0,"stats":{"Line":26}},{"line":444,"address":[],"length":0,"stats":{"Line":7}},{"line":445,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":4}},{"line":449,"address":[],"length":0,"stats":{"Line":3}},{"line":450,"address":[],"length":0,"stats":{"Line":3}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":13}},{"line":464,"address":[],"length":0,"stats":{"Line":30}},{"line":465,"address":[],"length":0,"stats":{"Line":6}},{"line":466,"address":[],"length":0,"stats":{"Line":6}},{"line":467,"address":[],"length":0,"stats":{"Line":6}},{"line":469,"address":[],"length":0,"stats":{"Line":18}},{"line":471,"address":[],"length":0,"stats":{"Line":24}},{"line":473,"address":[],"length":0,"stats":{"Line":15}},{"line":492,"address":[],"length":0,"stats":{"Line":67}},{"line":500,"address":[],"length":0,"stats":{"Line":234}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":86}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":58}},{"line":508,"address":[],"length":0,"stats":{"Line":139}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":5}},{"line":514,"address":[],"length":0,"stats":{"Line":81}},{"line":515,"address":[],"length":0,"stats":{"Line":119}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":19}},{"line":518,"address":[],"length":0,"stats":{"Line":19}},{"line":519,"address":[],"length":0,"stats":{"Line":19}},{"line":520,"address":[],"length":0,"stats":{"Line":19}},{"line":521,"address":[],"length":0,"stats":{"Line":57}},{"line":522,"address":[],"length":0,"stats":{"Line":19}},{"line":530,"address":[],"length":0,"stats":{"Line":62}},{"line":543,"address":[],"length":0,"stats":{"Line":191}},{"line":544,"address":[],"length":0,"stats":{"Line":191}},{"line":545,"address":[],"length":0,"stats":{"Line":60}},{"line":546,"address":[],"length":0,"stats":{"Line":1}},{"line":547,"address":[],"length":0,"stats":{"Line":130}},{"line":565,"address":[],"length":0,"stats":{"Line":67}},{"line":572,"address":[],"length":0,"stats":{"Line":67}},{"line":574,"address":[],"length":0,"stats":{"Line":67}},{"line":576,"address":[],"length":0,"stats":{"Line":67}},{"line":577,"address":[],"length":0,"stats":{"Line":67}},{"line":579,"address":[],"length":0,"stats":{"Line":67}},{"line":591,"address":[],"length":0,"stats":{"Line":98}},{"line":592,"address":[],"length":0,"stats":{"Line":98}},{"line":593,"address":[],"length":0,"stats":{"Line":98}},{"line":594,"address":[],"length":0,"stats":{"Line":98}},{"line":595,"address":[],"length":0,"stats":{"Line":98}},{"line":598,"address":[],"length":0,"stats":{"Line":5}},{"line":599,"address":[],"length":0,"stats":{"Line":21}},{"line":600,"address":[],"length":0,"stats":{"Line":21}},{"line":601,"address":[],"length":0,"stats":{"Line":21}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":21}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":21}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":63}},{"line":612,"address":[],"length":0,"stats":{"Line":127}},{"line":613,"address":[],"length":0,"stats":{"Line":64}},{"line":614,"address":[],"length":0,"stats":{"Line":64}},{"line":616,"address":[],"length":0,"stats":{"Line":64}},{"line":617,"address":[],"length":0,"stats":{"Line":192}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":9}},{"line":627,"address":[],"length":0,"stats":{"Line":9}},{"line":628,"address":[],"length":0,"stats":{"Line":9}},{"line":630,"address":[],"length":0,"stats":{"Line":17}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":14}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":646,"address":[],"length":0,"stats":{"Line":4}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":4}},{"line":650,"address":[],"length":0,"stats":{"Line":3}},{"line":651,"address":[],"length":0,"stats":{"Line":3}},{"line":653,"address":[],"length":0,"stats":{"Line":3}},{"line":654,"address":[],"length":0,"stats":{"Line":3}},{"line":656,"address":[],"length":0,"stats":{"Line":61}},{"line":674,"address":[],"length":0,"stats":{"Line":88}},{"line":681,"address":[],"length":0,"stats":{"Line":88}},{"line":683,"address":[],"length":0,"stats":{"Line":88}},{"line":684,"address":[],"length":0,"stats":{"Line":89}},{"line":685,"address":[],"length":0,"stats":{"Line":205}},{"line":686,"address":[],"length":0,"stats":{"Line":69}},{"line":687,"address":[],"length":0,"stats":{"Line":69}},{"line":688,"address":[],"length":0,"stats":{"Line":69}},{"line":692,"address":[],"length":0,"stats":{"Line":81}},{"line":693,"address":[],"length":0,"stats":{"Line":15}},{"line":694,"address":[],"length":0,"stats":{"Line":15}},{"line":695,"address":[],"length":0,"stats":{"Line":15}},{"line":696,"address":[],"length":0,"stats":{"Line":15}},{"line":698,"address":[],"length":0,"stats":{"Line":3}},{"line":699,"address":[],"length":0,"stats":{"Line":3}},{"line":700,"address":[],"length":0,"stats":{"Line":3}},{"line":702,"address":[],"length":0,"stats":{"Line":3}},{"line":703,"address":[],"length":0,"stats":{"Line":3}},{"line":706,"address":[],"length":0,"stats":{"Line":88}},{"line":720,"address":[],"length":0,"stats":{"Line":63}},{"line":721,"address":[],"length":0,"stats":{"Line":63}},{"line":722,"address":[],"length":0,"stats":{"Line":63}},{"line":723,"address":[],"length":0,"stats":{"Line":63}},{"line":725,"address":[],"length":0,"stats":{"Line":63}},{"line":727,"address":[],"length":0,"stats":{"Line":63}},{"line":728,"address":[],"length":0,"stats":{"Line":63}},{"line":730,"address":[],"length":0,"stats":{"Line":253}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":95}},{"line":737,"address":[],"length":0,"stats":{"Line":190}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":235}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":16}},{"line":744,"address":[],"length":0,"stats":{"Line":16}},{"line":745,"address":[],"length":0,"stats":{"Line":16}},{"line":746,"address":[],"length":0,"stats":{"Line":16}},{"line":747,"address":[],"length":0,"stats":{"Line":16}},{"line":751,"address":[],"length":0,"stats":{"Line":79}},{"line":752,"address":[],"length":0,"stats":{"Line":79}},{"line":753,"address":[],"length":0,"stats":{"Line":79}},{"line":757,"address":[],"length":0,"stats":{"Line":63}},{"line":758,"address":[],"length":0,"stats":{"Line":63}},{"line":782,"address":[],"length":0,"stats":{"Line":64}},{"line":789,"address":[],"length":0,"stats":{"Line":64}},{"line":793,"address":[],"length":0,"stats":{"Line":2}},{"line":794,"address":[],"length":0,"stats":{"Line":2}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":13}},{"line":804,"address":[],"length":0,"stats":{"Line":39}},{"line":805,"address":[],"length":0,"stats":{"Line":13}},{"line":806,"address":[],"length":0,"stats":{"Line":13}},{"line":807,"address":[],"length":0,"stats":{"Line":13}},{"line":808,"address":[],"length":0,"stats":{"Line":13}},{"line":811,"address":[],"length":0,"stats":{"Line":2}},{"line":812,"address":[],"length":0,"stats":{"Line":15}},{"line":813,"address":[],"length":0,"stats":{"Line":26}},{"line":814,"address":[],"length":0,"stats":{"Line":13}},{"line":815,"address":[],"length":0,"stats":{"Line":13}},{"line":816,"address":[],"length":0,"stats":{"Line":13}},{"line":817,"address":[],"length":0,"stats":{"Line":13}},{"line":818,"address":[],"length":0,"stats":{"Line":26}},{"line":819,"address":[],"length":0,"stats":{"Line":13}},{"line":820,"address":[],"length":0,"stats":{"Line":13}},{"line":821,"address":[],"length":0,"stats":{"Line":13}},{"line":822,"address":[],"length":0,"stats":{"Line":13}},{"line":823,"address":[],"length":0,"stats":{"Line":13}},{"line":825,"address":[],"length":0,"stats":{"Line":13}},{"line":826,"address":[],"length":0,"stats":{"Line":13}},{"line":827,"address":[],"length":0,"stats":{"Line":13}},{"line":828,"address":[],"length":0,"stats":{"Line":13}},{"line":829,"address":[],"length":0,"stats":{"Line":13}},{"line":833,"address":[],"length":0,"stats":{"Line":2}},{"line":834,"address":[],"length":0,"stats":{"Line":2}},{"line":837,"address":[],"length":0,"stats":{"Line":62}},{"line":838,"address":[],"length":0,"stats":{"Line":62}},{"line":839,"address":[],"length":0,"stats":{"Line":62}},{"line":840,"address":[],"length":0,"stats":{"Line":62}},{"line":841,"address":[],"length":0,"stats":{"Line":62}},{"line":842,"address":[],"length":0,"stats":{"Line":17}},{"line":844,"address":[],"length":0,"stats":{"Line":17}},{"line":845,"address":[],"length":0,"stats":{"Line":17}},{"line":846,"address":[],"length":0,"stats":{"Line":17}},{"line":847,"address":[],"length":0,"stats":{"Line":17}},{"line":848,"address":[],"length":0,"stats":{"Line":17}},{"line":849,"address":[],"length":0,"stats":{"Line":17}},{"line":850,"address":[],"length":0,"stats":{"Line":17}},{"line":851,"address":[],"length":0,"stats":{"Line":17}},{"line":853,"address":[],"length":0,"stats":{"Line":7}},{"line":854,"address":[],"length":0,"stats":{"Line":12}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":8}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":1}},{"line":864,"address":[],"length":0,"stats":{"Line":1}},{"line":865,"address":[],"length":0,"stats":{"Line":1}},{"line":867,"address":[],"length":0,"stats":{"Line":3}},{"line":868,"address":[],"length":0,"stats":{"Line":3}},{"line":869,"address":[],"length":0,"stats":{"Line":3}},{"line":871,"address":[],"length":0,"stats":{"Line":34}},{"line":874,"address":[],"length":0,"stats":{"Line":62}},{"line":875,"address":[],"length":0,"stats":{"Line":1}},{"line":876,"address":[],"length":0,"stats":{"Line":1}},{"line":879,"address":[],"length":0,"stats":{"Line":61}},{"line":880,"address":[],"length":0,"stats":{"Line":61}},{"line":881,"address":[],"length":0,"stats":{"Line":61}},{"line":882,"address":[],"length":0,"stats":{"Line":61}},{"line":884,"address":[],"length":0,"stats":{"Line":61}},{"line":885,"address":[],"length":0,"stats":{"Line":61}},{"line":887,"address":[],"length":0,"stats":{"Line":61}},{"line":889,"address":[],"length":0,"stats":{"Line":130}},{"line":890,"address":[],"length":0,"stats":{"Line":65}},{"line":892,"address":[],"length":0,"stats":{"Line":65}},{"line":894,"address":[],"length":0,"stats":{"Line":65}},{"line":896,"address":[],"length":0,"stats":{"Line":65}},{"line":897,"address":[],"length":0,"stats":{"Line":65}},{"line":898,"address":[],"length":0,"stats":{"Line":65}},{"line":901,"address":[],"length":0,"stats":{"Line":61}},{"line":917,"address":[],"length":0,"stats":{"Line":10}},{"line":918,"address":[],"length":0,"stats":{"Line":10}},{"line":919,"address":[],"length":0,"stats":{"Line":10}},{"line":920,"address":[],"length":0,"stats":{"Line":34}},{"line":921,"address":[],"length":0,"stats":{"Line":24}},{"line":923,"address":[],"length":0,"stats":{"Line":24}},{"line":938,"address":[],"length":0,"stats":{"Line":3}},{"line":939,"address":[],"length":0,"stats":{"Line":6}},{"line":940,"address":[],"length":0,"stats":{"Line":1}},{"line":942,"address":[],"length":0,"stats":{"Line":2}},{"line":945,"address":[],"length":0,"stats":{"Line":6}},{"line":946,"address":[],"length":0,"stats":{"Line":1}},{"line":948,"address":[],"length":0,"stats":{"Line":2}},{"line":951,"address":[],"length":0,"stats":{"Line":3}},{"line":952,"address":[],"length":0,"stats":{"Line":53}},{"line":953,"address":[],"length":0,"stats":{"Line":25}},{"line":955,"address":[],"length":0,"stats":{"Line":3}},{"line":956,"address":[],"length":0,"stats":{"Line":28}},{"line":957,"address":[],"length":0,"stats":{"Line":25}},{"line":958,"address":[],"length":0,"stats":{"Line":250}},{"line":959,"address":[],"length":0,"stats":{"Line":225}},{"line":960,"address":[],"length":0,"stats":{"Line":900}},{"line":961,"address":[],"length":0,"stats":{"Line":1}},{"line":962,"address":[],"length":0,"stats":{"Line":1}},{"line":964,"address":[],"length":0,"stats":{"Line":224}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":25}},{"line":999,"address":[],"length":0,"stats":{"Line":58}},{"line":1000,"address":[],"length":0,"stats":{"Line":58}},{"line":1001,"address":[],"length":0,"stats":{"Line":115}},{"line":1002,"address":[],"length":0,"stats":{"Line":3}},{"line":1005,"address":[],"length":0,"stats":{"Line":53}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":2}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":13}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":3}},{"line":1020,"address":[],"length":0,"stats":{"Line":1}},{"line":1022,"address":[],"length":0,"stats":{"Line":1}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":2}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":18}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":8}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":16}},{"line":1043,"address":[],"length":0,"stats":{"Line":15}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":2}},{"line":1046,"address":[],"length":0,"stats":{"Line":2}},{"line":1047,"address":[],"length":0,"stats":{"Line":2}},{"line":1048,"address":[],"length":0,"stats":{"Line":2}},{"line":1049,"address":[],"length":0,"stats":{"Line":2}},{"line":1050,"address":[],"length":0,"stats":{"Line":2}},{"line":1052,"address":[],"length":0,"stats":{"Line":2}},{"line":1053,"address":[],"length":0,"stats":{"Line":2}},{"line":1054,"address":[],"length":0,"stats":{"Line":1}},{"line":1055,"address":[],"length":0,"stats":{"Line":1}},{"line":1057,"address":[],"length":0,"stats":{"Line":1}},{"line":1058,"address":[],"length":0,"stats":{"Line":1}},{"line":1059,"address":[],"length":0,"stats":{"Line":1}},{"line":1060,"address":[],"length":0,"stats":{"Line":1}},{"line":1061,"address":[],"length":0,"stats":{"Line":1}},{"line":1062,"address":[],"length":0,"stats":{"Line":1}},{"line":1065,"address":[],"length":0,"stats":{"Line":1}},{"line":1067,"address":[],"length":0,"stats":{"Line":1}},{"line":1068,"address":[],"length":0,"stats":{"Line":1}},{"line":1071,"address":[],"length":0,"stats":{"Line":5}},{"line":1072,"address":[],"length":0,"stats":{"Line":5}},{"line":1073,"address":[],"length":0,"stats":{"Line":5}},{"line":1074,"address":[],"length":0,"stats":{"Line":5}},{"line":1075,"address":[],"length":0,"stats":{"Line":5}},{"line":1076,"address":[],"length":0,"stats":{"Line":5}},{"line":1079,"address":[],"length":0,"stats":{"Line":5}},{"line":1084,"address":[],"length":0,"stats":{"Line":3}},{"line":1088,"address":[],"length":0,"stats":{"Line":41}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":50}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":28}},{"line":1100,"address":[],"length":0,"stats":{"Line":28}},{"line":1101,"address":[],"length":0,"stats":{"Line":20}},{"line":1102,"address":[],"length":0,"stats":{"Line":20}},{"line":1103,"address":[],"length":0,"stats":{"Line":20}},{"line":1105,"address":[],"length":0,"stats":{"Line":8}},{"line":1106,"address":[],"length":0,"stats":{"Line":8}},{"line":1129,"address":[],"length":0,"stats":{"Line":39}},{"line":1130,"address":[],"length":0,"stats":{"Line":39}},{"line":1131,"address":[],"length":0,"stats":{"Line":64}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":24}},{"line":1137,"address":[],"length":0,"stats":{"Line":27}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1142,"address":[],"length":0,"stats":{"Line":22}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":24}},{"line":1149,"address":[],"length":0,"stats":{"Line":12}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1154,"address":[],"length":0,"stats":{"Line":36}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":24}},{"line":1160,"address":[],"length":0,"stats":{"Line":24}},{"line":1161,"address":[],"length":0,"stats":{"Line":24}},{"line":1162,"address":[],"length":0,"stats":{"Line":24}},{"line":1163,"address":[],"length":0,"stats":{"Line":24}},{"line":1164,"address":[],"length":0,"stats":{"Line":24}},{"line":1165,"address":[],"length":0,"stats":{"Line":24}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":14}}],"covered":406,"coverable":488},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","web.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse cop::app;\n\n/// Main entry point for the web application\n///\n/// This is the main function for the Rust spreadsheet web application.\n/// It initializes and runs the web server with the specified spreadsheet dimensions.\n///\n/// # Arguments\n/// * Command line arguments (not directly processed in this function)\n///\n/// # Default Configuration\n/// * Creates a spreadsheet with 10 rows and 10 columns by default\n///\n/// # Returns\n/// * `Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e` - Success or error object\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse command line arguments for rows and cols\n    // Currently using default values; command line parsing could be added here\n\n    let mut rows: i16 = 10;\n    let mut cols: i16 = 10;\n\n    // Start the web application with the specified dimensions\n    app::run(rows, cols).await\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>