<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","actix-spreadsheet","src","models","mod.rs"],"content":"// filepath: /actix-spreadsheet/actix-spreadsheet/src/models/mod.rs\npub mod session;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","app.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse axum::{\n    Form, Json, Router,\n    body::Bytes,\n    extract::{Multipart, Path, Query, State},\n    http::{StatusCode, header},\n    middleware,\n    response::{Html, IntoResponse, Redirect, Response},\n    routing::{get, post},\n};\nuse axum_extra::extract::cookie::CookieJar;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::sync::{Arc, Mutex};\nuse tokio::net::TcpListener;\nuse tower_http::services::ServeDir;\n\nuse crate::downloader;\nuse crate::graph::{GraphOptions, GraphType, create_graph};\nuse crate::login::{self, User, UserCredentials};\nuse crate::saving;\nuse crate::spreadsheet::{FunctionName, Operand, ParsedRHS, Spreadsheet};\n\npub struct AppState {\n    sheet: Mutex\u003cBox\u003cSpreadsheet\u003e\u003e,\n    original_path: Mutex\u003cOption\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CellUpdate {\n    rhs: String,\n    cell: String,\n}\n\n#[derive(Serialize)]\nstruct CellResponse {\n    status: String,\n    value: Option\u003ci32\u003e,\n}\n\n#[derive(Deserialize)]\nstruct SaveQuery {\n    filename: String,\n}\n\n#[derive(Deserialize)]\nstruct SheetQuery {\n    rows: Option\u003ci32\u003e,\n    cols: Option\u003ci32\u003e,\n}\n\n#[derive(Serialize)]\nstruct SaveResponse {\n    status: String,\n    message: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct FileNameQuery {\n    name: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct GraphRequest {\n    x_range: String,\n    y_range: String,\n    title: String,\n    x_label: String,\n    y_label: String,\n    graph_type: String,\n}\n\npub async fn run(rows: i16, cols: i16) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Initialize the database\n    login::init_database()?;\n\n    // Create spreadsheet\n    let sheet = Spreadsheet::spreadsheet_create(rows, cols).expect(\"Failed to create spreadsheet\");\n\n    // Setup app state\n    let app_state = Arc::new(AppState {\n        sheet: Mutex::new(sheet),\n        original_path: Mutex::new(None),\n    });\n\n    // 1) Build the public (no‐auth) routes\n    let public = Router::new()\n        .route(\"/\", get(serve_landing))\n        .route(\n            \"/login\",\n            get(login::serve_login_page).post(login::handle_login),\n        )\n        .route(\n            \"/signup\",\n            get(login::serve_signup_page).post(login::handle_signup),\n        )\n        .route(\"/logout\", get(login::handle_logout))\n        .nest_service(\"/static\", ServeDir::new(\"static\"));\n\n    // 2) Build the protected routes and apply auth‐middleware\n    let protected = Router::new()\n        // spreadsheet endpoints\n        .route(\"/sheet\", get(serve_sheet))\n        .route(\"/api/sheet\", get(get_sheet_data))\n        .route(\"/api/cell/:cell_name\", get(get_cell))\n        .route(\"/api/update_cell\", post(update_cell))\n        .route(\"/api/save\", post(save_spreadsheet))\n        .route(\"/api/export\", post(export_spreadsheet))\n        .route(\"/api/load\", post(load_spreadsheet))\n        .route(\"/api/graph\", post(generate_graph))\n        .route(\"/api/download/csv\", get(download_csv))\n        .route(\"/api/download/xlsx\", get(download_xlsx))\n        .route(\"/api/sheet_info\", get(get_sheet_info))\n        .route(\"/api/save_with_name\", post(save_spreadsheet_with_name))\n        // user file routes\n        .route(\"/:username\", get(login::list_files))\n        .route(\"/:username/:filename\", get(load_user_file))\n        // only these get require_auth\n        .layer(middleware::from_fn(login::require_auth));\n\n    // 3) Merge and attach shared state\n    let app = Router::new()\n        .merge(public)\n        .merge(protected)\n        .with_state(app_state);\n\n    // Start server\n    let listener = TcpListener::bind(\"127.0.0.1:3000\").await?;\n    println!(\"Listening on http://127.0.0.1:3000\");\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n\nasync fn generate_graph(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(payload): Json\u003cGraphRequest\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    let graph_type = match payload.graph_type.as_str() {\n        \"Line\" =\u003e GraphType::Line,\n        \"Bar\" =\u003e GraphType::Bar,\n        \"Scatter\" =\u003e GraphType::Scatter,\n        \"Area\" =\u003e GraphType::Area,\n        _ =\u003e GraphType::Line,\n    };\n\n    let options = GraphOptions {\n        title: payload.title,\n        x_label: payload.x_label,\n        y_label: payload.y_label,\n        width: 800,\n        height: 600,\n        graph_type,\n    };\n\n    match create_graph(\u0026sheet, \u0026payload.x_range, \u0026payload.y_range, options) {\n        Ok(img_data) =\u003e ([(\"Content-Type\", \"image/png\")], img_data).into_response(),\n        Err(e) =\u003e (\n            StatusCode::BAD_REQUEST,\n            format!(\"Failed to create graph: {}\", e),\n        )\n            .into_response(),\n    }\n}\n\nasync fn serve_landing() -\u003e impl IntoResponse {\n    // Redirect to login page\n    Redirect::to(\"/login\")\n}\n\nasync fn serve_sheet(\n    Query(params): Query\u003cSheetQuery\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e Html\u003c\u0026'static str\u003e {\n    if let (Some(rows), Some(cols)) = (params.rows, params.cols) {\n        if rows \u003e 0 \u0026\u0026 rows \u003c= 1000 \u0026\u0026 cols \u003e 0 \u0026\u0026 cols \u003c= 18278 {\n            let new_sheet = Spreadsheet::spreadsheet_create(rows as i16, cols as i16)\n                .expect(\"Failed to create spreadsheet with specified dimensions\");\n\n            let mut current_sheet = state.sheet.lock().unwrap();\n            *current_sheet = new_sheet;\n        }\n    }\n\n    Html(include_str!(\"./static/sheet.html\"))\n}\n\nasync fn get_sheet_data(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n    let rows = sheet.rows;\n    let cols = sheet.cols;\n\n    let mut cell_data = Vec::new();\n\n    for r in 1..=rows {\n        for c in 1..=cols {\n            let index = ((r - 1) * cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                cell_data.push(serde_json::json!({\n                    \"row\": r,\n                    \"col\": c,\n                    \"name\": Spreadsheet::get_cell_name(r, c),\n                    \"value\": cell.value,\n                    \"formula\": formula_to_string(\u0026cell.formula),  // Convert to string\n                    \"error\": cell.error,\n                }));\n            }\n        }\n    }\n\n    Json(serde_json::json!({\n        \"rows\": rows,\n        \"cols\": cols,\n        \"cells\": cell_data,\n    }))\n}\n\nasync fn get_cell(\n    Path(cell_name): Path\u003cString\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026cell_name) {\n        let index = ((row - 1) * sheet.cols + (col - 1)) as usize;\n        if let Some(cell) = \u0026sheet.cells[index] {\n            return Json(serde_json::json!({\n                \"name\": cell_name,\n                \"value\": cell.value,\n                \"formula\": formula_to_string(\u0026cell.formula),  // Convert to string\n                \"error\": cell.error,\n            }))\n            .into_response();\n        }\n    }\n\n    StatusCode::NOT_FOUND.into_response()\n}\n\nasync fn update_cell(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(payload): Json\u003cCellUpdate\u003e,\n) -\u003e impl IntoResponse {\n    println!(\"(DEBUG) Received update_cell payload: {:?}\", payload);\n    let mut sheet = state.sheet.lock().unwrap();\n    let mut status = String::new();\n\n    // Parse the cell name\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026payload.cell) {\n        println!(\"(DEBUG) Parsed cell name: row={}, col={}\", row, col);\n\n        // Parse the formula string into ParsedRHS using is_valid_command\n        let (is_valid, _, _, parsed_rhs) = sheet.is_valid_command(\u0026payload.cell, \u0026payload.rhs);\n\n        if is_valid {\n            println!(\"(DEBUG) Valid formula parsed: {:?}\", parsed_rhs);\n            sheet.spreadsheet_set_cell_value(row, col, parsed_rhs, \u0026mut status);\n        } else {\n            status = format!(\"Invalid formula: {}\", payload.rhs);\n            println!(\"(DEBUG) {}\", status);\n        }\n    } else {\n        status = format!(\"Invalid cell identifier: {}\", payload.cell);\n        println!(\"(DEBUG) {}\", status);\n    }\n\n    // Retrieve the updated cell value and print its state\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(\u0026payload.cell) {\n        let index = ((row - 1) * sheet.cols + (col - 1)) as usize;\n        if let Some(cell) = \u0026sheet.cells[index] {\n            println!(\n                \"(DEBUG) Final state of cell {}: value = {}, formula = {:?}, error = {}\",\n                payload.cell, cell.value, cell.formula, cell.error\n            );\n            Json(CellResponse {\n                status,\n                value: Some(cell.value),\n            })\n            .into_response()\n        } else {\n            println!(\"(DEBUG) Missing cell at index {}\", index);\n            Json(CellResponse {\n                status: \"Cell not found\".into(),\n                value: None,\n            })\n            .into_response()\n        }\n    } else {\n        println!(\n            \"(DEBUG) Second parsing of cell identifier failed for '{}'\",\n            payload.cell\n        );\n        Json(CellResponse {\n            status,\n            value: None,\n        })\n        .into_response()\n    }\n}\n\nasync fn save_spreadsheet(\n    Query(params): Query\u003cSaveQuery\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e impl IntoResponse {\n    // Get the sheet and original path\n    let sheet = state.sheet.lock().unwrap();\n    let mut original_path = state.original_path.lock().unwrap();\n\n    // Get filename from query params or use original path if none provided\n    let filename = if params.filename.is_empty() {\n        // Try to use the original path\n        match original_path.as_ref() {\n            Some(path) =\u003e path.clone(),\n            None =\u003e {\n                return Json(SaveResponse {\n                    status: \"error\".to_string(),\n                    message: Some(\n                        \"No filename provided and no original path available\".to_string(),\n                    ),\n                })\n                .into_response();\n            }\n        }\n    } else {\n        // For new sheets, update the original path with the provided filename\n        let new_filename = params.filename.clone();\n        *original_path = Some(new_filename.clone());\n        new_filename\n    };\n\n    match saving::save_spreadsheet(\u0026sheet, \u0026filename) {\n        Ok(_) =\u003e Json(SaveResponse {\n            status: \"ok\".to_string(),\n            message: None,\n        })\n        .into_response(),\n        Err(e) =\u003e {\n            // If save fails, don't keep the path for new sheets\n            if original_path.as_ref().unwrap() == \u0026filename \u0026\u0026 params.filename == filename {\n                *original_path = None;\n            }\n\n            Json(SaveResponse {\n                status: \"error\".to_string(),\n                message: Some(e.to_string()),\n            })\n            .into_response()\n        }\n    }\n}\n\n// Modified save function to save to user directory\nasync fn save_spreadsheet_with_name(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    username: axum::extract::Extension\u003cString\u003e,\n    Form(query): Form\u003cFileNameQuery\u003e,\n) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    // Create user directory if it doesn't exist\n    let user_dir = format!(\"database/{}\", username.0);\n    let _ = std::fs::create_dir_all(\u0026user_dir);\n\n    // Build the filename\n    let filename = if query.name.trim().is_empty() {\n        \"spreadsheet.bin.gz\".to_string()\n    } else {\n        if !query.name.ends_with(\".bin.gz\") {\n            format!(\"{}.bin.gz\", query.name)\n        } else {\n            query.name\n        }\n    };\n\n    let path = format!(\"{}/{}\", user_dir, filename);\n\n    // Update original path\n    let mut original_path = state.original_path.lock().unwrap();\n    *original_path = Some(path.clone());\n\n    // Save the file\n    match saving::save_spreadsheet(\u0026sheet, \u0026path) {\n        Ok(_) =\u003e Json(SaveResponse {\n            status: \"ok\".to_string(),\n            message: None,\n        })\n        .into_response(),\n        Err(e) =\u003e {\n            *original_path = None;\n            Json(SaveResponse {\n                status: \"error\".to_string(),\n                message: Some(e.to_string()),\n            })\n            .into_response()\n        }\n    }\n}\n\n// Load user file by path\nasync fn load_user_file(\n    axum::extract::Path((username, filename)): axum::extract::Path\u003c(String, String)\u003e,\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    current_user: axum::extract::Extension\u003cString\u003e,\n) -\u003e impl IntoResponse {\n    // Security check - users can only load their own files\n    if username != current_user.0 {\n        return Redirect::to(\"/login\").into_response();\n    }\n\n    let path = format!(\"database/{}/{}\", username, filename);\n\n    // Check if file exists\n    if !std::path::Path::new(\u0026path).exists() {\n        return Html(\"\u003ch1\u003eFile not found\u003c/h1\u003e\".to_string()).into_response();\n    }\n\n    // Load the file\n    match std::fs::read(\u0026path) {\n        Ok(file_data) =\u003e {\n            match deserialize_from_memory(\u0026file_data) {\n                Ok(loaded_sheet) =\u003e {\n                    {\n                        let mut sheet_guard = state.sheet.lock().unwrap();\n                        *sheet_guard = loaded_sheet;\n\n                        // Update original path\n                        let mut path_guard = state.original_path.lock().unwrap();\n                        *path_guard = Some(path);\n                    } // Release locks before calling serve_sheet\n\n                    // Clone the Arc to avoid ownership issues:\n                    serve_sheet(\n                        Query(SheetQuery {\n                            rows: None,\n                            cols: None,\n                        }),\n                        State(Arc::clone(\u0026state)),\n                    )\n                    .await\n                    .into_response()\n                }\n                Err(_) =\u003e Html(\"\u003ch1\u003eError loading spreadsheet\u003c/h1\u003e\".to_string()).into_response(),\n            }\n        }\n        Err(_) =\u003e Html(\"\u003ch1\u003eError reading file\u003c/h1\u003e\".to_string()).into_response(),\n    }\n}\n\nasync fn export_spreadsheet(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    // Prepare a memory buffer to receive the serialized data\n    let mut buffer = Vec::new();\n\n    // Try to serialize the spreadsheet to the buffer\n    match serialize_to_memory(\u0026sheet, \u0026mut buffer) {\n        Ok(_) =\u003e {\n            // Return the serialized data as a downloadable file\n            Response::builder()\n                .status(StatusCode::OK)\n                .header(header::CONTENT_TYPE, \"application/gzip\")\n                .body(axum::body::Body::from(Bytes::from(buffer)))\n                .unwrap()\n        }\n        Err(e) =\u003e {\n            // Return error response\n            Response::builder()\n                .status(StatusCode::INTERNAL_SERVER_ERROR)\n                .header(header::CONTENT_TYPE, \"application/json\")\n                .body(axum::body::Body::from(\n                    serde_json::to_string(\u0026SaveResponse {\n                        status: \"error\".to_string(),\n                        message: Some(e.to_string()),\n                    })\n                    .unwrap(),\n                ))\n                .unwrap()\n        }\n    }\n}\n\nasync fn load_spreadsheet(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    mut multipart: Multipart,\n) -\u003e impl IntoResponse {\n    // Process the multipart form data\n    let mut file_data = Vec::new();\n    let _field_name = String::new();\n    let mut file_path = None;\n\n    while let Some(field) = multipart.next_field().await.unwrap_or(None) {\n        let field_name = field.name().unwrap_or(\"unknown\").to_string();\n\n        if field_name == \"spreadsheet\" {\n            // First get the filename before consuming the field with bytes()\n            file_path = field.file_name().map(|s| s.to_string());\n\n            // Now get the bytes (this consumes the field)\n            file_data = field.bytes().await.unwrap_or_default().to_vec();\n        }\n    }\n\n    if file_data.is_empty() {\n        return Json(SaveResponse {\n            status: \"error\".to_string(),\n            message: Some(\"No file data received\".to_string()),\n        })\n        .into_response();\n    }\n\n    // Try to deserialize the spreadsheet\n    match deserialize_from_memory(\u0026file_data) {\n        Ok(loaded_sheet) =\u003e {\n            // Update the application's spreadsheet\n            let mut sheet = state.sheet.lock().unwrap();\n            *sheet = loaded_sheet;\n\n            // Store the original file path\n            if let Some(path) = file_path {\n                let mut original_path = state.original_path.lock().unwrap();\n                *original_path = Some(path);\n            }\n\n            Json(SaveResponse {\n                status: \"ok\".to_string(),\n                message: None,\n            })\n            .into_response()\n        }\n        Err(e) =\u003e Json(SaveResponse {\n            status: \"error\".to_string(),\n            message: Some(format!(\"Failed to load spreadsheet: {}\", e)),\n        })\n        .into_response(),\n    }\n}\n\nasync fn download_csv(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    match downloader::to_csv(\u0026sheet) {\n        Ok(csv_content) =\u003e Response::builder()\n            .status(StatusCode::OK)\n            .header(header::CONTENT_TYPE, \"text/csv\")\n            .header(\n                header::CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"spreadsheet.csv\\\"\",\n            )\n            .body(axum::body::Body::from(csv_content))\n            .unwrap(),\n        Err(e) =\u003e Response::builder()\n            .status(StatusCode::INTERNAL_SERVER_ERROR)\n            .header(header::CONTENT_TYPE, \"text/plain\")\n            .body(axum::body::Body::from(format!(\n                \"Error generating CSV: {}\",\n                e\n            )))\n            .unwrap(),\n    }\n}\n\nasync fn download_xlsx(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let sheet = state.sheet.lock().unwrap();\n\n    match downloader::to_xlsx(\u0026sheet) {\n        Ok(xlsx_data) =\u003e Response::builder()\n            .status(StatusCode::OK)\n            .header(\n                header::CONTENT_TYPE,\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            )\n            .header(\n                header::CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"spreadsheet.xlsx\\\"\",\n            )\n            .body(axum::body::Body::from(Bytes::from(xlsx_data)))\n            .unwrap(),\n        Err(e) =\u003e Response::builder()\n            .status(StatusCode::INTERNAL_SERVER_ERROR)\n            .header(header::CONTENT_TYPE, \"text/plain\")\n            .body(axum::body::Body::from(format!(\n                \"Error generating XLSX: {}\",\n                e\n            )))\n            .unwrap(),\n    }\n}\n\n// Helper function to serialize a spreadsheet to a memory buffer\nfn serialize_to_memory(spreadsheet: \u0026Spreadsheet, buffer: \u0026mut Vec\u003cu8\u003e) -\u003e std::io::Result\u003c()\u003e {\n    use bincode::serialize_into;\n    use flate2::Compression;\n    use flate2::write::GzEncoder;\n\n    let encoder = GzEncoder::new(buffer, Compression::default());\n    let mut writer = std::io::BufWriter::new(encoder);\n\n    serialize_into(\u0026mut writer, spreadsheet)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;\n\n    Ok(())\n}\n\n// Helper function to deserialize a spreadsheet from a memory buffer\nfn deserialize_from_memory(buffer: \u0026[u8]) -\u003e std::io::Result\u003cBox\u003cSpreadsheet\u003e\u003e {\n    use bincode::deserialize_from;\n    use flate2::read::GzDecoder;\n    use std::io::Cursor;\n\n    let cursor = Cursor::new(buffer);\n    let decoder = GzDecoder::new(cursor);\n    let mut reader = std::io::BufReader::new(decoder);\n\n    let spreadsheet: Spreadsheet = deserialize_from(\u0026mut reader)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n    Ok(Box::new(spreadsheet))\n}\n\n// Add this function to convert ParsedRHS to a display string\nfn formula_to_string(formula: \u0026ParsedRHS) -\u003e String {\n    match formula {\n        ParsedRHS::Function {\n            name,\n            args: (arg1, arg2),\n        } =\u003e {\n            let func_name = match name {\n                FunctionName::Min =\u003e \"MIN\",\n                FunctionName::Max =\u003e \"MAX\",\n                FunctionName::Avg =\u003e \"AVG\",\n                FunctionName::Sum =\u003e \"SUM\",\n                FunctionName::Stdev =\u003e \"STDEV\",\n                FunctionName::Cut =\u003e \"CUT\",\n                FunctionName::Copy =\u003e \"COPY\",\n            };\n\n            let cell1 = match arg1 {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            let cell2 = match arg2 {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"{}({}:{})\", func_name, cell1, cell2)\n        }\n        ParsedRHS::Arithmetic { lhs, operator, rhs } =\u003e {\n            let left = match lhs {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            let right = match rhs {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"{}{}{}\", left, operator, right)\n        }\n        ParsedRHS::Sleep(operand) =\u003e {\n            let value = match operand {\n                Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n                Operand::Number(n) =\u003e n.to_string(),\n            };\n\n            format!(\"SLEEP({})\", value)\n        }\n        ParsedRHS::SingleValue(operand) =\u003e match operand {\n            Operand::Cell(row, col) =\u003e Spreadsheet::get_cell_name(*row, *col),\n            Operand::Number(n) =\u003e n.to_string(),\n        },\n        ParsedRHS::None =\u003e String::new(),\n    }\n}\n\nasync fn get_sheet_info(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\n    let original_path = state.original_path.lock().unwrap();\n\n    Json(serde_json::json!({\n        \"is_loaded\": original_path.is_some(),\n        \"original_path\": original_path.clone().unwrap_or_default(),\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","cell_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\n#[cfg(test)]\nmod cell_tests {\n    use cop::cell::{Cell, Dependents, cell_create, cell_dep_insert, cell_dep_remove};\n\n    fn cell_contains(cell: \u0026Cell, row: i16, col: i16) -\u003e bool {\n        cell.contains(row, col)\n    }\n\n    #[test]\n    fn test_basic_cell_creation() {\n        let cell = cell_create(1, 1);\n        assert_eq!(cell.row, 1);\n        assert_eq!(cell.col, 1);\n        assert_eq!(cell.value, 0);\n        assert!(!cell.error);\n        assert!(matches!(cell.formula, cop::spreadsheet::ParsedRHS::None));\n        assert_eq!(cell.dependents_initialised, 0);\n        assert!(matches!(cell.dependents, Dependents::None));\n    }\n\n    #[test]\n    fn test_cell_value_modification() {\n        let mut cell = cell_create(1, 1);\n        cell.value = 100;\n        assert_eq!(cell.value, 100);\n    }\n\n    #[test]\n    fn test_cell_formula_assignment() {\n        use cop::spreadsheet::{Operand, ParsedRHS};\n\n        let mut cell = cell_create(1, 1);\n        cell.formula = ParsedRHS::SingleValue(Operand::Number(42));\n\n        assert!(matches!(cell.formula, ParsedRHS::SingleValue(_)));\n\n        if let ParsedRHS::SingleValue(Operand::Number(value)) = cell.formula {\n            assert_eq!(value, 42);\n        } else {\n            panic!(\"Expected ParsedRHS::SingleValue(Operand::Number)\");\n        }\n    }\n\n    #[test]\n    fn test_error_flag() {\n        let mut cell = cell_create(1, 1);\n        cell.error = true;\n        assert!(cell.error);\n    }\n\n    #[test]\n    fn test_managing_dependents() {\n        let mut cell = cell_create(1, 1);\n\n        cell_dep_insert(\u0026mut cell, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell, 3, 2); // C2\n        cell_dep_insert(\u0026mut cell, 4, 3); // D3\n\n        assert!(cell_contains(\u0026cell, 2, 1));\n        assert!(cell_contains(\u0026cell, 3, 2));\n        assert!(cell_contains(\u0026cell, 4, 3));\n        assert!(!cell_contains(\u0026cell, 5, 4)); // E4 not added\n\n        // Add more dependents such that it becomes set\n        for i in 5..=10 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n        // Ensure all dependencies are still accessible\n        for i in 5..=10 {\n            assert!(cell_contains(\u0026cell, i, i));\n        }\n    }\n\n    #[test]\n    fn test_removing_dependents() {\n        let mut cell = cell_create(1, 1);\n\n        cell_dep_insert(\u0026mut cell, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell, 3, 2); // C2\n\n        assert!(cell_contains(\u0026cell, 3, 2));\n\n        cell_dep_remove(\u0026mut cell, 3, 2);\n        assert!(!cell_contains(\u0026cell, 3, 2));\n        assert!(cell_contains(\u0026cell, 2, 1)); // B1 should still be there\n\n        // Add more cells , such that it converts to set\n        for i in 4..=11 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n\n        // remove some dependents\n        cell_dep_remove(\u0026mut cell, 4, 4);\n        cell_dep_remove(\u0026mut cell, 5, 5);\n        cell_dep_remove(\u0026mut cell, 6, 6);\n\n        // check \n        assert!(!cell_contains(\u0026cell, 4, 4));\n        assert!(!cell_contains(\u0026cell, 5, 5));\n        assert!(!cell_contains(\u0026cell, 6, 6));\n        assert!(cell_contains(\u0026cell, 7, 7));\n        assert!(cell_contains(\u0026cell, 8, 8));\n        assert!(cell_contains(\u0026cell, 9, 9));\n        assert!(cell_contains(\u0026cell, 10, 10));\n        assert!(cell_contains(\u0026cell, 11, 11));\n    }\n\n    #[test]\n    fn test_creating_multiple_cells() {\n        let mut cell1 = cell_create(1, 1);\n        let mut cell2 = cell_create(2, 3);\n\n        assert_eq!(cell1.row, 1);\n        assert_eq!(cell1.col, 1);\n        assert_eq!(cell2.row, 2);\n        assert_eq!(cell2.col, 3);\n\n        cell_dep_insert(\u0026mut cell1, 2, 1); // B1\n        cell_dep_insert(\u0026mut cell2, 1, 1); // A1\n        cell_dep_insert(\u0026mut cell2, 10, 24); // X10\n\n        // Verify each cell has its own dependencies\n        assert!(cell_contains(\u0026cell1, 2, 1));\n        assert!(!cell_contains(\u0026cell2, 2, 1));\n        assert!(!cell_contains(\u0026cell1, 1, 1));\n        assert!(cell_contains(\u0026cell2, 1, 1));\n        assert!(cell_contains(\u0026cell2, 10, 24));\n    }\n\n    #[test]\n    fn test_dependent_conversion() {\n        let mut cell = cell_create(1, 1);\n\n        // Add 9 dependencies to trigger conversion from Vector to Set\n        for i in 1..=9 {\n            cell_dep_insert(\u0026mut cell, i, i);\n        }\n\n        // Check that Set was created by verifying format\n        match \u0026cell.dependents {\n            Dependents::Vector(_) =\u003e panic!(\"Should have converted to Set\"),\n            Dependents::Set(_) =\u003e assert!(true), // This is expected\n            Dependents::None =\u003e panic!(\"Should not be None\"),\n        }\n\n        // Ensure all dependencies are still accessible\n        for i in 1..=9 {\n            assert!(cell_contains(\u0026cell, i, i));\n        }\n\n        // Add one more and check it works\n        cell_dep_insert(\u0026mut cell, 10, 10);\n        assert!(cell_contains(\u0026cell, 10, 10));\n\n        // Remove one and check it works\n        cell_dep_remove(\u0026mut cell, 5, 5);\n        assert!(!cell_contains(\u0026cell, 5, 5));\n        assert!(cell_contains(\u0026cell, 6, 6));\n    }\n}\n\nfn main() {\n    // When run directly, this will run the tests\n    println!(\"=== Cell Test Suite ===\");\n    println!(\"Run with 'cargo test' to execute tests\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","cli.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse cop::spreadsheet::Spreadsheet;\n\n// use crate::spreadsheet::{Spreadsheet, Spreadsheet as SpreadsheetTrait};\nuse std::env;\nuse std::io::{self, Write};\n// use std::os::macos::raw::stat;\nuse std::time::Instant;\n\n// #[tokio::main]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let s = Instant::now(); // Start time for the entire program\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    // if args.len() \u003e 1 \u0026\u0026 args[1] == \"-dassi_nahi_to_rassi\" {\n    //     // Run the web application\n    //     let mut rows = 10;\n    //     let mut cols = 10;\n\n    //     if args.len() \u003e= 4 {\n    //         rows = args[2].parse().unwrap_or(10);\n    //         cols = args[3].parse().unwrap_or(10);\n    //     }\n\n    //     app::run(rows, cols).await?;\n    // } else {\n    // Run the spreadsheet functionality\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003crows\u003e \u003ccols\u003e\", args[0]);\n        return Ok(());\n    }\n\n    let rows: i32 = args[1].parse().unwrap_or(0);\n    let cols: i32 = args[2].parse().unwrap_or(0);\n\n    if !(1..=999).contains(\u0026rows) || !(1..=18278).contains(\u0026cols) {\n        eprintln!(\"Error: Invalid dimensions\");\n        return Ok(());\n    }\n\n    let mut start_time = Instant::now(); // Start time for the first command\n    let mut sheet = Spreadsheet::spreadsheet_create(rows as i16, cols as i16).unwrap();\n    let mut elapsed_time;\n    let mut status = String::from(\"ok\");\n    let mut show = true;\n    loop {\n        if show {\n            sheet.spreadsheet_display();\n        }\n\n        elapsed_time = start_time.elapsed().as_secs_f64(); // Calculate time since the last command\n        print!(\"[{:.1}] ({}) \u003e \", elapsed_time, status);\n        io::stdout().flush().unwrap();\n\n        let mut command = String::new();\n        if io::stdin().read_line(\u0026mut command).is_err() {\n            break;\n        }\n        let command = command.trim();\n\n        start_time = Instant::now(); // Reset the start time for the next command\n\n        if command.is_empty() {\n            status = String::from(\"invalid command\");\n            continue;\n        }\n\n        if command == \"help\" {\n            println!(\"Commands:\");\n            println!(\"  q: Quit\");\n            println!(\"  w: Move up\");\n            println!(\"  s: Move down\");\n            println!(\"  a: Move left\");\n            println!(\"  d: Move right\");\n            println!(\"  disable_output: Disable output display\");\n            println!(\"  enable_output: Enable output display\");\n            println!(\"  scroll_to \u003ccell\u003e: Scroll to the specified cell\");\n            println!(\"  \u003ccell\u003e=\u003cformula\u003e: Set the formula for the specified cell\");\n            continue;\n        }\n\n        if command == \"q\" {\n            break;\n        } else if command.len() == 1 \u0026\u0026 \"wasd\".contains(command) {\n            match command {\n                \"w\" if sheet.view_row \u003e 0 =\u003e {\n                    sheet.view_row = (sheet.view_row - 10).max(0);\n                }\n                \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                    sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n                }\n                \"a\" if sheet.view_col \u003e 0 =\u003e {\n                    sheet.view_col = (sheet.view_col - 10).max(0);\n                }\n                \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                    sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n                }\n                _ =\u003e {}\n            }\n            status = String::from(\"ok\");\n        } else if command == \"disable_output\" {\n            show = false;\n            status = String::from(\"ok\");\n        } else if command == \"enable_output\" {\n            show = true;\n            status = String::from(\"ok\");\n        } else if command.starts_with(\"scroll_to\") {\n            let cell_name = command[10..].trim();\n            if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n                sheet.view_row = row - 1;\n                sheet.view_col = col - 1;\n                status = String::from(\"ok\");\n            } else {\n                status = String::from(\"invalid cell\");\n            }\n        } else if let Some(equal_pos) = command.find('=') {\n            sheet.undo_stack.clear();\n            let cell_name = \u0026command[..equal_pos];\n            let formula = \u0026command[equal_pos + 1..];\n            let (valid, row, col, rhs) = sheet.is_valid_command(cell_name, formula);\n            if !valid {\n                status = String::from(\"invalid command\");\n            } else {\n                sheet.spreadsheet_set_cell_value(row, col, rhs, \u0026mut status);\n            }\n        } else if command == \"UNDO\" {\n            if sheet.undo_stack.is_empty() {\n                status = String::from(\"no undo\");\n            } else {\n                sheet.spreadsheet_undo(\u0026mut status);\n            }\n        // } else if command == \"REDO\" {\n        //     if sheet.redo_stack.is_empty() {\n        //         status = String::from(\"no redo\");\n        //     } else {\n        //         sheet.spreadsheet_redo();\n        //         status = String::from(\"ok\");\n        //     }\n        } else {\n            status = String::from(\"invalid command 3\");\n        }\n\n        // Update the start_time after processing the command\n        // start_time = Instant::now();\n    }\n    // }\n    let e = s.elapsed().as_secs_f64(); // Calculate total elapsed time\n    println!(\"Total elapsed time: {:.1} seconds\", e);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","graph_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Generate example graphs from the library - now returns file paths\n    let graphs = cop::graph::create_example_graphs();\n\n    for (name, file_path) in graphs {\n        println!(\"Created {} graph at {}\", name, file_path);\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","scroll_test.rs"],"content":"#![cfg(not(tarpaulin_include))]\nuse cop::spreadsheet::Spreadsheet;\nuse std::io::{self, Write};\n\nfn execute_command(sheet: \u0026mut Box\u003cSpreadsheet\u003e, cmd: \u0026str, status: \u0026mut String) {\n    if cmd.len() == 1 \u0026\u0026 \"wasd\".contains(cmd) {\n        match cmd {\n            \"w\" if sheet.view_row \u003e 0 =\u003e {\n                sheet.view_row = (sheet.view_row - 10).max(0);\n            }\n            \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n            }\n            \"a\" if sheet.view_col \u003e 0 =\u003e {\n                sheet.view_col = (sheet.view_col - 10).max(0);\n            }\n            \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n            }\n            _ =\u003e {}\n        }\n        *status = \"ok\".to_string();\n    } else if cmd.starts_with(\"scroll_to\") {\n        let cell_name = \u0026cmd[10..];\n        if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n            sheet.view_row = row - 1;\n            sheet.view_col = col - 1;\n            *status = \"ok\".to_string();\n        } else {\n            *status = \"invalid cell\".to_string();\n        }\n    } else {\n        *status = \"invalid command\".to_string();\n    }\n}\n\nfn set_cell(sheet: \u0026mut Box\u003cSpreadsheet\u003e, cell_name: \u0026str, formula: \u0026str) {\n    let mut status = String::new();\n\n    if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n        let (valid, _, _, rhs) = sheet.is_valid_command(cell_name, formula);\n        if valid {\n            sheet.spreadsheet_set_cell_value(row, col, rhs, \u0026mut status);\n        }\n    }\n}\n\nfn main() {\n    println!(\"Starting interactive scroll test\");\n\n    // Create a 25x25 spreadsheet\n    let mut sheet = Spreadsheet::spreadsheet_create(25, 25).unwrap();\n\n    // Fill the spreadsheet with values for easy visual testing\n    println!(\"Filling spreadsheet with test data...\");\n    for i in 1..=25 {\n        for j in 1..=25 {\n            let cell_name = Spreadsheet::get_cell_name(i, j);\n            let formula = format!(\"{}\", i * 100 + j); // Value will be row*100+col\n            set_cell(\u0026mut sheet, \u0026cell_name, \u0026formula);\n        }\n    }\n\n    let mut status = \"ok\".to_string();\n\n    println!(\"\\n=== SCROLL TEST INTERACTIVE SIMULATION ===\");\n    println!(\"Initial view (top-left corner):\");\n    sheet.spreadsheet_display();\n\n    // Test a series of commands\n    let commands = [\n        \"s\",             // scroll down\n        \"d\",             // scroll right\n        \"s\",             // scroll down more\n        \"scroll_to P20\", // jump to cell P20\n        \"w\",             // scroll up\n        \"a\",             // scroll left\n    ];\n\n    for cmd in commands.iter() {\n        println!(\"\\nExecuting command: '{}'\", cmd);\n        execute_command(\u0026mut sheet, cmd, \u0026mut status);\n        println!(\"Status: {}\", status);\n        println!(\n            \"View position: row={}, col={}\",\n            sheet.view_row, sheet.view_col\n        );\n        sheet.spreadsheet_display();\n    }\n\n    // Try boundary cases\n    println!(\"\\n=== TESTING BOUNDARY CASES ===\");\n\n    // Scroll to a corner\n    println!(\"\\nScrolling to top-left (A1):\");\n    execute_command(\u0026mut sheet, \"scroll_to A1\", \u0026mut status);\n    sheet.spreadsheet_display();\n\n    // Try to scroll beyond left boundary\n    println!(\"\\nTrying to scroll left beyond boundary ('a'):\");\n    execute_command(\u0026mut sheet, \"a\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    // Scroll to bottom-right corner\n    println!(\"\\nScrolling to bottom-right (Y25):\");\n    execute_command(\u0026mut sheet, \"scroll_to Y25\", \u0026mut status);\n    sheet.spreadsheet_display();\n\n    // Try to scroll beyond right/bottom boundary\n    println!(\"\\nTrying to scroll down beyond boundary ('s'):\");\n    execute_command(\u0026mut sheet, \"s\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    println!(\"\\nTrying to scroll right beyond boundary ('d'):\");\n    execute_command(\u0026mut sheet, \"d\", \u0026mut status);\n    println!(\n        \"Status: {}, view_row={}, view_col={}\",\n        status, sheet.view_row, sheet.view_col\n    );\n\n    println!(\"\\nScroll test completed successfully!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","spreadsheet_test.rs"],"content":"// #[cfg(test)]\n#![cfg(not(tarpaulin_include))]\n\nmod spreadsheet_tests {\n    use cop::cell::cell_dep_insert;\n    use cop::spreadsheet::{FunctionName, Operand, ParsedRHS, Spreadsheet};\n    // use std::collections::BTreeSet;\n    use std::time::Instant;\n    // use cop::cell;\n    // use serde_json::Number;\n\n    // use super::*;\n\n    #[test]\n    fn test_spreadsheet_creation() {\n        // Test creating a spreadsheet with valid dimensions\n        let sheet = Spreadsheet::spreadsheet_create(10, 10);\n        assert!(sheet.is_some());\n        let sheet = sheet.unwrap();\n        assert_eq!(sheet.rows, 10);\n        assert_eq!(sheet.cols, 10);\n        assert_eq!(sheet.cells.len(), 100);\n\n        // Test cells initialization\n        for r in 1..=10 {\n            for c in 1..=10 {\n                let index = ((r - 1) as usize * 10 + (c - 1) as usize) as usize;\n                assert!(sheet.cells[index].is_some());\n            }\n        }\n        // Test creating a spreadsheet with larger dimensions\n        let sheet = Spreadsheet::spreadsheet_create(999, 18278);\n        assert!(sheet.is_some());\n        let sheet = sheet.unwrap();\n        assert_eq!(sheet.rows, 999);\n        assert_eq!(sheet.cols, 18278);\n\n        // Test cells initialization\n        for r in 1..=999 {\n            for c in 1..=18278 {\n                let index = ((r - 1) as usize * 10 + (c - 1) as usize) as usize;\n                assert!(sheet.cells[index].is_some());\n            }\n        }\n    }\n\n    #[test]\n    fn test_column_letter_conversion() {\n        // Test converting column numbers to letters\n        assert_eq!(Spreadsheet::col_to_letter(1), \"A\");\n        assert_eq!(Spreadsheet::col_to_letter(26), \"Z\");\n        assert_eq!(Spreadsheet::col_to_letter(27), \"AA\");\n        assert_eq!(Spreadsheet::col_to_letter(52), \"AZ\");\n        assert_eq!(Spreadsheet::col_to_letter(53), \"BA\");\n        assert_eq!(Spreadsheet::col_to_letter(702), \"ZZ\");\n        assert_eq!(Spreadsheet::col_to_letter(703), \"AAA\");\n        assert_eq!(Spreadsheet::col_to_letter(704), \"AAB\");\n        assert_eq!(Spreadsheet::col_to_letter(728), \"AAZ\");\n        assert_eq!(Spreadsheet::col_to_letter(729), \"ABA\");\n        assert_eq!(Spreadsheet::col_to_letter(1404), \"BAZ\");\n        assert_eq!(Spreadsheet::col_to_letter(18278), \"ZZZ\");\n\n        // Test converting letters to column numbers\n        assert_eq!(Spreadsheet::letter_to_col(\"A\"), 1);\n        assert_eq!(Spreadsheet::letter_to_col(\"Z\"), 26);\n        assert_eq!(Spreadsheet::letter_to_col(\"AA\"), 27);\n        assert_eq!(Spreadsheet::letter_to_col(\"AZ\"), 52);\n        assert_eq!(Spreadsheet::letter_to_col(\"BA\"), 53);\n        assert_eq!(Spreadsheet::letter_to_col(\"ZZ\"), 702);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAA\"), 703);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAB\"), 704);\n        assert_eq!(Spreadsheet::letter_to_col(\"AAZ\"), 728);\n        assert_eq!(Spreadsheet::letter_to_col(\"ABA\"), 729);\n        assert_eq!(Spreadsheet::letter_to_col(\"BAZ\"), 1404);\n        assert_eq!(Spreadsheet::letter_to_col(\"ZZZ\"), 18278);\n\n        // Test round-trip conversion\n        for col in 1..=100 {\n            let letter = Spreadsheet::col_to_letter(col);\n            let back = Spreadsheet::letter_to_col(\u0026letter);\n            assert_eq!(col, back);\n        }\n    }\n\n    #[test]\n    fn test_cell_name_operations() {\n        // Test generating cell names\n        assert_eq!(Spreadsheet::get_cell_name(1, 1), \"A1\");\n        assert_eq!(Spreadsheet::get_cell_name(10, 26), \"Z10\");\n        assert_eq!(Spreadsheet::get_cell_name(100, 27), \"AA100\");\n        assert_eq!(Spreadsheet::get_cell_name(100, 100), \"CV100\");\n\n        // Test parsing cell names in a spreadsheet context\n        let sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n\n        // Valid cell names\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A1\"), Some((1, 1)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"Z10\"), Some((10, 26)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"AA100\"), Some((100, 27)));\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"CV100\"), Some((100, 100)));\n\n        // Invalid cell names (out of bounds)\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A0\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A101\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"CW1\"), None); // Column out of bounds\n\n        // Malformed cell names\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"1A\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A1B\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"A\"), None);\n        assert_eq!(sheet.spreadsheet_parse_cell_name(\"1\"), None);\n    }\n\n    #[test]\n    fn test_is_numeric() {\n        // Test numeric strings\n        assert!(Spreadsheet::is_numeric(\"0\"));\n        assert!(Spreadsheet::is_numeric(\"123\"));\n        assert!(Spreadsheet::is_numeric(\"9876543210\"));\n        assert!(Spreadsheet::is_numeric(\"00\"));\n        assert!(Spreadsheet::is_numeric(\"0098\"));\n        assert!(Spreadsheet::is_numeric(\"0090\"));\n\n        // Test non-numeric strings\n        assert!(!Spreadsheet::is_numeric(\"\"));\n        assert!(!Spreadsheet::is_numeric(\"A\"));\n        assert!(!Spreadsheet::is_numeric(\"12A\"));\n        assert!(!Spreadsheet::is_numeric(\"A12\"));\n        assert!(!Spreadsheet::is_numeric(\"-123\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"+123\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"12.3\")); // Contains non-digit\n        assert!(!Spreadsheet::is_numeric(\"-0090\")); // Contains non-digit\n    }\n\n    #[test]\n    fn test_evaluate_expression() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup some cell values\n        let a1_idx = 0 * 10 + 0;\n        let a2_idx = 1 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n        let b2_idx = 1 * 10 + 1;\n        let c1_idx = 0 * 10 + 2;\n        let d1_idx = 0 * 10 + 3;\n        let d2_idx = 0 * 10 + 4;\n        let d3_idx = 0 * 10 + 5;\n\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 10;\n        }\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 20;\n        }\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.value = 30;\n        }\n        if let Some(cell) = sheet.cells[b2_idx].as_mut() {\n            cell.value = 40;\n        }\n        if let Some(cell) = sheet.cells[c1_idx].as_mut() {\n            cell.value = 123;\n        }\n        if let Some(cell) = sheet.cells[d1_idx].as_mut() {\n            cell.value = -234;\n        }\n        if let Some(cell) = sheet.cells[d2_idx].as_mut() {\n            cell.value = 2;\n            cell.error = true;\n        }\n        if let Some(cell) = sheet.cells[d3_idx].as_mut() {\n            cell.value = 2;\n            cell.error = false;\n        }\n\n        // Test various expressions similar to the C tests\n\n        // Test with numeric literals\n        let expr = ParsedRHS::SingleValue(Operand::Number(42));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 42);\n        assert!(!error);\n\n        // Test with positive and negative numbers\n        let expr = ParsedRHS::SingleValue(Operand::Number(-1));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -1);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(1));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 1);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(09));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 9);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(-09));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -9);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(-2_147_483_648));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, -2147483648);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Number(2_147_483_647));\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 1);\n        assert_eq!(value, 2147483647);\n        assert!(!error);\n\n        // Test with cell references\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, 10);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 4)); // A4\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, -234);\n        assert!(!error);\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 5)); // A4\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert!(error);\n\n        // Test for none formula i.e. default cells\n        let expr = ParsedRHS::None;\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert_eq!(value, 0);\n        assert!(!error);\n\n        // Test basic arithmetic\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1 = 10\n            operator: '+',\n            rhs: Operand::Cell(2, 1), // A2 = 20\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 30);\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 5),\n            operator: '+',\n            rhs: Operand::Cell(1, 1),\n        }; // A5 = ERR\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert!(error);\n\n        // Test arithmetic with constants\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(3),\n            operator: '*',\n            rhs: Operand::Cell(1, 2), // B1 = 30\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 90);\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 3), // C1 = 123\n            operator: '-',\n            rhs: Operand::Number(34),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 89);\n        assert!(!error);\n\n        // Test division and error propagation\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(3),\n            operator: '/',\n            rhs: Operand::Cell(1, 1), // A1 = 10\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 0); // Integer division\n        assert!(!error);\n\n        let expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(10),\n            operator: '/',\n            rhs: Operand::Number(0),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 1, 2);\n        assert_eq!(value, 0);\n        assert!(error); // Division by zero error\n\n        // Test propagation of errors\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = true;\n        }\n\n        let expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1 (with error)\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 2, 2);\n        assert!(error);\n\n        // Test with range functions\n        // First, reset A1's error flag\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = false;\n        }\n\n        // Test SUM function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 100); // 10 + 20 + 30 + 40\n        assert!(!error);\n\n        // Test MIN function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 10);\n        assert!(!error);\n\n        // Test MAX function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 40);\n        assert!(!error);\n\n        // Test AVG function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 25); // (10 + 20 + 30 + 40) / 4\n        assert!(!error);\n\n        // Range can be single cell as well\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(1, 1), // A1 = 10\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 10); // (10) / 1\n        assert!(!error);\n\n        //Test STDDEV function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 11); // Standard deviation of the values\n        assert!(!error);\n\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(1, 1), // A1 = 10\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 0); // Standard deviation returns 0 for a single value\n        assert!(!error);\n\n        // Test COPY function\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (\n                Operand::Cell(1, 1), // A1 = 10\n                Operand::Cell(2, 2), // B2 = 40\n            ),\n        };\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert_eq!(value, 0); // Copy is not implemented in this function. it should simply return 0,false\n        assert!(!error); // Copy function should return a default error\n\n        // Test error propagation with functions\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.error = true;\n        }\n\n        let expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 (with error)\n                Operand::Cell(2, 2), // B2\n            ),\n        };\n        let (_, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        assert!(error);\n\n        // Test for sleep function with error\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 5), // A5 = 2\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Test for sleep function without error\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 6), // A6 = 2\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 2); // Sleep function should sleep for 2 seconds\n\n        // test for sleep with cell with negative value\n        //A4 is negative value\n        let expr = ParsedRHS::Sleep(\n            Operand::Cell(1, 4), // A4 = -234\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, -234); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Sleep with value as argument\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(2), // Sleep for 2 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 2); // Sleep function should sleep for 2 seconds\n\n        // Test for sleep with negative value\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(-2), // Sleep for -2 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, -2); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n\n        // Test for sleep with zero value\n        let expr = ParsedRHS::Sleep(\n            Operand::Number(0), // Sleep for 0 seconds\n        );\n        let start = Instant::now();\n        let (value, error) = sheet.spreadsheet_evaluate_expression(\u0026expr, 3, 3);\n        let duration = start.elapsed();\n        assert_eq!(value, 0); // Sleep function should return cell value\n        assert!(!error); // Sleep function should return an error\n        assert!(duration.as_secs() == 0); // Sleep function should sleep for 0 seconds\n    }\n\n    #[test]\n    fn test_cycle_detection() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Set up a cyclic dependency: A1 depends on B1, B1 depends on A1\n        let a1_idx = 0 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n\n        // First, modify A1 to depend on B1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_dep_insert(cell_a1, 1, 2);\n        }\n        assert!(sheet.first_step_find_cycle((1, 1), (1, 2), (0, 0), false));\n\n        // Then, modify B1 to depend on A1 (in a separate step)\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_mut() {\n            cell_dep_insert(cell_b1, 1, 1);\n        }\n\n        // Test cycle detection\n        assert!(sheet.first_step_find_cycle((1, 2), (1, 1), (0, 0), false));\n\n        // Test no cycle\n        let c1_idx = 0 * 10 + 2;\n\n        // First, modify C1 to depend on C2\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_mut() {\n            cell_dep_insert(cell_c1, 2, 3);\n        }\n\n        // Test no cycle detection\n        assert!(!sheet.first_step_find_cycle((1, 3), (1, 1), (1, 2), false));\n\n        // Test for is_range = true\n        // add A1 to dependencies of D1. i.e. changing D1 will change A1\n        let d1_idx = 0 * 10 + 3;\n        if let Some(cell_d1) = sheet.cells[d1_idx].as_mut() {\n            cell_dep_insert(cell_d1, 1, 1);\n        }\n\n        // Test cycle detection\n        assert!(sheet.first_step_find_cycle((1, 4), (1, 1), (2, 2), true));\n    }\n\n    #[test]\n    pub fn test_dependencies_management() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup A1's formula to depend on B1 and C1\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2), // B1\n                operator: '+',\n                rhs: Operand::Cell(1, 3), // C1\n            };\n        }\n\n        // Now update the dependencies\n        sheet.update_dependencies((1, 1), (1, 2), (1, 3), false);\n\n        // Check if dependencies were correctly set up\n        let b1_idx = 0 * 10 + 1;\n        let c1_idx = 0 * 10 + 2;\n\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_c1);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n\n        // Now change A1's formula to depend only on D1\n        sheet.remove_old_dependents(1, 1);\n\n        // Set the new formula for A1\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Cell(1, 4)); // D1\n        }\n\n        sheet.update_dependencies((1, 1), (1, 4), (0, 0), false);\n\n        // Check that old dependencies were removed\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        if let Some(cell_c1) = sheet.cells[c1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_c1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        // Check that new dependency was added\n        let d1_idx = 0 * 10 + 3;\n        if let Some(cell_d1) = sheet.cells[d1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_d1);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n\n        // Test for larger spreadsheet\n        let mut sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n        // set A1 to 5\n        let a1_idx = 0 * 100 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 5;\n        }\n        // set A2 to 10\n        let a2_idx = 1 * 100 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 10;\n        }\n\n        //set A3 to 20\n        let a3_idx = 2 * 100 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_mut() {\n            cell.value = 20;\n        }\n        // set A4 to -5\n        let a4_idx = 3 * 100 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_mut() {\n            cell.value = -5;\n        }\n\n        //  set B1 to be equal to A1 + A2 using set_cell_value\n        let b1_idx = 0 * 100 + 1;\n        // set formula of B1 to A1 + A2\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 1), // A1\n                operator: '+',\n                rhs: Operand::Cell(2, 1), // A2\n            };\n        }\n        sheet.update_dependencies((1, 2), (1, 1), (2, 1), false);\n\n        // assign A1 to 20 using formula\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Number(20));\n        }\n        sheet.update_dependencies((1, 1), (0, 0), (0, 0), false);\n        // assign C1 to B1 * 2\n        let c1_idx = 0 * 100 + 2;\n        if let Some(cell) = sheet.cells[c1_idx].as_mut() {\n            cell.formula = ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2), // B1\n                operator: '*',\n                rhs: Operand::Number(2),\n            };\n        }\n\n        // update dependencies for C1\n        sheet.update_dependencies((1, 3), (1, 2), (0, 0), false);\n\n        // update dependencies for A2\n        // assign A2 to 10 using formula\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.formula = ParsedRHS::SingleValue(Operand::Number(10));\n        }\n        sheet.update_dependencies((2, 1), (0, 0), (0, 0), false);\n\n        // set D1 = MAX(A1:A4)\n        // set formula of D1\n        let d1_idx = 0 * 100 + 3;\n        if let Some(cell) = sheet.cells[d1_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Max,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D2 = MIN(A1:A4)\n        // set formula of D2\n        let d2_idx = 1 * 100 + 3;\n        if let Some(cell) = sheet.cells[d2_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Min,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D3 = SUM(A1:A4)\n        // set formula of D3\n        let d3_idx = 2 * 100 + 3;\n        if let Some(cell) = sheet.cells[d3_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Sum,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D4= AVG(A1:A4)\n        // set formula of D4\n        let d4_idx = 3 * 100 + 3;\n        if let Some(cell) = sheet.cells[d4_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Avg,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set D5 = STDDEV(A1:A4)\n        // set formula of D5\n        let d5_idx = 4 * 100 + 3;\n        if let Some(cell) = sheet.cells[d5_idx].as_mut() {\n            cell.formula = ParsedRHS::Function {\n                name: FunctionName::Stdev,\n                args: (\n                    Operand::Cell(1, 1), // A1\n                    Operand::Cell(4, 1), // A4\n                ),\n            };\n        }\n        // set E1= SLEEP(A1)\n        // set formula of E1\n        let e1_idx = 0 * 100 + 4;\n        if let Some(cell) = sheet.cells[e1_idx].as_mut() {\n            cell.formula = ParsedRHS::Sleep(Operand::Cell(1, 1)); // A1\n        }\n        // set E2= SLEEP(A4)\n        // set formula of E2\n        let e2_idx = 1 * 100 + 4;\n        if let Some(cell) = sheet.cells[e2_idx].as_mut() {\n            cell.formula = ParsedRHS::Sleep(Operand::Cell(4, 1)); // A4\n        }\n\n        // update dependencies for D1\n        sheet.update_dependencies((1, 4), (1, 1), (4, 1), true);\n        // update dependencies for D2\n        sheet.update_dependencies((2, 4), (1, 1), (4, 1), true);\n        // update dependencies for D3\n        sheet.update_dependencies((3, 4), (1, 1), (4, 1), true);\n        // update dependencies for D4\n        sheet.update_dependencies((4, 4), (1, 1), (4, 1), true);\n        // update dependencies for D5\n        sheet.update_dependencies((5, 4), (1, 1), (4, 1), true);\n        // update dependencies for E1\n        sheet.update_dependencies((1, 5), (1, 1), (0, 0), false);\n        // update dependencies for E2\n        sheet.update_dependencies((2, 5), (4, 1), (0, 0), false);\n        // Check that dependencies were correctly set up\n        // B1 D1-D5 E1 should be present in dependents of A1\n\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(deps.contains(\u0026(1, 2)));\n            assert!(deps.contains(\u0026(1, 4)));\n            assert!(deps.contains(\u0026(2, 4)));\n            assert!(deps.contains(\u0026(3, 4)));\n            assert!(deps.contains(\u0026(4, 4)));\n            assert!(deps.contains(\u0026(5, 4)));\n            assert!(deps.contains(\u0026(1, 5)));\n        }\n\n        // dependencies of B1 should contain C1\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(deps.contains(\u0026(1, 3)));\n        }\n\n        // test for the remove_old_dependents function\n        // remove old dependents of B1 . now B1 should not be present in A1's dependents\n        sheet.remove_old_dependents(1, 2); //B1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(1, 2)));\n        }\n\n        // remove old dependents for E2 , now E2 should not be present in A4's dependents\n        sheet.remove_old_dependents(2, 5);\n        if let Some(cell_a4) = sheet.cells[a4_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a4);\n            assert!(!deps.contains(\u0026(2, 5)));\n        }\n\n        // remove old dependents for D1 , now D1 should not be present in A1's dependents\n        sheet.remove_old_dependents(1, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(1, 4)));\n        }\n\n        // remove old dependents for D2 , now D2 should not be present in A1's dependents\n        sheet.remove_old_dependents(2, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(2, 4)));\n        }\n\n        // remove old dependents for D3 , now D3 should not be present in A1's dependents\n        sheet.remove_old_dependents(3, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(3, 4)));\n        }\n\n        // remove old dependents for D4 , now D4 should not be present in A1's dependents\n        sheet.remove_old_dependents(4, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(4, 4)));\n        }\n\n        // remove old dependents for D5 , now D5 should not be present in A1's dependents\n        sheet.remove_old_dependents(5, 4);\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a1);\n            assert!(!deps.contains(\u0026(5, 4)));\n        }\n\n        // remove dependents for A1. Now A1 should not be present in any cell's dependents\n        sheet.remove_old_dependents(1, 1);\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_b1);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n\n        // Single value operand cell is left. check that as well\n        // first assign A1 to A2 let's say\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_a1.formula = ParsedRHS::SingleValue(Operand::Cell(2, 1)); // A2\n        }\n        sheet.update_dependencies((1, 1), (2, 1), (0, 0), false);\n        // check that A1 is present in A2's dependents\n        if let Some(cell_a2) = sheet.cells[a2_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a2);\n            assert!(deps.contains(\u0026(1, 1)));\n        }\n        // remove old dependents for A1 , now A1 should not be present in A2's dependents\n        sheet.remove_old_dependents(1, 1);\n        if let Some(cell_a2) = sheet.cells[a2_idx].as_ref() {\n            let deps = sheet.get_dependent_names(cell_a2);\n            assert!(!deps.contains(\u0026(1, 1)));\n        }\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        // Setup:\n        // A1 depends on B1\n        // B1 depends on C1\n        // C1 has no dependencies\n        let a1_idx = 0 * 10 + 0;\n        let b1_idx = 0 * 10 + 1;\n\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_mut() {\n            cell_dep_insert(cell_a1, 1, 2); // A1 points to B1\n        }\n\n        if let Some(cell_b1) = sheet.cells[b1_idx].as_mut() {\n            cell_dep_insert(cell_b1, 1, 3); // B1 points to C1\n        }\n\n        // Perform topological sort starting from A1\n        if let Some(cell_a1) = sheet.cells[a1_idx].as_ref() {\n            let sorted = sheet.topo_sort(cell_a1);\n\n            // Check that the order is correct (should be C1, B1, A1)\n            assert_eq!(sorted.len(), 3);\n            assert_eq!(sorted[0], (1, 1)); // C1\n            assert_eq!(sorted[1], (1, 2)); // B1\n            assert_eq!(sorted[2], (1, 3)); // A1\n        }\n\n        // Test topo sort for large spreadsheet (enhanced check)\n        let mut sheet = Spreadsheet::spreadsheet_create(100, 100).unwrap();\n        // set_cell(sheet, \"B1\", \"SUM(A1:A10)\");\n        // set_cell(sheet, \"B2\", \"MAX(A1:A10)\");\n        // set_cell(sheet, \"B3\", \"MIN(A1:A10)\");\n        // set_cell(sheet, \"B4\", \"AVG(A1:A10)\");\n        // set_cell(sheet, \"B5\", \"STDEV(A1:A10)\");\n\n        // // Set formulas in C1:C5\n        // set_cell(sheet, \"C1\", \"SUM(B1:B5)\");\n        // set_cell(sheet, \"C2\", \"MAX(B1:B5)\");\n        // set_cell(sheet, \"C3\", \"MIN(B1:B5)\");\n        // set_cell(sheet, \"C4\", \"AVG(B1:B5)\");\n        // set_cell(sheet, \"C5\", \"STDEV(B1:B5)\");\n\n        // ADD B1 till B5 to A1:A10\n        for i in 1..=10 {\n            for j in 1..=5 {\n                let cell_idx = (i - 1) * 100;\n                if let Some(cell) = sheet.cells[cell_idx].as_mut() {\n                    cell_dep_insert(cell, j, 2);\n                }\n            }\n        }\n\n        // ADD C1 till C5 to B1:B10\n        for i in 1..=10 {\n            for j in 1..=5 {\n                let cell_idx = (i - 1) * 100 + 1;\n                if let Some(cell) = sheet.cells[cell_idx].as_mut() {\n                    cell_dep_insert(cell, j, 3);\n                }\n            }\n        }\n\n        let sorted_cells = sheet.topo_sort(\u0026sheet.cells[0].as_ref().unwrap());\n        // the vector should be something of the type... A1 then (B1 to B5 in any order) then (C1:C5 in any order)\n        assert_eq!(sorted_cells.len(), 11);\n        assert_eq!(sorted_cells[0], (1, 1)); // A1\n        for i in 1..=5 {\n            assert_eq!(sorted_cells[i], (6 - i as i16, 2)); // B1 to B5\n        }\n        for i in 1..=5 {\n            assert_eq!(sorted_cells[i + 5], (6 - i as i16, 3)); // C1 to C5\n        }\n    }\n\n    #[test]\n    fn test_set_cell_value() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Test setting a simple value\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(42));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_ref() {\n            assert_eq!(cell.value, 42);\n            assert!(!cell.error);\n        }\n\n        // Test setting a cell reference\n        let ref_expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // Reference to A1\n        sheet.spreadsheet_set_cell_value(2, 1, ref_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a2_idx = 1 * 10 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_ref() {\n            assert_eq!(cell.value, 42); // Should get value from A1\n            assert!(!cell.error);\n        }\n\n        // Test cycle detection\n        let cycle_expr = ParsedRHS::SingleValue(Operand::Cell(2, 1)); // Reference to A2, creating cycle\n        sheet.spreadsheet_set_cell_value(1, 1, cycle_expr.clone(), \u0026mut status);\n        assert_eq!(status, \"Cycle Detected\");\n\n        // Test formula with function\n        let sum_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(1, 2), // B1\n            ),\n        };\n\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(3, 1, avg_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        let a3_idx = 2 * 10 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert_eq!(cell.value, 42); // (42 + 42) / 2\n            assert!(!cell.error);\n        }\n\n        let min_expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 1, min_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a4_idx = 3 * 10 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_ref() {\n            assert_eq!(cell.value, 42); // min(42, 42)\n            assert!(!cell.error);\n        }\n\n        let max_expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(5, 1, max_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a5_idx = 4 * 10 + 0;\n        if let Some(cell) = sheet.cells[a5_idx].as_ref() {\n            assert_eq!(cell.value, 42); // max(42, 42)\n            assert!(!cell.error);\n        }\n\n        let stdev_expr = ParsedRHS::Function {\n            name: FunctionName::Stdev,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(6, 1, stdev_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a6_idx = 5 * 10 + 0;\n        if let Some(cell) = sheet.cells[a6_idx].as_ref() {\n            assert_eq!(cell.value, 0); // stdev(42, 42) = 0\n            assert!(!cell.error);\n        }\n\n        // First set B1 to some value\n        let b1_val_expr = ParsedRHS::SingleValue(Operand::Number(58));\n        sheet.spreadsheet_set_cell_value(1, 2, b1_val_expr, \u0026mut status);\n\n        // Now set A3 to be SUM(A1:B1)\n        sheet.spreadsheet_set_cell_value(3, 1, sum_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert_eq!(cell.value, 100); // 42 + 58\n            assert!(!cell.error);\n        }\n\n        // Test for arithmetic expression type formula\n        let arith_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1\n            operator: '+',\n            rhs: Operand::Cell(2, 1), // A2\n        };\n        sheet.spreadsheet_set_cell_value(7, 1, arith_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a7_idx = 6 * 10 + 0;\n        if let Some(cell) = sheet.cells[a7_idx].as_ref() {\n            assert_eq!(cell.value, 84); // 42 + 42\n            assert!(!cell.error);\n        }\n\n        // Test for sleep type formula\n        let sleep_expr = ParsedRHS::Sleep(Operand::Number(2)); // Sleep for 2 seconds\n        sheet.spreadsheet_set_cell_value(8, 1, sleep_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n        let a8_idx = 7 * 10 + 0;\n        if let Some(cell) = sheet.cells[a8_idx].as_ref() {\n            assert_eq!(cell.value, 2); // Sleep function should return cell value\n            assert!(!cell.error);\n        }\n\n        //Test for Copy type formula\n        let copy_expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (Operand::Cell(1, 1), Operand::Cell(8, 1)),\n        };\n        sheet.spreadsheet_set_cell_value(1, 2, copy_expr, \u0026mut status);\n        // B1 should have value of A1 . B2 should have value of A2 . B3 should have value of A3...and so on. and formula of them should be None\n        assert_eq!(status, \"ok\");\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B1 should have value of A1\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b2_idx = 1 * 10 + 1;\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B2 should have value of A2\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b3_idx = 2 * 10 + 1;\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 100); // B3 should have value of A3\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(100)));\n        }\n        let b4_idx = 3 * 10 + 1;\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B4 should have value of A4\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b5_idx = 4 * 10 + 1;\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 42); // B5 should have value of A5\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(42)));\n        }\n        let b6_idx = 5 * 10 + 1;\n        if let Some(cell) = sheet.cells[b6_idx].as_ref() {\n            assert_eq!(cell.value, 0); // B6 should have value of A6\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(0)));\n        }\n        let b7_idx = 6 * 10 + 1;\n        if let Some(cell) = sheet.cells[b7_idx].as_ref() {\n            assert_eq!(cell.value, 84); // B7 should have value of A7\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(84)));\n        }\n        let b8_idx = 7 * 10 + 1;\n        if let Some(cell) = sheet.cells[b8_idx].as_ref() {\n            assert_eq!(cell.value, 2); // B8 should have value of A8\n            assert_eq!(cell.formula, ParsedRHS::SingleValue(Operand::Number(2)));\n        }\n    }\n\n    #[test]\n    fn test_undo_function() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Test setting a simple value\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(42));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n        assert_eq!(status, \"ok\");\n\n        // Test undo\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 0); // Cell should be reset to 0\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        // should go back to 42\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 42); // Cell should be reset to 42\n\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(100));\n        sheet.spreadsheet_set_cell_value(1, 1, val_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[0].as_ref().unwrap().value, 100); // Cell should be set to 100\n\n        let val_expr = ParsedRHS::SingleValue(Operand::Number(200));\n        sheet.spreadsheet_set_cell_value(2, 1, val_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[10].as_ref().unwrap().value, 200); // Cell should be set to 200\n\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(2, 1), // A2\n            ),\n        };\n\n        sheet.spreadsheet_set_cell_value(1, 3, avg_expr, \u0026mut status);\n\n        assert_eq!(sheet.cells[2].as_ref().unwrap().value, 150); // Cell should be set to 150\n\n        sheet.spreadsheet_undo(\u0026mut status);\n        assert_eq!(sheet.cells[2].as_ref().unwrap().value, 0); // Cell should be reset to 0\n    }\n\n    #[test]\n    fn test_command_validation() {\n        let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Test valid commands\n\n        // Number\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"42\");\n        assert!(valid);\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(42)));\n\n        // Cell reference\n        let (valid, row, col, expr) = sheet.is_valid_command(\"B2\", \"A1\");\n        assert!(valid);\n        assert_eq!(row, 2);\n        assert_eq!(col, 2);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Cell(1, 1)));\n\n        // Arithmetic\n        let (valid, row, col, expr) = sheet.is_valid_command(\"C3\", \"A1+B2\");\n        assert!(valid);\n        assert_eq!(row, 3);\n        assert_eq!(col, 3);\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 1),\n                operator: '+',\n                rhs: Operand::Cell(2, 2),\n            }\n        );\n\n        // Function\n        // SUM\n        let (valid, row, col, expr) = sheet.is_valid_command(\"D4\", \"SUM(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 4);\n        assert_eq!(col, 4);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Sum,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // AVG\n        let (valid, row, col, expr) = sheet.is_valid_command(\"E5\", \"AVG(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 5);\n        assert_eq!(col, 5);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Avg,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // MIN\n        let (valid, row, col, expr) = sheet.is_valid_command(\"F6\", \"MIN(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 6);\n        assert_eq!(col, 6);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Min,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // MAX\n        let (valid, row, col, expr) = sheet.is_valid_command(\"G7\", \"MAX(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 7);\n        assert_eq!(col, 7);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Max,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // STDEV\n        let (valid, row, col, expr) = sheet.is_valid_command(\"H8\", \"STDEV(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 8);\n        assert_eq!(col, 8);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Stdev,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n        // COPY\n        let (valid, row, col, expr) = sheet.is_valid_command(\"I9\", \"COPY(A1:B2)\");\n        assert!(valid);\n        assert_eq!(row, 9);\n        assert_eq!(col, 9);\n        assert_eq!(\n            expr,\n            ParsedRHS::Function {\n                name: FunctionName::Copy,\n                args: (Operand::Cell(1, 1), Operand::Cell(2, 2),),\n            }\n        );\n\n        // Test invalid commands\n\n        // Invalid cell name\n        let (valid, _, _, _) = sheet.is_valid_command(\"X1\", \"42\");\n        assert!(!valid); // X1 is beyond the column limit\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"1A\", \"42\");\n        assert!(!valid); // Malformed cell name\n\n        // Invalid formula\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"A1++B1\");\n        assert!(!valid); // Malformed formula\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"SUM(A1)\");\n        assert!(!valid); // Missing second argument\n\n        // Out-of-bounds reference\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"Z100\");\n        assert!(!valid); // Z100 is beyond the sheet bounds\n\n        // Test additional invalid commands\n        let (valid, _, _, _) = sheet.is_valid_command(\"B1\", \"-A11\");\n        assert!(!valid); // A11 out of bounds\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"MAZ(B1:C5)\");\n        assert!(!valid); // Invalid function\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"SLEEP()\");\n        assert!(!valid); // Missing arguments\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"A1\", \"MAX()\");\n        assert!(!valid); // Missing arguments\n\n        let (valid, _, _, _) = sheet.is_valid_command(\"\", \"\");\n        assert!(!valid); // Empty cell and formula\n\n        // Test arbitrary is_Valid commands\n        // give cell name A1 , formula = -1 , +1 , +2, -4 , 2147483647,-2147483648, 00, 09, 0090, -0090, -1*-1,-1*+1, -1+-1,-1-+1,-1/+1,-1/-1,1/0,2/0,A2*B1,-1*B1, +3*B1,B1+2,B1/0,C1-34,C1/-3,D1*-4,D1+-6,C1-+3\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"-1\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-1)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"+1\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(1)));\n\n        let (valid, row, col, expr) = sheet.is_valid_command(\"A1\", \"+2\");\n        assert!(valid); // valid number\n        assert_eq!(row, 1);\n        assert_eq!(col, 1);\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(2)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-4\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-4)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"2147483647\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(2147483647)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-2147483648\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-2147483648)));\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"00\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(0)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"09\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(9)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"0090\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(90)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-0090\");\n        assert!(valid); // valid number\n        assert_eq!(expr, ParsedRHS::SingleValue(Operand::Number(-90)));\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1+-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '+',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1-+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '-',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1/+1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '/',\n                rhs: Operand::Number(1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1/-1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '/',\n                rhs: Operand::Number(-1),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"1/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(1),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"2/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(2),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"A2*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(2, 1),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"-1*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(-1),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"+3*B1\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Number(3),\n                operator: '*',\n                rhs: Operand::Cell(1, 2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"B1+2\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2),\n                operator: '+',\n                rhs: Operand::Number(2),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"B1/0\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 2),\n                operator: '/',\n                rhs: Operand::Number(0),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-34\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(34),\n            }\n        );\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1/-3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '/',\n                rhs: Operand::Number(-3),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"D1*-4\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 4),\n                operator: '*',\n                rhs: Operand::Number(-4),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"D1+-6\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 4),\n                operator: '+',\n                rhs: Operand::Number(-6),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-+3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(3),\n            }\n        );\n\n        let (valid, _, _, expr) = sheet.is_valid_command(\"A1\", \"C1-+3\");\n        assert!(valid); // valid number\n        assert_eq!(\n            expr,\n            ParsedRHS::Arithmetic {\n                lhs: Operand::Cell(1, 3),\n                operator: '-',\n                rhs: Operand::Number(3),\n            }\n        );\n    }\n\n    #[test]\n    fn test_arithmetic_expression_validation() {\n        let sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Test valid expressions\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"A1+B2\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"42-A1\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"A1*10\");\n        assert!(valid);\n\n        let (valid, expr) = sheet.is_valid_arithmetic_expression(\"B2/2\");\n        assert!(valid);\n\n        // Test invalid expressions\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1++B2\");\n        assert!(!valid); // Invalid operator\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1+\");\n        assert!(!valid); // Missing second operand\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"+B2\");\n        assert!(!valid); // Missing first operand\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"A1 + B2\");\n        assert!(!valid); // Spaces not allowed\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"Z100+A1\");\n        assert!(!valid); // Out of bounds cell\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"--5\");\n        assert!(!valid); // Invalid format\n\n        let (valid, _) = sheet.is_valid_arithmetic_expression(\"-4+++5\");\n        assert!(!valid); // Invalid format\n\n    }\n\n    #[test]\n    fn test_range_functions() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Setup test data in A1-A5\n        let vals = [10, 20, 30, 40, 50];\n        for i in 0..5 {\n            let row = i + 1;\n            let expr = ParsedRHS::SingleValue(Operand::Number(vals[i]));\n            sheet.spreadsheet_set_cell_value(row as i16, 1, expr, \u0026mut status);\n            assert_eq!(status, \"ok\");\n        }\n\n        // Test SUM\n        let sum_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(1, 2, sum_expr, \u0026mut status); // B1\n        assert_eq!(status, \"ok\");\n\n        let b1_idx = 0 * 10 + 1;\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 150); // 10+20+30+40+50\n            assert!(!cell.error);\n        }\n\n        // Test AVG\n        let avg_expr = ParsedRHS::Function {\n            name: FunctionName::Avg,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(2, 2, avg_expr, \u0026mut status); // B2\n        assert_eq!(status, \"ok\");\n\n        let b2_idx = 1 * 10 + 1;\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 30); // (10+20+30+40+50)/5\n            assert!(!cell.error);\n        }\n\n        // Test MIN\n        let min_expr = ParsedRHS::Function {\n            name: FunctionName::Min,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(3, 2, min_expr, \u0026mut status); // B3\n        assert_eq!(status, \"ok\");\n\n        let b3_idx = 2 * 10 + 1;\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 10);\n            assert!(!cell.error);\n        }\n\n        // Test MAX\n        let max_expr = ParsedRHS::Function {\n            name: FunctionName::Max,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 2, max_expr, \u0026mut status); // B4\n        assert_eq!(status, \"ok\");\n\n        let b4_idx = 3 * 10 + 1;\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 50);\n            assert!(!cell.error);\n        }\n\n        // Test COPY\n        let copy_expr = ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (\n                Operand::Cell(1, 1), // A1\n                Operand::Cell(5, 1), // A5\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(5, 2, copy_expr, \u0026mut status); // B5\n        assert_eq!(status, \"ok\");\n\n        let b5_idx = 4 * 10 + 1;\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 10); // Copying A1\n            assert!(!cell.error);\n        }\n\n        // Update a value and check if dependencies update\n        let new_val_expr = ParsedRHS::SingleValue(Operand::Number(100));\n        sheet.spreadsheet_set_cell_value(1, 1, new_val_expr, \u0026mut status); // A1 = 100\n        assert_eq!(status, \"ok\");\n\n        // Check that SUM, AVG, MIN, MAX all updated\n        if let Some(cell) = sheet.cells[b1_idx].as_ref() {\n            assert_eq!(cell.value, 240); // 100+20+30+40+50\n        }\n\n        if let Some(cell) = sheet.cells[b2_idx].as_ref() {\n            assert_eq!(cell.value, 48); // (100+20+30+40+50)/5\n        }\n\n        if let Some(cell) = sheet.cells[b3_idx].as_ref() {\n            assert_eq!(cell.value, 20); // 20\n        }\n        if let Some(cell) = sheet.cells[b4_idx].as_ref() {\n            assert_eq!(cell.value, 100); // 100\n        }\n        if let Some(cell) = sheet.cells[b5_idx].as_ref() {\n            assert_eq!(cell.value, 10); // B5 will still be 10\n        }\n    }\n\n    #[test]\n    fn test_error_propagation() {\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n        let mut status = String::new();\n\n        // Set up a cell with division by zero error\n        let div_zero_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Number(10),\n            operator: '/',\n            rhs: Operand::Number(0),\n        };\n        sheet.spreadsheet_set_cell_value(1, 1, div_zero_expr, \u0026mut status); // A1\n        assert_eq!(status, \"ok\");\n\n        // Verify error state\n        let a1_idx = 0 * 10 + 0;\n        if let Some(cell) = sheet.cells[a1_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Reference the error cell\n        let ref_expr = ParsedRHS::SingleValue(Operand::Cell(1, 1)); // A1\n        sheet.spreadsheet_set_cell_value(2, 1, ref_expr, \u0026mut status); // A2\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a2_idx = 1 * 10 + 0;\n        if let Some(cell) = sheet.cells[a2_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Use in arithmetic\n        let arith_expr = ParsedRHS::Arithmetic {\n            lhs: Operand::Cell(1, 1), // A1 (error)\n            operator: '+',\n            rhs: Operand::Number(5),\n        };\n        sheet.spreadsheet_set_cell_value(3, 1, arith_expr, \u0026mut status); // A3\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a3_idx = 2 * 10 + 0;\n        if let Some(cell) = sheet.cells[a3_idx].as_ref() {\n            assert!(cell.error);\n        }\n\n        // Use in function\n        let func_expr = ParsedRHS::Function {\n            name: FunctionName::Sum,\n            args: (\n                Operand::Cell(1, 1), // A1 (error)\n                Operand::Cell(1, 2), // B1\n            ),\n        };\n        sheet.spreadsheet_set_cell_value(4, 1, func_expr, \u0026mut status); // A4\n        assert_eq!(status, \"ok\");\n\n        // Check error propagation\n        let a4_idx = 3 * 10 + 0;\n        if let Some(cell) = sheet.cells[a4_idx].as_ref() {\n            assert!(cell.error);\n        }\n    }\n\n    #[test]\n    fn test_spreadsheet_display() {\n        use std::io::{self, Write};\n\n        // Create a spreadsheet for testing display\n        let mut sheet = Spreadsheet::spreadsheet_create(10, 10).unwrap();\n\n        // Setup cells with various values and error states\n        let a1_idx = 0 * 10 + 0; // A1\n        let a2_idx = 1 * 10 + 0; // A2\n        let b1_idx = 0 * 10 + 1; // B1\n        let b2_idx = 1 * 10 + 1; // B2\n\n        if let Some(cell) = sheet.cells[a1_idx].as_mut() {\n            cell.value = 42;\n            cell.error = false;\n        }\n\n        if let Some(cell) = sheet.cells[a2_idx].as_mut() {\n            cell.value = 100;\n            cell.error = false;\n        }\n\n        if let Some(cell) = sheet.cells[b1_idx].as_mut() {\n            cell.value = 0; // Value doesn't matter when error=true\n            cell.error = true;\n        }\n\n        if let Some(cell) = sheet.cells[b2_idx].as_mut() {\n            cell.value = 200;\n            cell.error = false;\n        }\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            // Redirect stdout to our buffer temporarily\n            let original_stdout = io::stdout();\n            let mut handle = original_stdout.lock();\n\n            // Call spreadsheet_display\n            sheet.spreadsheet_display();\n\n            // Flush to ensure all output is captured\n            handle.flush().unwrap();\n        }\n\n        // Convert captured output to string\n        let output_str = String::from_utf8_lossy(\u0026output);\n\n        // Basic verification of output structure\n        // Note: We can't fully test the exact output string since it's being\n        // printed directly to stdout and we're not capturing it in this test.\n        // In a real test, we'd use something like `std::io::Cursor` to capture the output.\n\n        // Instead, we'll just verify the function doesn't panic\n        // A more comprehensive test would use a crate like `rexpect` or modify\n        // spreadsheet_display to accept a writer parameter.\n\n        // For now, this test just ensures the function runs without panicking\n        assert!(true);\n    }\n\n    #[test]\n    fn test_spreadsheet_display_view_window() {\n        // Test the view window functionality of spreadsheet_display\n        let mut sheet = Spreadsheet::spreadsheet_create(20, 20).unwrap();\n\n        // Set up some cell values\n        for r in 1..=20 {\n            for c in 1..=20 {\n                let index = (r - 1) as usize * 20 + (c - 1) as usize;\n                if let Some(cell) = sheet.cells[index].as_mut() {\n                    cell.value = (r * 100 + c) as i32;\n                }\n            }\n        }\n\n        // Test default view (0,0)\n        assert_eq!(sheet.view_row, 0);\n        assert_eq!(sheet.view_col, 0);\n\n        // Change view window\n        sheet.view_row = 5;\n        sheet.view_col = 5;\n\n        // Call display - this just tests it doesn't crash\n        sheet.spreadsheet_display();\n\n        // The displayed cells should now start from row 6, col 6\n        // Verify view window state\n        assert_eq!(sheet.view_row, 5);\n        assert_eq!(sheet.view_col, 5);\n\n        // Test with view at the edge\n        sheet.view_row = 15; // Should show rows 16-20\n        sheet.view_col = 15; // Should show cols 16-20\n\n        // Call display\n        sheet.spreadsheet_display();\n\n        // Verify window state\n        assert_eq!(sheet.view_row, 15);\n        assert_eq!(sheet.view_col, 15);\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","bin","web.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse cop::app;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse command line arguments for rows and cols\n\n    let mut rows: i16 = 10;\n    let mut cols: i16 = 10;\n\n    // println!(\"Starting web server with spreadsheet of {} rows x {} columns\", rows, cols);\n    app::run(rows, cols).await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","cell.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::BTreeSet;\n\nuse crate::spreadsheet::ParsedRHS; // Using BTreeSet as an AVL-tree-like ordered collection\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Cell {\n    pub row: i16,\n    pub col: i16,\n    pub error: bool,\n    pub value: i32,\n    // pub formula: Option\u003cString\u003e,\n    pub formula: ParsedRHS,\n    pub dependents_initialised: i16,\n    pub dependents: Dependents,\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub enum Dependents {\n    Vector(Vec\u003c(i16, i16)\u003e),\n    Set(BTreeSet\u003c(i16, i16)\u003e),\n    None,\n}\n\nimpl Cell {\n    pub fn create(row: i16, col: i16) -\u003e Self {\n        Cell {\n            row,\n            col,\n            value: 0,\n            error: false,\n            formula: ParsedRHS::None,\n            dependents_initialised: 0,\n            dependents: Dependents::None,\n        }\n    }\n\n    pub fn dep_insert(\u0026mut self, row: i16, col: i16) {\n        // Set the initialised flag to 1 whenever a dependency is added\n        self.dependents_initialised = 1;\n        let key = (row, col);\n\n        match \u0026mut self.dependents {\n            Dependents::None =\u003e {\n                let v = vec![key];\n                self.dependents = Dependents::Vector(v);\n            }\n            Dependents::Vector(vec) =\u003e {\n                if vec.len() \u003e 7 {\n                    // Convert to OrderedSet\n                    let mut set = BTreeSet::new();\n                    for item in vec.iter() {\n                        set.insert(*item);\n                    }\n                    set.insert(key);\n                    self.dependents = Dependents::Set(set);\n                    // self.container = 1;\n                } else {\n                    vec.push(key);\n                }\n            }\n            Dependents::Set(set) =\u003e {\n                set.insert(key);\n            }\n        }\n    }\n\n    pub fn dep_remove(\u0026mut self, row: i16, col: i16) {\n        let key = (row, col);\n        match \u0026mut self.dependents {\n            Dependents::Vector(vec) =\u003e {\n                vec.retain(|k| k != \u0026key);\n            }\n            Dependents::Set(set) =\u003e {\n                set.remove(\u0026key);\n            }\n            Dependents::None =\u003e {}\n        }\n    }\n\n    pub fn contains(\u0026self, row: i16, col: i16) -\u003e bool {\n        if self.dependents_initialised == 0 {\n            return false;\n        }\n\n        let key = (row, col);\n        match \u0026self.dependents {\n            Dependents::Vector(vec) =\u003e vec.iter().any(|k| k == \u0026key),\n            Dependents::Set(set) =\u003e set.contains(\u0026key),\n            Dependents::None =\u003e false,\n        }\n    }\n}\n\n// Public interface functions that match the C API\npub fn cell_create(row: i16, col: i16) -\u003e Box\u003cCell\u003e {\n    Box::new(Cell::create(row, col))\n}\n\npub fn cell_dep_insert(cell: \u0026mut Cell, row: i16, col: i16) {\n    cell.dep_insert(row, col);\n}\n\npub fn cell_dep_remove(cell: \u0026mut Cell, row: i16, col: i16) {\n    cell.dep_remove(row, col);\n}\n\npub fn cell_contains(cell: \u0026Cell, row: i16, col: i16) -\u003e bool {\n    cell.contains(row, col)\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":18291331}},{"line":38,"address":[],"length":0,"stats":{"Line":206}},{"line":40,"address":[],"length":0,"stats":{"Line":206}},{"line":41,"address":[],"length":0,"stats":{"Line":206}},{"line":43,"address":[],"length":0,"stats":{"Line":206}},{"line":44,"address":[],"length":0,"stats":{"Line":51}},{"line":45,"address":[],"length":0,"stats":{"Line":51}},{"line":46,"address":[],"length":0,"stats":{"Line":51}},{"line":48,"address":[],"length":0,"stats":{"Line":154}},{"line":49,"address":[],"length":0,"stats":{"Line":154}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":51}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":151}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":75}},{"line":69,"address":[],"length":0,"stats":{"Line":75}},{"line":70,"address":[],"length":0,"stats":{"Line":75}},{"line":71,"address":[],"length":0,"stats":{"Line":63}},{"line":72,"address":[],"length":0,"stats":{"Line":256}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":38}},{"line":82,"address":[],"length":0,"stats":{"Line":38}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":38}},{"line":87,"address":[],"length":0,"stats":{"Line":38}},{"line":88,"address":[],"length":0,"stats":{"Line":32}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":18291331}},{"line":97,"address":[],"length":0,"stats":{"Line":18291331}},{"line":100,"address":[],"length":0,"stats":{"Line":206}},{"line":101,"address":[],"length":0,"stats":{"Line":206}},{"line":104,"address":[],"length":0,"stats":{"Line":75}},{"line":105,"address":[],"length":0,"stats":{"Line":75}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":42},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","downloader.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse crate::spreadsheet::Spreadsheet;\nuse std::error::Error;\n/// Convert spreadsheet to CSV format\npub fn to_csv(sheet: \u0026Spreadsheet) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n    let mut csv_content = String::new();\n\n    // Add header row with column letters\n    for c in 1..=sheet.cols {\n        if c \u003e 1 {\n            csv_content.push(',');\n        }\n        csv_content.push_str(\u0026column_to_letter(c as u16));\n    }\n    csv_content.push('\\n');\n\n    // Add data rows\n    for r in 1..=sheet.rows {\n        for c in 1..=sheet.cols {\n            if c \u003e 1 {\n                csv_content.push(',');\n            }\n\n            let index = ((r - 1) * sheet.cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                // Handle value - escape commas, quotes, newlines as needed\n                let value = cell.value.to_string();\n                if value.contains(',') || value.contains('\"') || value.contains('\\n') {\n                    let escaped = value.replace(\"\\\"\", \"\\\"\\\"\");\n                    csv_content.push_str(\u0026format!(\"\\\"{}\\\"\", escaped));\n                } else {\n                    csv_content.push_str(\u0026value);\n                }\n            }\n        }\n        csv_content.push('\\n');\n    }\n\n    Ok(csv_content)\n}\n\n/// Convert spreadsheet to XLSX format\npub fn to_xlsx(sheet: \u0026Spreadsheet) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn Error\u003e\u003e {\n    use rust_xlsxwriter::{Workbook, Worksheet};\n\n    // Create a new workbook and worksheet\n    let mut workbook = Workbook::new();\n    let mut worksheet = Worksheet::new();\n\n    // Add column headers\n    for c in 1..=sheet.cols {\n        worksheet.write_string(0, (c - 1) as u16, column_to_letter(c as u16))?;\n    }\n\n    // Add cell data\n    for r in 1..=sheet.rows {\n        for c in 1..=sheet.cols {\n            let index = ((r - 1) * sheet.cols + (c - 1)) as usize;\n            if let Some(cell) = \u0026sheet.cells[index] {\n                // Write cell value (using row+1 to account for header)\n                worksheet.write_number(r as u32, (c - 1) as u16, cell.value as f64)?;\n            }\n        }\n    }\n\n    workbook.push_worksheet(worksheet);\n\n    // Save to memory buffer - corrected method call\n    let buffer = workbook.save_to_buffer()?;\n\n    Ok(buffer)\n}\n\n// Helper function: Convert column number to letter (1=A, 2=B, etc.)\nfn column_to_letter(col: u16) -\u003e String {\n    let mut name = String::new();\n    let mut n = col;\n\n    while n \u003e 0 {\n        n -= 1;\n        name.insert(0, (b'A' + (n % 26) as u8) as char);\n        n /= 26;\n    }\n\n    name\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","graph.rs"],"content":"#![cfg(not(tarpaulin_include))]\nuse crate::spreadsheet::Spreadsheet;\nuse plotters::prelude::*;\nuse std::fs::remove_file;\n\n#[derive(Clone, Debug)]\n\npub enum GraphType {\n    Line,\n    Bar,\n    Scatter,\n    // Pie,\n    Area,\n}\n#[derive(Clone, Debug)]\npub struct GraphOptions {\n    pub title: String,\n    pub x_label: String,\n    pub y_label: String,\n    pub width: u32,\n    pub height: u32,\n    pub graph_type: GraphType,\n}\nimpl Default for GraphOptions {\n    fn default() -\u003e Self {\n        Self {\n            title: \"Graph\".to_string(),\n            x_label: \"X Axis\".to_string(),\n            y_label: \"Y Axis\".to_string(),\n            width: 800,\n            height: 600,\n            graph_type: GraphType::Line,\n        }\n    }\n}\n\n/// Creates a graph from spreadsheet data\n///\n/// # Arguments\n/// * `spreadsheet` - Reference to the spreadsheet\n/// * `x_range` - Range for X values (e.g., \"A1:A10\")\n/// * `y_range` - Range for Y values (e.g., \"B1:B10\")\n/// * `options` - Graph styling and type options\n///\n/// # Returns\n/// * A Result containing the PNG image data as bytes\npub fn create_graph(\n    spreadsheet: \u0026Spreadsheet,\n    x_range: \u0026str,\n    y_range: \u0026str,\n    options: GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Parse the ranges to get the actual cells\n    let (x_cells, y_cells) = parse_ranges(spreadsheet, x_range, y_range)?;\n\n    // Extract the data from the cells\n    let data: Vec\u003c(i32, i32)\u003e = x_cells\n        .iter()\n        .zip(y_cells.iter())\n        .map(|(x, y)| (*x, *y))\n        .collect();\n\n    match options.graph_type {\n        GraphType::Line =\u003e create_line_graph(data, \u0026options),\n        GraphType::Bar =\u003e create_bar_graph(data, \u0026options),\n        GraphType::Scatter =\u003e create_scatter_graph(data, \u0026options),\n        // GraphType::Pie =\u003e create_pie_graph(data, \u0026options),\n        GraphType::Area =\u003e create_area_graph(data, \u0026options),\n    }\n}\n\n/// Parses the range strings and returns the cell values\nfn parse_ranges(\n    spreadsheet: \u0026Spreadsheet,\n    x_range: \u0026str,\n    y_range: \u0026str,\n) -\u003e Result\u003c(Vec\u003ci32\u003e, Vec\u003ci32\u003e), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Split the range at the colon\n    let x_parts: Vec\u003c\u0026str\u003e = x_range.split(':').collect();\n    let y_parts: Vec\u003c\u0026str\u003e = y_range.split(':').collect();\n\n    if x_parts.len() != 2 || y_parts.len() != 2 {\n        return Err(\"Invalid range format. Expected format: A1:A10\".into());\n    }\n\n    // Parse the cell coordinates\n    let (x_start_row, x_start_col) = match spreadsheet.spreadsheet_parse_cell_name(x_parts[0]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid start cell in X range\".into()),\n    };\n\n    let (x_end_row, x_end_col) = match spreadsheet.spreadsheet_parse_cell_name(x_parts[1]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid end cell in X range\".into()),\n    };\n\n    let (y_start_row, y_start_col) = match spreadsheet.spreadsheet_parse_cell_name(y_parts[0]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid start cell in Y range\".into()),\n    };\n\n    let (y_end_row, y_end_col) = match spreadsheet.spreadsheet_parse_cell_name(y_parts[1]) {\n        Some(coords) =\u003e coords,\n        None =\u003e return Err(\"Invalid end cell in Y range\".into()),\n    };\n\n    // Ensure the ranges have the same length\n    let x_len = if x_start_col == x_end_col {\n        (x_end_row - x_start_row + 1) as usize\n    } else {\n        (x_end_col - x_start_col + 1) as usize\n    };\n\n    let y_len = if y_start_col == y_end_col {\n        (y_end_row - y_start_row + 1) as usize\n    } else {\n        (y_end_col - y_start_col + 1) as usize\n    };\n\n    if x_len != y_len {\n        return Err(\"X and Y ranges must have the same length\".into());\n    }\n\n    // Extract values\n    let mut x_values = Vec::with_capacity(x_len);\n    let mut y_values = Vec::with_capacity(y_len);\n\n    // Handle vertical ranges (same column)\n    if x_start_col == x_end_col {\n        for row in x_start_row..=x_end_row {\n            let index = ((row - 1) * spreadsheet.cols + (x_start_col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                x_values.push(cell.value);\n            } else {\n                x_values.push(0);\n            }\n        }\n    } else {\n        // Handle horizontal ranges (same row)\n        for col in x_start_col..=x_end_col {\n            let index = ((x_start_row - 1) * spreadsheet.cols + (col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                x_values.push(cell.value);\n            } else {\n                x_values.push(0);\n            }\n        }\n    }\n\n    // Do the same for Y values\n    if y_start_col == y_end_col {\n        for row in y_start_row..=y_end_row {\n            let index = ((row - 1) * spreadsheet.cols + (y_start_col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                y_values.push(cell.value);\n            } else {\n                y_values.push(0);\n            }\n        }\n    } else {\n        for col in y_start_col..=y_end_col {\n            let index = ((y_start_row - 1) * spreadsheet.cols + (col - 1)) as usize;\n            if let Some(cell) = \u0026spreadsheet.cells[index] {\n                y_values.push(cell.value);\n            } else {\n                y_values.push(0);\n            }\n        }\n    }\n\n    Ok((x_values, y_values))\n}\n\n// / Creates a line graph\nfn create_line_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        chart.draw_series(LineSeries::new(\n            data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            \u0026BLUE,\n        ))?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let mut file = std::fs::File::open(filename)?;\n    let mut buffer = Vec::new();\n    use std::io::Read;\n    file.read_to_end(\u0026mut buffer)?;\n    remove_file(filename)?;\n    Ok(buffer)\n}\n\n/// Saves a line graph to a file\nfn save_line_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    chart.draw_series(LineSeries::new(\n        data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n        \u0026RED,\n    ))?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates a bar graph\nfn create_bar_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x..*max_x + 1;\n        let y_range = 0..*max_y + 1;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        // Draw wider bars with solid fill and clear borders\n        chart.draw_series(\n            data.iter()\n                .map(|\u0026(x, y)| Rectangle::new([(x - 2, 0), (x + 2, y)], BLUE.filled())),\n        )?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let png_data = std::fs::read(filename)?;\n\n    // Clean up\n    remove_file(filename)?;\n\n    Ok(png_data)\n}\n\n/// Saves a bar graph to a file\nfn save_bar_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x..*max_x + 1;\n    let y_range = 0..*max_y + 1;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    chart.draw_series(data.iter().map(|\u0026(x, y)| {\n        Rectangle::new(\n            [((x as f64 - 0.4) as i32, 0), ((x as f64 + 0.4) as i32, y)],\n            BLUE.filled(),\n        )\n    }))?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates a scatter plot\nfn create_scatter_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range, y_range)?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        chart.draw_series(\n            data.iter()\n                .map(|\u0026(x, y)| Circle::new((x as f64, y as f64), 5, GREEN.filled())),\n        )?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let png_data = std::fs::read(filename)?;\n\n    // Clean up\n    remove_file(filename)?;\n\n    Ok(png_data)\n}\n\n/// Saves a scatter plot to a file\nfn save_scatter_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260);\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    chart.draw_series(\n        data.iter()\n            .map(|\u0026(x, y)| Circle::new((x as f64, y as f64), 5, GREEN.filled())),\n    )?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates an area graph\nfn create_area_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n) -\u003e Result\u003cVec\u003cu8\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create a temporary file-based bitmap solution\n    let filename = \"temp_graph.png\";\n    {\n        // Create a file-based bitmap backend\n        let root =\n            BitMapBackend::new(filename, (options.width, options.height)).into_drawing_area();\n        root.fill(\u0026WHITE)?;\n\n        let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n        let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n        let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260).min(\u00260); // Ensure we include 0\n        let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n        let x_range = *min_x as f64..*max_x as f64 + 1.0;\n        let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n        let mut chart = ChartBuilder::on(\u0026root)\n            .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n            .margin(10)\n            .x_label_area_size(30)\n            .y_label_area_size(40)\n            .build_cartesian_2d(x_range.clone(), y_range.clone())?;\n\n        chart\n            .configure_mesh()\n            .x_desc(\u0026options.x_label)\n            .y_desc(\u0026options.y_label)\n            .draw()?;\n\n        // Sort data by x to ensure proper area graph\n        let mut sorted_data = data.clone();\n        sorted_data.sort_by_key(|\u0026(x, _)| x);\n\n        use plotters::series::AreaSeries;\n        use plotters::style::RGBAColor;\n\n        // Draw the area graph\n        chart.draw_series(AreaSeries::new(\n            sorted_data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            0.0,\n            RGBAColor(30, 144, 255, 0.5), // semi-transparent blue\n        ))?;\n\n        root.present()?;\n    }\n\n    // Read the file directly\n    let mut file = std::fs::File::open(filename)?;\n    let mut buffer = Vec::new();\n    use std::io::Read;\n    file.read_to_end(\u0026mut buffer)?;\n    remove_file(filename)?;\n    Ok(buffer)\n}\n\n/// Saves an area graph to a file\nfn save_area_graph(\n    data: Vec\u003c(i32, i32)\u003e,\n    options: \u0026GraphOptions,\n    path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let root = BitMapBackend::new(path, (options.width, options.height)).into_drawing_area();\n    root.fill(\u0026WHITE)?;\n\n    let min_x = data.iter().map(|(x, _)| x).min().unwrap_or(\u00260);\n    let max_x = data.iter().map(|(x, _)| x).max().unwrap_or(\u0026100);\n    let min_y = data.iter().map(|(_, y)| y).min().unwrap_or(\u00260).min(\u00260); // Ensure we include 0\n    let max_y = data.iter().map(|(_, y)| y).max().unwrap_or(\u0026100);\n\n    let x_range = *min_x as f64..*max_x as f64 + 1.0;\n    let y_range = *min_y as f64..*max_y as f64 + 1.0;\n\n    let mut chart = ChartBuilder::on(\u0026root)\n        .caption(\u0026options.title, (\"sans-serif\", 30).into_font())\n        .margin(10)\n        .x_label_area_size(30)\n        .y_label_area_size(40)\n        .build_cartesian_2d(x_range, y_range)?;\n\n    chart\n        .configure_mesh()\n        .x_desc(\u0026options.x_label)\n        .y_desc(\u0026options.y_label)\n        .draw()?;\n\n    // Sort data by x to ensure proper area graph\n    let mut sorted_data = data.clone();\n    sorted_data.sort_by_key(|\u0026(x, _)| x);\n\n    chart.draw_series(\n        AreaSeries::new(\n            sorted_data.iter().map(|\u0026(x, y)| (x as f64, y as f64)),\n            0.0,\n            BLUE.mix(0.2),\n        )\n        .border_style(BLUE),\n    )?;\n\n    root.present()?;\n\n    Ok(())\n}\n\n/// Creates example graphs for demonstration purposes\n///\n/// # Returns\n/// * A vector of tuples containing graph type name and file path\npub fn create_example_graphs() -\u003e Vec\u003c(String, String)\u003e {\n    let mut result = Vec::new();\n\n    // Create output directory if it doesn't exist\n    let output_dir = \"graph_output\";\n    std::fs::create_dir_all(output_dir).unwrap_or_else(|_| {\n        eprintln!(\"Output directory already exists or couldn't be created\");\n    });\n\n    // Create sample data\n    let data: Vec\u003c(i32, i32)\u003e = vec![\n        (1, 10),\n        (2, 25),\n        (3, 15),\n        (4, 30),\n        (5, 22),\n        (6, 40),\n        (7, 35),\n    ];\n\n    // Standard options for all examples\n    let base_options = GraphOptions {\n        title: \"Example Graph\".to_string(),\n        x_label: \"X Values\".to_string(),\n        y_label: \"Y Values\".to_string(),\n        width: 600,\n        height: 400,\n        graph_type: GraphType::Line,\n    };\n\n    // Line graph\n    let mut line_options = base_options.clone();\n    line_options.title = \"Example Line Graph\".to_string();\n    line_options.graph_type = GraphType::Line;\n    let line_path = format!(\"{}/line_graph.png\", output_dir);\n    if save_line_graph(data.clone(), \u0026line_options, \u0026line_path).is_ok() {\n        result.push((\"Line\".to_string(), line_path));\n    }\n\n    // Bar graph\n    let mut bar_options = base_options.clone();\n    bar_options.title = \"Example Bar Graph\".to_string();\n    bar_options.graph_type = GraphType::Bar;\n    let bar_path = format!(\"{}/bar_graph.png\", output_dir);\n    if save_bar_graph(data.clone(), \u0026bar_options, \u0026bar_path).is_ok() {\n        result.push((\"Bar\".to_string(), bar_path));\n    }\n\n    // Scatter graph\n    let mut scatter_options = base_options.clone();\n    scatter_options.title = \"Example Scatter Graph\".to_string();\n    scatter_options.graph_type = GraphType::Scatter;\n    let scatter_path = format!(\"{}/scatter_graph.png\", output_dir);\n    if save_scatter_graph(data.clone(), \u0026scatter_options, \u0026scatter_path).is_ok() {\n        result.push((\"Scatter\".to_string(), scatter_path));\n    }\n\n    // Area graph\n    let mut area_options = base_options.clone();\n    area_options.title = \"Example Area Graph\".to_string();\n    area_options.graph_type = GraphType::Area;\n    let area_path = format!(\"{}/area_graph.png\", output_dir);\n    if save_area_graph(data.clone(), \u0026area_options, \u0026area_path).is_ok() {\n        result.push((\"Area\".to_string(), area_path));\n    }\n\n    result\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","lib.rs"],"content":"pub mod cell;\npub mod downloader;\npub mod graph;\npub mod login;\npub mod saving;\npub mod spreadsheet;\n\n// Only include app module when building with web feature\n#[cfg(feature = \"web\")]\npub mod app;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","login.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse argon2::{\n    Argon2,\n    password_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\n#[cfg(feature = \"web\")]\nuse axum::extract::FromRef;\n#[cfg(feature = \"web\")]\nuse axum::{\n    Form, Json,\n    extract::{Query, State},\n    http::{StatusCode, header},\n    response::{Html, IntoResponse, Redirect, Response},\n    routing::{get, post},\n};\n#[cfg(feature = \"web\")]\nuse axum_extra::extract::cookie::{Cookie, CookieJar};\nuse lazy_static::lazy_static;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs::{self, File, create_dir_all};\nuse std::io::{Read, Write};\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, RwLock};\nuse std::time::{Duration, SystemTime};\nuse uuid::Uuid;\n\n// User data structures\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct User {\n    pub username: String,\n    pub password_hash: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct UserCredentials {\n    pub username: String,\n    pub password: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct UserFile {\n    pub name: String,\n    pub path: String,\n    pub created: SystemTime,\n    pub modified: SystemTime,\n}\n\n// Session management\n#[derive(Debug, Clone)]\npub struct Session {\n    pub user_id: String,\n    pub expires_at: SystemTime,\n}\n\nlazy_static! {\n    static ref SESSIONS: RwLock\u003cHashMap\u003cString, Session\u003e\u003e = RwLock::new(HashMap::new());\n}\n\n// Constants\nconst USERS_FILE: \u0026str = \"database/users.json\";\nconst DATABASE_DIR: \u0026str = \"database\";\nconst SESSION_DURATION: u64 = 24 * 60 * 60; // 24 hours in seconds\n\n// Initialization function to ensure database structure exists\npub fn init_database() -\u003e std::io::Result\u003c()\u003e {\n    // Create database directory if it doesn't exist\n    if !Path::new(DATABASE_DIR).exists() {\n        create_dir_all(DATABASE_DIR)?;\n    }\n\n    // Create Admin folder\n    let admin_dir = Path::new(DATABASE_DIR).join(\"Admin\");\n    if !admin_dir.exists() {\n        create_dir_all(\u0026admin_dir)?;\n    }\n\n    // Create users.json if it doesn't exist\n    let users_path = Path::new(USERS_FILE);\n    if !users_path.exists() {\n        let mut file = File::create(users_path)?;\n        file.write_all(b\"{}\")?;\n    }\n\n    Ok(())\n}\n\n// User management functions\npub fn get_users() -\u003e Result\u003cHashMap\u003cString, User\u003e, String\u003e {\n    let mut file = match File::open(USERS_FILE) {\n        Ok(file) =\u003e file,\n        Err(_) =\u003e return Err(\"Failed to open users file\".to_string()),\n    };\n\n    let mut contents = String::new();\n    if file.read_to_string(\u0026mut contents).is_err() {\n        return Err(\"Failed to read users file\".to_string());\n    }\n\n    match serde_json::from_str(\u0026contents) {\n        Ok(users) =\u003e Ok(users),\n        Err(_) =\u003e Err(\"Failed to parse users data\".to_string()),\n    }\n}\n\npub fn save_users(users: \u0026HashMap\u003cString, User\u003e) -\u003e Result\u003c(), String\u003e {\n    let json = match serde_json::to_string_pretty(users) {\n        Ok(json) =\u003e json,\n        Err(_) =\u003e return Err(\"Failed to serialize users data\".to_string()),\n    };\n\n    let mut file = match File::create(USERS_FILE) {\n        Ok(file) =\u003e file,\n        Err(_) =\u003e return Err(\"Failed to create users file\".to_string()),\n    };\n\n    if file.write_all(json.as_bytes()).is_err() {\n        return Err(\"Failed to write users data\".to_string());\n    }\n\n    Ok(())\n}\n\n// Register a new user\npub fn register_user(username: \u0026str, password: \u0026str) -\u003e Result\u003c(), String\u003e {\n    if username.is_empty() || password.is_empty() {\n        return Err(\"Username and password cannot be empty\".to_string());\n    }\n\n    // Check if username already exists\n    let mut users = get_users()?;\n    if users.contains_key(username) {\n        return Err(\"Username already exists\".to_string());\n    }\n\n    // Hash the password\n    let password_hash = hash_password(password)?;\n\n    // Create user directory\n    let user_dir = Path::new(DATABASE_DIR).join(username);\n    if create_dir_all(\u0026user_dir).is_err() {\n        return Err(\"Failed to create user directory\".to_string());\n    }\n\n    // Add user to users.json\n    let user = User {\n        username: username.to_string(),\n        password_hash,\n    };\n\n    users.insert(username.to_string(), user);\n    save_users(\u0026users)?;\n\n    Ok(())\n}\n\n// Verify user credentials\npub fn verify_user(username: \u0026str, password: \u0026str) -\u003e Result\u003cbool, String\u003e {\n    let users = get_users()?;\n\n    if let Some(user) = users.get(username) {\n        verify_password(password, \u0026user.password_hash)\n    } else {\n        Ok(false)\n    }\n}\n\n// Password hashing functions\nfn hash_password(password: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n    let argon2 = Argon2::default();\n\n    match argon2.hash_password(password.as_bytes(), \u0026salt) {\n        Ok(hash) =\u003e Ok(hash.to_string()),\n        Err(_) =\u003e Err(\"Password hashing failed\".to_string()),\n    }\n}\n\nfn verify_password(password: \u0026str, hash: \u0026str) -\u003e Result\u003cbool, String\u003e {\n    let parsed_hash = match PasswordHash::new(hash) {\n        Ok(hash) =\u003e hash,\n        Err(_) =\u003e return Err(\"Invalid password hash format\".to_string()),\n    };\n\n    match Argon2::default().verify_password(password.as_bytes(), \u0026parsed_hash) {\n        Ok(_) =\u003e Ok(true),\n        Err(_) =\u003e Ok(false), // Password didn't match\n    }\n}\n\n// Session management\npub fn create_session(username: \u0026str) -\u003e String {\n    let session_id = Uuid::new_v4().to_string();\n    let expires_at = SystemTime::now() + Duration::from_secs(SESSION_DURATION);\n\n    let session = Session {\n        user_id: username.to_string(),\n        expires_at,\n    };\n\n    let mut sessions = SESSIONS.write().unwrap();\n    sessions.insert(session_id.clone(), session);\n\n    session_id\n}\n\npub fn validate_session(session_id: \u0026str) -\u003e Option\u003cString\u003e {\n    let sessions = SESSIONS.read().unwrap();\n\n    if let Some(session) = sessions.get(session_id) {\n        if session.expires_at \u003e SystemTime::now() {\n            return Some(session.user_id.clone());\n        }\n    }\n\n    None\n}\n\n// File management\npub fn get_user_files(username: \u0026str) -\u003e Vec\u003cUserFile\u003e {\n    let mut files = Vec::new();\n    let user_dir = Path::new(DATABASE_DIR).join(username);\n\n    if let Ok(entries) = fs::read_dir(user_dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_file() \u0026\u0026 path.extension().and_then(|ext| ext.to_str()) == Some(\"gz\") {\n                if let Some(filename) = path.file_name().and_then(|name| name.to_str()) {\n                    let metadata = match fs::metadata(\u0026path) {\n                        Ok(meta) =\u003e meta,\n                        Err(_) =\u003e continue, // Skip this file if we can't get metadata\n                    };\n                    let created = metadata.created().unwrap_or(SystemTime::now());\n                    let modified = metadata.modified().unwrap_or(SystemTime::now());\n\n                    files.push(UserFile {\n                        name: filename.to_string(),\n                        path: path.to_string_lossy().to_string(),\n                        created,\n                        modified,\n                    });\n                }\n            }\n        }\n    }\n\n    files\n}\n\n// Axum handler functions - only compiled when \"web\" feature is enabled\n#[cfg(feature = \"web\")]\npub async fn serve_login_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/login.html\"))\n}\n\n#[cfg(feature = \"web\")]\npub async fn serve_signup_page() -\u003e Html\u003c\u0026'static str\u003e {\n    Html(include_str!(\"./static/signup.html\"))\n}\n\n#[cfg(feature = \"web\")]\n#[axum::debug_handler]\npub async fn handle_login(jar: CookieJar, Form(credentials): Form\u003cUserCredentials\u003e) -\u003e Response {\n    match verify_user(\u0026credentials.username, \u0026credentials.password) {\n        Ok(true) =\u003e {\n            let session_id = create_session(\u0026credentials.username);\n            let cookie = Cookie::new(\"session\", session_id);\n            (\n                jar.add(cookie),\n                Redirect::to(\u0026format!(\"/{}\", credentials.username)),\n            )\n                .into_response()\n        }\n        Ok(false) =\u003e (StatusCode::UNAUTHORIZED, \"Invalid username or password\").into_response(),\n        Err(_) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, \"Authentication error\").into_response(),\n    }\n}\n\n#[cfg(feature = \"web\")]\npub async fn handle_signup(\n    Form(credentials): Form\u003cUserCredentials\u003e,\n) -\u003e Result\u003cRedirect, (StatusCode, String)\u003e {\n    match register_user(\u0026credentials.username, \u0026credentials.password) {\n        Ok(_) =\u003e Ok(Redirect::to(\"/login?registered=true\")),\n        Err(e) =\u003e Err((StatusCode::BAD_REQUEST, e)),\n    }\n}\n\n#[cfg(feature = \"web\")]\npub async fn handle_logout(jar: CookieJar) -\u003e (CookieJar, Redirect) {\n    // Remove session cookie\n    let cookie = Cookie::new(\"session\", \"\");\n\n    (jar.add(cookie), Redirect::to(\"/login\"))\n}\n\n// Middleware to check if user is authenticated\n#[cfg(feature = \"web\")]\npub async fn require_auth(\n    jar: CookieJar,\n    mut request: axum::extract::Request, // Remove generic parameter B\n    next: axum::middleware::Next,        // Remove generic parameter B\n) -\u003e Response {\n    // Check for session cookie\n    if let Some(session_cookie) = jar.get(\"session\") {\n        let session_id = session_cookie.value();\n\n        // Validate the session\n        if let Some(username) = validate_session(session_id) {\n            // Add username to request extensions\n            request.extensions_mut().insert(username);\n\n            // Continue with the request\n            return next.run(request).await;\n        }\n    }\n\n    // No valid session found, redirect to login\n    Redirect::to(\"/login\").into_response()\n}\n\n#[cfg(feature = \"web\")]\npub async fn list_files(\n    jar: CookieJar,\n    axum::extract::Path(username): axum::extract::Path\u003cString\u003e,\n) -\u003e Result\u003cHtml\u003cString\u003e, (StatusCode, \u0026'static str)\u003e {\n    // Verify user is authorized\n    if let Some(session_cookie) = jar.get(\"session\") {\n        if let Some(current_user) = validate_session(session_cookie.value()) {\n            // Check if the current user is trying to access their own files\n            if current_user == username {\n                let files = get_user_files(\u0026username);\n\n                // Generate HTML for file list\n                let mut html = String::from(\n                    \"\u003c!DOCTYPE html\u003e\n                \u003chtml\u003e\n                \u003chead\u003e\n                    \u003ctitle\u003eYour Files\u003c/title\u003e\n                    \u003cstyle\u003e\n                        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }\n                        h1 { color: #333; }\n                        .file-list { margin-top: 20px; }\n                        .file-item { \n                            padding: 10px; \n                            border: 1px solid #ddd; \n                            margin-bottom: 10px;\n                            border-radius: 4px;\n                        }\n                        .file-item:hover { background-color: #f5f5f5; }\n                        .file-link { \n                            text-decoration: none; \n                            color: #2196F3; \n                            font-weight: bold;\n                            display: block;\n                        }\n                        .file-info { \n                            color: #666; \n                            font-size: 0.8em;\n                            margin-top: 5px;\n                        }\n                        .new-sheet { \n                            display: inline-block;\n                            margin-top: 20px;\n                            padding: 10px 15px;\n                            background-color: #4CAF50;\n                            color: white;\n                            text-decoration: none;\n                            border-radius: 4px;\n                        }\n                        .logout {\n                            position: absolute;\n                            top: 20px;\n                            right: 20px;\n                            padding: 5px 10px;\n                            background-color: #f44336;\n                            color: white;\n                            text-decoration: none;\n                            border-radius: 4px;\n                        }\n                    \u003c/style\u003e\n                \u003c/head\u003e\n                \u003cbody\u003e\n                    \u003ca href='/logout' class='logout'\u003eLogout\u003c/a\u003e\n                    \u003ch1\u003eWelcome, \",\n                );\n\n                html.push_str(\u0026username);\n                html.push_str(\"\u003c/h1\u003e\");\n\n                if files.is_empty() {\n                    html.push_str(\"\u003cp\u003eYou don't have any spreadsheets yet.\u003c/p\u003e\");\n                } else {\n                    html.push_str(\"\u003cdiv class='file-list'\u003e\");\n                    html.push_str(\"\u003ch2\u003eYour Spreadsheets:\u003c/h2\u003e\");\n\n                    for file in files {\n                        let file_path = format!(\"/{}/{}\", username, file.name);\n                        html.push_str(\"\u003cdiv class='file-item'\u003e\");\n                        html.push_str(\u0026format!(\n                            \"\u003ca href='{}' class='file-link'\u003e{}\u003c/a\u003e\",\n                            file_path, file.name\n                        ));\n\n                        // Format timestamps\n                        let modified = chrono::DateTime::\u003cchrono::Utc\u003e::from(file.modified)\n                            .format(\"%Y-%m-%d %H:%M:%S\");\n\n                        html.push_str(\u0026format!(\n                            \"\u003cdiv class='file-info'\u003eLast modified: {}\u003c/div\u003e\",\n                            modified\n                        ));\n                        html.push_str(\"\u003c/div\u003e\");\n                    }\n\n                    html.push_str(\"\u003c/div\u003e\");\n                }\n\n                html.push_str(\n                    \"\u003ca href='/sheet?rows=10\u0026cols=10' class='new-sheet'\u003eCreate New Spreadsheet\u003c/a\u003e\",\n                );\n                html.push_str(\"\u003c/body\u003e\u003c/html\u003e\");\n\n                return Ok(Html(html));\n            }\n        }\n    }\n\n    Err((StatusCode::UNAUTHORIZED, \"Unauthorized\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","main.rs"],"content":"mod app;\nmod cell;\nmod graph;\nmod saving;\nmod spreadsheet;\n\nuse cop::spreadsheet::Spreadsheet;\n\n// use crate::spreadsheet::{Spreadsheet, Spreadsheet as SpreadsheetTrait};\nuse std::env;\nuse std::io::{self, Write};\n// use std::os::macos::raw::stat;\nuse std::time::Instant;\n\n// #[tokio::main]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let s = Instant::now(); // Start time for the entire program\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    // if args.len() \u003e 1 \u0026\u0026 args[1] == \"-dassi_nahi_to_rassi\" {\n    //     // Run the web application\n    //     let mut rows = 10;\n    //     let mut cols = 10;\n\n    //     if args.len() \u003e= 4 {\n    //         rows = args[2].parse().unwrap_or(10);\n    //         cols = args[3].parse().unwrap_or(10);\n    //     }\n\n    //     app::run(rows, cols).await?;\n    // } else {\n    // Run the spreadsheet functionality\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003crows\u003e \u003ccols\u003e\", args[0]);\n        return Ok(());\n    }\n\n    let rows: i32 = args[1].parse().unwrap_or(0);\n    let cols: i32 = args[2].parse().unwrap_or(0);\n\n    if rows \u003c 1 || rows \u003e 999 || cols \u003c 1 || cols \u003e 18278 {\n        eprintln!(\"Error: Invalid dimensions\");\n        return Ok(());\n    }\n\n    let mut start_time = Instant::now(); // Start time for the first command\n    let mut sheet = Spreadsheet::spreadsheet_create(rows, cols).unwrap();\n    let mut elapsed_time;\n    let mut status = String::from(\"ok\");\n    let mut show = true;\n    loop {\n        if show {\n            sheet.spreadsheet_display();\n        }\n\n        elapsed_time = start_time.elapsed().as_secs_f64(); // Calculate time since the last command\n        print!(\"[{:.1}] ({}) \u003e \", elapsed_time, status);\n        io::stdout().flush().unwrap();\n\n        let mut command = String::new();\n        if io::stdin().read_line(\u0026mut command).is_err() {\n            break;\n        }\n        let command = command.trim();\n\n        start_time = Instant::now(); // Reset the start time for the next command\n\n        if command.is_empty() {\n            status = String::from(\"invalid command\");\n            continue;\n        }\n\n        if command == \"help\" {\n            println!(\"Commands:\");\n            println!(\"  q: Quit\");\n            println!(\"  w: Move up\");\n            println!(\"  s: Move down\");\n            println!(\"  a: Move left\");\n            println!(\"  d: Move right\");\n            println!(\"  disable_output: Disable output display\");\n            println!(\"  enable_output: Enable output display\");\n            println!(\"  scroll_to \u003ccell\u003e: Scroll to the specified cell\");\n            println!(\"  \u003ccell\u003e=\u003cformula\u003e: Set the formula for the specified cell\");\n            continue;\n        }\n\n        if command == \"q\" {\n            break;\n        } else if command.len() == 1 \u0026\u0026 \"wasd\".contains(command) {\n            match command {\n                \"w\" if sheet.view_row \u003e 0 =\u003e {\n                    sheet.view_row = (sheet.view_row - 10).max(0);\n                }\n                \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                    sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n                }\n                \"a\" if sheet.view_col \u003e 0 =\u003e {\n                    sheet.view_col = (sheet.view_col - 10).max(0);\n                }\n                \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                    sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n                }\n                _ =\u003e {}\n            }\n            status = String::from(\"ok\");\n        } else if command == \"disable_output\" {\n            show = false;\n            status = String::from(\"ok\");\n        } else if command == \"enable_output\" {\n            show = true;\n            status = String::from(\"ok\");\n        } else if command.starts_with(\"scroll_to\") {\n            let cell_name = command[10..].trim();\n            if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n                sheet.view_row = row - 1;\n                sheet.view_col = col - 1;\n                status = String::from(\"ok\");\n            } else {\n                status = String::from(\"invalid cell\");\n            }\n        } else if let Some(equal_pos) = command.find('=') {\n            sheet.undo_stack.clear();\n            let cell_name = \u0026command[..equal_pos];\n            let formula = \u0026command[equal_pos + 1..];\n            if !sheet.is_valid_command(cell_name, formula) {\n                status = String::from(\"invalid command\");\n            } else {\n                sheet.spreadsheet_set_cell_value(cell_name, formula, \u0026mut status);\n            }\n        } else if command == \"UNDO\" {\n            if sheet.undo_stack.is_empty() {\n                status = String::from(\"no undo\");\n            } else if sheet.undo_stack.len() == 1 {\n                let (formula, row, col, value, err_state) = (\n                    sheet.undo_stack[0].0.clone(),\n                    sheet.undo_stack[0].1,\n                    sheet.undo_stack[0].2,\n                    sheet.undo_stack[0].3,\n                    sheet.undo_stack[0].4,\n                );\n                let cell_name = Spreadsheet::get_cell_name(row, col);\n                println!(\"Undoing: {} {} {} {}\", cell_name, row, col, value);\n                if let Some(formula) = formula {\n                    println!(\"Setting formula: {} {}\", cell_name, formula);\n                    sheet.undo_stack.clear();\n                    sheet.spreadsheet_set_cell_value(\u0026cell_name, \u0026formula, \u0026mut status);\n                } else {\n                    println!(\"Setting value: {} {}\", cell_name, value);\n                    sheet.spreadsheet_undo();\n                    status = String::from(\"ok\");\n                }\n            } else {\n                sheet.spreadsheet_undo();\n                status = String::from(\"ok\");\n            }\n        } else if command == \"REDO\" {\n            if sheet.redo_stack.is_empty() {\n                status = String::from(\"no redo\");\n            } else {\n                sheet.spreadsheet_redo();\n                status = String::from(\"ok\");\n            }\n        } else {\n            status = String::from(\"invalid command\");\n        }\n\n        // Update the start_time after processing the command\n        // start_time = Instant::now();\n    }\n    // }\n\n    let e = s.elapsed().as_secs_f64(); // Calculate total elapsed time\n    println!(\"Total elapsed time: {:.1} seconds\", e);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","new_main.rs"],"content":"mod app;\nmod cell;\nmod graph;\nmod saving;\nmod spreadsheet;\n\nuse cop::spreadsheet::Spreadsheet;\n\n// use crate::spreadsheet::{Spreadsheet, Spreadsheet as SpreadsheetTrait};\nuse std::env;\nuse std::io::{self, Write};\n// use std::os::macos::raw::stat;\nuse std::time::Instant;\n\n// #[tokio::main]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let s = Instant::now(); // Start time for the entire program\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    // if args.len() \u003e 1 \u0026\u0026 args[1] == \"-dassi_nahi_to_rassi\" {\n    //     // Run the web application\n    //     let mut rows = 10;\n    //     let mut cols = 10;\n\n    //     if args.len() \u003e= 4 {\n    //         rows = args[2].parse().unwrap_or(10);\n    //         cols = args[3].parse().unwrap_or(10);\n    //     }\n\n    //     app::run(rows, cols).await?;\n    // } else {\n    // Run the spreadsheet functionality\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003crows\u003e \u003ccols\u003e\", args[0]);\n        return Ok(());\n    }\n\n    let rows: i32 = args[1].parse().unwrap_or(0);\n    let cols: i32 = args[2].parse().unwrap_or(0);\n\n    if rows \u003c 1 || rows \u003e 999 || cols \u003c 1 || cols \u003e 18278 {\n        eprintln!(\"Error: Invalid dimensions\");\n        return Ok(());\n    }\n\n    let mut start_time = Instant::now(); // Start time for the first command\n    let mut sheet = Spreadsheet::spreadsheet_create(rows, cols).unwrap();\n    let mut elapsed_time;\n    let mut status = String::from(\"ok\");\n    let mut show = true;\n    loop {\n        if show {\n            sheet.spreadsheet_display();\n        }\n\n        elapsed_time = start_time.elapsed().as_secs_f64(); // Calculate time since the last command\n        print!(\"[{:.1}] ({}) \u003e \", elapsed_time, status);\n        io::stdout().flush().unwrap();\n\n        let mut command = String::new();\n        if io::stdin().read_line(\u0026mut command).is_err() {\n            break;\n        }\n        let command = command.trim();\n\n        start_time = Instant::now(); // Reset the start time for the next command\n\n        if command.is_empty() {\n            status = String::from(\"invalid command\");\n            continue;\n        }\n\n        if command == \"help\" {\n            println!(\"Commands:\");\n            println!(\"  q: Quit\");\n            println!(\"  w: Move up\");\n            println!(\"  s: Move down\");\n            println!(\"  a: Move left\");\n            println!(\"  d: Move right\");\n            println!(\"  disable_output: Disable output display\");\n            println!(\"  enable_output: Enable output display\");\n            println!(\"  scroll_to \u003ccell\u003e: Scroll to the specified cell\");\n            println!(\"  \u003ccell\u003e=\u003cformula\u003e: Set the formula for the specified cell\");\n            continue;\n        }\n\n        if command == \"q\" {\n            break;\n        } else if command.len() == 1 \u0026\u0026 \"wasd\".contains(command) {\n            match command {\n                \"w\" if sheet.view_row \u003e 0 =\u003e {\n                    sheet.view_row = (sheet.view_row - 10).max(0);\n                }\n                \"s\" if sheet.view_row \u003c sheet.rows - 10 =\u003e {\n                    sheet.view_row = (sheet.view_row + 10).min(sheet.rows - 10);\n                }\n                \"a\" if sheet.view_col \u003e 0 =\u003e {\n                    sheet.view_col = (sheet.view_col - 10).max(0);\n                }\n                \"d\" if sheet.view_col \u003c sheet.cols - 10 =\u003e {\n                    sheet.view_col = (sheet.view_col + 10).min(sheet.cols - 10);\n                }\n                _ =\u003e {}\n            }\n            status = String::from(\"ok\");\n        } else if command == \"disable_output\" {\n            show = false;\n            status = String::from(\"ok\");\n        } else if command == \"enable_output\" {\n            show = true;\n            status = String::from(\"ok\");\n        } else if command.starts_with(\"scroll_to\") {\n            let cell_name = command[10..].trim();\n            if let Some((row, col)) = sheet.spreadsheet_parse_cell_name(cell_name) {\n                sheet.view_row = row - 1;\n                sheet.view_col = col - 1;\n                status = String::from(\"ok\");\n            } else {\n                status = String::from(\"invalid cell\");\n            }\n        } else if let Some(equal_pos) = command.find('=') {\n            sheet.undo_stack.clear();\n            let cell_name = \u0026command[..equal_pos];\n            let formula = \u0026command[equal_pos + 1..];\n            if !sheet.is_valid_command(cell_name, formula) {\n                status = String::from(\"invalid command\");\n            } else {\n                sheet.spreadsheet_set_cell_value(cell_name, formula, \u0026mut status);\n            }\n        } else if command == \"UNDO\" {\n            if sheet.undo_stack.is_empty() {\n                status = String::from(\"no undo\");\n            } else if sheet.undo_stack.len() == 1 {\n                let (formula, row, col, value, err_state) = (\n                    sheet.undo_stack[0].0.clone(),\n                    sheet.undo_stack[0].1,\n                    sheet.undo_stack[0].2,\n                    sheet.undo_stack[0].3,\n                    sheet.undo_stack[0].4,\n                );\n                let cell_name = Spreadsheet::get_cell_name(row, col);\n                println!(\"Undoing: {} {} {} {}\", cell_name, row, col, value);\n                if let Some(formula) = formula {\n                    println!(\"Setting formula: {} {}\", cell_name, formula);\n                    sheet.undo_stack.clear();\n                    sheet.spreadsheet_set_cell_value(\u0026cell_name, \u0026formula, \u0026mut status);\n                } else {\n                    println!(\"Setting value: {} {}\", cell_name, value);\n                    sheet.spreadsheet_undo();\n                    status = String::from(\"ok\");\n                }\n            } else {\n                sheet.spreadsheet_undo();\n                status = String::from(\"ok\");\n            }\n        } else if command == \"REDO\" {\n            if sheet.redo_stack.is_empty() {\n                status = String::from(\"no redo\");\n            } else {\n                sheet.spreadsheet_redo();\n                status = String::from(\"ok\");\n            }\n        } else {\n            status = String::from(\"invalid command\");\n        }\n\n        // Update the start_time after processing the command\n        // start_time = Instant::now();\n    }\n    // }\n\n    let e = s.elapsed().as_secs_f64(); // Calculate total elapsed time\n    println!(\"Total elapsed time: {:.1} seconds\", e);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","saving.rs"],"content":"#![cfg(not(tarpaulin_include))]\n\nuse bincode::{deserialize_from, serialize_into};\nuse flate2::Compression;\nuse flate2::read::GzDecoder;\nuse flate2::write::GzEncoder;\nuse std::fs::File;\n\nuse crate::spreadsheet::Spreadsheet;\n\npub fn save_spreadsheet(spreadsheet: \u0026Spreadsheet, filename: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n    let file = File::create(filename)?;\n    let encoder = GzEncoder::new(file, Compression::default());\n    let mut writer = std::io::BufWriter::new(encoder);\n\n    serialize_into(\u0026mut writer, spreadsheet)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;\n\n    Ok(())\n}\n\npub fn load_spreadsheet(filename: \u0026str) -\u003e std::io::Result\u003cSpreadsheet\u003e {\n    let file = File::open(filename)?;\n    let decoder = GzDecoder::new(file);\n    let mut reader = std::io::BufReader::new(decoder);\n\n    let spreadsheet: Spreadsheet = deserialize_from(\u0026mut reader)\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n    Ok(spreadsheet)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","Admin","Library","Mobile Documents","com~apple~CloudDocs","Shivankur","2. IIT Delhi","Sem 4","COP290","Assignment 2_Rust Lab","cop","src","spreadsheet.rs"],"content":"use crate::cell::{Cell, cell_create};\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeSet;\n// use std::time::Instant;\nuse lazy_static::lazy_static;\nuse regex::Regex;\n\n// Pre-compile regex patterns\nlazy_static! {\n    static ref FUNC_REGEX: Regex = Regex::new(r\"^([A-Za-z]+)\\((.*)\\)$\").unwrap();\n    static ref ARITH_EXPR_REGEX: Regex = Regex::new(\n        r\"^(([+-]?[0-9]+)|([A-Za-z]+[0-9]+))([+\\-*/])(([+-]?[0-9]+)|([A-Za-z]+[0-9]+))$\"\n    )\n    .unwrap();\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\npub struct Spreadsheet {\n    pub rows: i16,\n    pub cols: i16,\n    pub view_row: i16,\n    pub view_col: i16,\n    pub cells: Vec\u003cOption\u003cBox\u003cCell\u003e\u003e\u003e,\n    pub undo_stack: Vec\u003c(ParsedRHS, i16, i16)\u003e,\n    // pub cells: Vec\u003cVec\u003cOption\u003cCell\u003e\u003e\u003e,\n}\n\n#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, PartialEq)]\npub enum ParsedRHS {\n    Function {\n        name: FunctionName,\n        args: (Operand, Operand), // now each arg can be a cell (row, col) or number\n    },\n    Sleep(Operand),\n    Arithmetic {\n        lhs: Operand,\n        operator: char,\n        rhs: Operand,\n    },\n    SingleValue(Operand),\n    None,\n}\n\n#[derive(Clone, serde::Serialize, serde::Deserialize, Debug, PartialEq)]\npub enum Operand {\n    Number(i32),\n    Cell(i16, i16), // (row, col)\n}\n\n#[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]\npub enum FunctionName {\n    Min,\n    Max,\n    Avg,\n    Sum,\n    Stdev,\n    Cut,\n    Copy,\n}\n\nimpl FunctionName {\n    pub fn from_strng(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name.to_uppercase().as_str() {\n            \"MIN\" =\u003e Some(FunctionName::Min),\n            \"MAX\" =\u003e Some(FunctionName::Max),\n            \"AVG\" =\u003e Some(FunctionName::Avg),\n            \"SUM\" =\u003e Some(FunctionName::Sum),\n            \"STDEV\" =\u003e Some(FunctionName::Stdev),\n            \"COPY\" =\u003e Some(FunctionName::Copy),\n            _ =\u003e None,\n        }\n    }\n    pub fn is_copy(\u0026self) -\u003e bool {\n        matches!(self, FunctionName::Copy)\n    }\n}\n\nimpl Spreadsheet {\n    pub fn spreadsheet_create(rows: i16, cols: i16) -\u003e Option\u003cBox\u003cSelf\u003e\u003e {\n        // eprintln!(\"Creating spreadsheet with {} rows and {} columns\", rows, cols);\n        let mut sheet = Box::new(Spreadsheet {\n            rows,\n            cols,\n            view_row: 0,\n            view_col: 0,\n            cells: Vec::with_capacity(rows as usize * cols as usize),\n            undo_stack: Vec::new(),\n        });\n\n        // Initialize the vector with None values\n        for _ in 0..(rows as usize * cols as usize) {\n            sheet.cells.push(None);\n        }\n\n        for r in 1..=rows {\n            for c in 1..=cols {\n                let index = ((r - 1) as usize) * (cols as usize) + ((c - 1) as usize);\n                sheet.cells[index] = Some(cell_create(r, c));\n            }\n        }\n\n        Some(sheet)\n    }\n\n    pub fn col_to_letter(col: i16) -\u003e String {\n        let mut col = col;\n        let mut result = String::new();\n        while col \u003e 0 {\n            col -= 1;\n            result.push(((col % 26) as u8 + b'A') as char);\n            col /= 26;\n        }\n        result.chars().rev().collect()\n    }\n\n    pub fn letter_to_col(letters: \u0026str) -\u003e i16 {\n        letters\n            .chars()\n            .fold(0, |acc, c| acc * 26 + (c as i16 - 'A' as i16 + 1))\n    }\n\n    pub fn get_cell_name(row: i16, col: i16) -\u003e String {\n        format!(\"{}{}\", Self::col_to_letter(col), row)\n    }\n\n    pub fn spreadsheet_parse_cell_name(\u0026self, cell_name: \u0026str) -\u003e Option\u003c(i16, i16)\u003e {\n        let mut letters = String::new();\n        let mut digits = String::new();\n        let mut found_digit = false;\n\n        for c in cell_name.chars() {\n            if c.is_ascii_alphabetic() {\n                // Once we've seen a digit, we shouldn't see more letters\n                if found_digit {\n                    return None;\n                }\n                letters.push(c);\n            } else if c.is_ascii_digit() {\n                found_digit = true;\n                digits.push(c);\n            } else {\n                return None;\n            }\n        }\n\n        if letters.is_empty() || digits.is_empty() {\n            return None;\n        }\n\n        let col = Self::letter_to_col(\u0026letters);\n        let row = digits.parse::\u003ci16\u003e().ok()?;\n\n        if col \u003e self.cols || row \u003e self.rows || row == 0 {\n            return None;\n        }\n        Some((row, col))\n    }\n\n    pub fn is_numeric(s: \u0026str) -\u003e bool {\n        !s.is_empty() \u0026\u0026 s.chars().all(|c| c.is_ascii_digit())\n    }\n\n    pub fn spreadsheet_evaluate_expression(\n        \u0026self,\n        expr: \u0026ParsedRHS,\n        _row: i16,\n        _col: i16,\n    ) -\u003e (i32, bool) {\n        match expr {\n            ParsedRHS::Function { name, args } =\u003e {\n                let mut error = false;\n                // Handle function evaluation here\n                let (arg1, arg2) = args;\n                // arg1 nd arg2 would be Operand cell type from there extract r1,c1 and r2,c2\n                let (r1, c1) = match arg1 {\n                    Operand::Cell(r, c) =\u003e (*r, *c),\n                    Operand::Number(_) =\u003e (0, 0), // Placeholder\n                };\n                let (r2, c2) = match arg2 {\n                    Operand::Cell(r, c) =\u003e (*r, *c),\n                    Operand::Number(_) =\u003e (0, 0), // Placeholder\n                };\n                // Call the appropriate function based on the name\n                // For now, just return a dummy value\n                // let r1 = r1 + 1;\n                // let r2 = r2 + 1;\n                // println!(\"{},{}\",r1,r2);\n                // new comment\n\n                let count = (r2 - r1 + 1) as usize * (c2 - c1 + 1) as usize;\n                let mut values = Vec::with_capacity(count);\n\n                for i in r1..=r2 {\n                    for j in c1..=c2 {\n                        let index = (i - 1) as usize * self.cols as usize + (j - 1) as usize;\n                        if index \u003c self.cells.len() {\n                            if let Some(ref c) = self.cells[index] {\n                                if c.error {\n                                    // cell.error = true;\n                                    error = true;\n                                    return (0, error);\n                                }\n                                // println!(\"{},c.value\", c.value);\n                                values.push(c.value);\n                            } else {\n                                values.push(0);\n                            }\n                        }\n                    }\n                }\n\n                match name {\n                    FunctionName::Min =\u003e {\n                        if values.is_empty() {\n                            return (0, error);\n                        }\n                        // cell.error = false;\n                        error = false;\n                        return (*values.iter().min().unwrap_or(\u00260), error);\n                    }\n                    FunctionName::Max =\u003e {\n                        if values.is_empty() {\n                            return (0, error);\n                        }\n                        // cell.error = false;\n                        error = false;\n                        return (*values.iter().max().unwrap_or(\u00260), error);\n                    }\n                    FunctionName::Sum =\u003e {\n                        // cell.error = false;\n                        // println!(\"Sum: {:?}\", values);\n                        error = false;\n                        return (values.iter().sum(), error);\n                    }\n                    FunctionName::Avg =\u003e {\n                        if values.is_empty() {\n                            return (0, error);\n                        }\n                        // cell.error = false;\n                        error = false;\n                        let sum: i32 = values.iter().sum();\n                        return (sum / values.len() as i32, error);\n                    }\n                    FunctionName::Stdev =\u003e {\n                        if values.len() \u003c 2 {\n                            return (0, error);\n                        }\n\n                        let mean = values.iter().sum::\u003ci32\u003e() as f64 / values.len() as f64;\n                        let variance = values\n                            .iter()\n                            .map(|\u0026x| {\n                                let diff = x as f64 - mean;\n                                diff * diff\n                            })\n                            .sum::\u003cf64\u003e()\n                            / values.len() as f64;\n\n                        // cell.error = false;\n                        error = false;\n                        return ((variance.sqrt().round()) as i32, error);\n                    }\n                    _ =\u003e {}\n                }\n\n                (0, error)\n            }\n            ParsedRHS::Sleep(op) =\u003e {\n                // Handle sleep function here\n                let val;\n                let error = false;\n\n                match op {\n                    Operand::Number(n) =\u003e {\n                        // Just a direct number: no error\n                        val = *n;\n                    }\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        if let Some(cell) = self.cells.get(index).and_then(|c| c.as_ref()) {\n                            val = cell.value;\n                            if cell.error {\n                                return (val, true);\n                            }\n                        } else {\n                            // Uninitialized cell → default to 0\n                            val = 0;\n                        }\n                    }\n                }\n\n                // Sleep if val \u003e 0\n                if val \u003e 0 {\n                    std::thread::sleep(std::time::Duration::from_secs(val as u64));\n                }\n\n                (val, error)\n            }\n            ParsedRHS::Arithmetic { lhs, operator, rhs } =\u003e {\n                let (lhs_val, lhs_err) = match lhs {\n                    Operand::Number(n) =\u003e (*n, false),\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        self.cells[index]\n                            .as_ref()\n                            .map_or((0, true), |cell| (cell.value, cell.error))\n                    }\n                };\n\n                let (rhs_val, rhs_err) = match rhs {\n                    Operand::Number(n) =\u003e (*n, false),\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        self.cells[index]\n                            .as_ref()\n                            .map_or((0, true), |cell| (cell.value, cell.error))\n                    }\n                };\n\n                // Combine error flags\n                let mut has_error = lhs_err || rhs_err;\n\n                // Compute result\n                let result = match operator {\n                    '+' =\u003e lhs_val + rhs_val,\n                    '-' =\u003e lhs_val - rhs_val,\n                    '*' =\u003e lhs_val * rhs_val,\n                    '/' =\u003e {\n                        if rhs_val == 0 {\n                            has_error = true;\n                            0 // or some default value\n                        } else {\n                            lhs_val / rhs_val\n                        }\n                    }\n                    _ =\u003e {\n                        has_error = true;\n                        0\n                    }\n                };\n\n                (result, has_error)\n            }\n\n            ParsedRHS::SingleValue(num) =\u003e {\n                // Handle single value expression here\n                match num {\n                    Operand::Cell(r, c) =\u003e {\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        self.cells[index]\n                            .as_ref()\n                            .map_or((0, false), |cell| (cell.value, cell.error))\n                    }\n                    Operand::Number(x) =\u003e (*x, false),\n                }\n            }\n            ParsedRHS::None =\u003e {\n                // No expression to evaluate\n                (0, false)\n            }\n        }\n    }\n\n    pub fn rec_find_cycle_using_stack\u003c'a\u003e(\n        \u0026'a self,\n        (r1, r2): (i16, i16),\n        (c1, c2): (i16, i16),\n        range_bool: bool,\n        visited: \u0026mut BTreeSet\u003c(i16, i16)\u003e,\n        stack: \u0026mut Vec\u003c\u0026'a Cell\u003e,\n    ) -\u003e bool {\n        while let Some(my_node) = stack.pop() {\n            // Generate cell name for the current node\n            // let cell_name = Self::get_cell_name(my_node.row as i32, my_node.col as i32);\n\n            // Check if we've already visited this cell\n            if visited.contains(\u0026(my_node.row, my_node.col)) {\n                continue; // Skip cells we've already processed\n            }\n\n            // Mark as visited\n            visited.insert((my_node.row, my_node.col));\n\n            // Check if the cell is part of the target range\n            let in_range = if range_bool {\n                // For range functions (SUM, AVG, etc.)\n                my_node.row \u003e= r1 \u0026\u0026 my_node.row \u003c= r2 \u0026\u0026 my_node.col \u003e= c1 \u0026\u0026 my_node.col \u003c= c2\n            } else {\n                // For direct cell references\n                (my_node.row == r1 \u0026\u0026 my_node.col == c1) || (my_node.row == r2 \u0026\u0026 my_node.col == c2)\n            };\n\n            if in_range {\n                // Cycle detected\n                return true;\n            } else {\n                // Check all dependent cells using our helper method\n                let dependent_names = self.get_dependent_names(my_node);\n                // println!(\"Dependent names: {:?}\", dependent_names);\n                // println!(\"Visited: {:?}\", visited);\n                for dependent_name in \u0026dependent_names {\n                    if !visited.contains(dependent_name) {\n                        let r = dependent_name.0;\n                        let c = dependent_name.1;\n                        let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n                        if index \u003c self.cells.len() {\n                            if let Some(ref neighbor_node) = self.cells[index] {\n                                stack.push(neighbor_node);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // No cycle found\n        false\n    }\n\n    // Helper method for the rec_find_cycle_using_stack function - simplifies dependent collection\n    pub fn get_dependent_names(\u0026self, cell: \u0026Cell) -\u003e Vec\u003c(i16, i16)\u003e {\n        match \u0026cell.dependents {\n            crate::cell::Dependents::Vector(vec) =\u003e vec.clone(),\n            crate::cell::Dependents::Set(set) =\u003e set.iter().cloned().collect(),\n            crate::cell::Dependents::None =\u003e Vec::new(),\n        }\n    }\n\n    // Entry point for cycle detection - checks if a given cell could create a cycle\n    pub fn first_step_find_cycle(\n        \u0026self,\n        (r_, c_): (i16, i16),\n        (r1, c1): (i16, i16),\n        (r2, c2): (i16, i16),\n        range_bool: bool,\n    ) -\u003e bool {\n        // Parse the cell name to get row and column indices\n        // let (r_, c_) = match self.spreadsheet_parse_cell_name(cell_name) {\n        //     Some(coords) =\u003e coords,\n        //     None =\u003e return false, // Invalid cell name\n        // };\n\n        // Get the index of the cell in the flattened vector\n        let index = (r_ - 1) as usize * self.cols as usize + (c_ - 1) as usize;\n\n        // Get the cell from the spreadsheet\n        let start_node = match \u0026self.cells[index] {\n            Some(cell) =\u003e cell,\n            None =\u003e return false, // Cell doesn't exist\n        };\n\n        // Create a visited set and stack for cycle detection\n        let mut visited = BTreeSet::new();\n        let mut stack = vec![\u0026**start_node];\n\n        // Call the recursive helper to find cycles\n        self.rec_find_cycle_using_stack((r1, r2), (c1, c2), range_bool, \u0026mut visited, \u0026mut stack)\n    }\n\n    pub fn remove_old_dependents(\u0026mut self, r: i16, c: i16) {\n        // Get formula from the cell we're updating\n        let formula = {\n            let index = (r - 1) as usize * self.cols as usize + (c - 1) as usize;\n            if let Some(curr_cell) = self.cells.get(index).and_then(|opt| opt.as_ref()) {\n                curr_cell.formula.clone()\n            } else {\n                ParsedRHS::None\n            }\n        };\n\n        match formula {\n            ParsedRHS::Function { name, args } =\u003e {\n                if !name.is_copy() {\n                    let (arg1, arg2) = args;\n                    // Get the range of cells we depend on\n                    let (start_row, start_col) = match arg1 {\n                        Operand::Cell(row, col) =\u003e (row, col),\n                        Operand::Number(_) =\u003e (0, 0), // Placeholder\n                    };\n                    let (end_row, end_col) = match arg2 {\n                        Operand::Cell(row, col) =\u003e (row, col),\n                        Operand::Number(_) =\u003e (0, 0), // Placeholder\n                    };\n\n                    // Remove our cell as a dependent from each cell in the range\n                    for dep_r in start_row..=end_row {\n                        for dep_c in start_col..=end_col {\n                            let dep_index =\n                                (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                            if let Some(dep_cell) =\n                                self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut())\n                            {\n                                // Pass r, c (our cell) to remove as a dependent\n                                crate::cell::cell_dep_remove(dep_cell, r, c);\n                            }\n                        }\n                    }\n                }\n            }\n            // Other patterns with the same fix...\n            ParsedRHS::Arithmetic {\n                lhs,\n                operator: _,\n                rhs,\n            } =\u003e {\n                // Handle the left operand\n                if let Operand::Cell(dep_r, dep_c) = lhs {\n                    let dep_index =\n                        (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                    if let Some(dep_cell) =\n                        self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut())\n                    {\n                        crate::cell::cell_dep_remove(dep_cell, r, c);\n                    }\n                }\n                // Handle the right operand\n                if let Operand::Cell(dep_r, dep_c) = rhs {\n                    let dep_index =\n                        (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                    if let Some(dep_cell) =\n                        self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut())\n                    {\n                        crate::cell::cell_dep_remove(dep_cell, r, c);\n                    }\n                }\n            }\n            // Handle single value case too\n            ParsedRHS::SingleValue(Operand::Cell(dep_r, dep_c)) =\u003e {\n                let dep_index = (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                if let Some(dep_cell) = self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut()) {\n                    crate::cell::cell_dep_remove(dep_cell, r, c);\n                }\n            }\n            ParsedRHS::Sleep(Operand::Cell(dep_r, dep_c)) =\u003e {\n                let dep_index = (dep_r - 1) as usize * self.cols as usize + (dep_c - 1) as usize;\n\n                if let Some(dep_cell) = self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut()) {\n                    crate::cell::cell_dep_remove(dep_cell, r, c);\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    pub fn update_dependencies(\n        \u0026mut self,\n        (r, c): (i16, i16),\n        (start_row, start_col): (i16, i16),\n        (end_row, end_col): (i16, i16),\n        is_range: bool,\n    ) -\u003e i32 {\n        // eprintln!(\"Entered update_dependencies for cell: {cell_name} with formula: {formula}\");\n        // First, parse the cell—this mirrors C obtaining the current cell coordinates.\n        // let (r, c) = self.spreadsheet_parse_cell_name(cell_name).unwrap();\n\n        // Remove old dependencies\n        self.remove_old_dependents(r, c);\n        // Add the new formula to the cell\n        // if let Some(cell) = self.cells.get_mut(index).and_then(|opt| opt.as_mut()) {\n        //     cell.formula = Some(formula.to_string());\n        // }\n        // Now, process the formula to update dependencies.\n\n        if is_range {\n            let r1 = start_row - 1;\n            let r2 = end_row - 1;\n\n            // Check validity as in the C code:\n            if end_col \u003c start_col || (start_col == end_col \u0026\u0026 r2 \u003c r1) {\n                return -1;\n            }\n\n            // Iterate over the range and update dependencies.\n            for r_it in start_row..=end_row {\n                for c_it in start_col..=end_col {\n                    let dep_index = (r_it - 1) as usize * self.cols as usize + (c_it - 1) as usize;\n                    if let Some(dep_cell) =\n                        self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut())\n                    {\n                        crate::cell::cell_dep_insert(dep_cell, r, c);\n                    }\n                }\n            }\n        } else {\n            if start_row \u003e 0 {\n                let dep_index =\n                    (start_row - 1) as usize * self.cols as usize + (start_col - 1) as usize;\n                if let Some(dep_cell) = self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut()) {\n                    crate::cell::cell_dep_insert(dep_cell, r, c);\n                }\n            }\n            if end_row \u003e 0 {\n                let dep_index =\n                    (end_row - 1) as usize * self.cols as usize + (end_col - 1) as usize;\n                if let Some(dep_cell) = self.cells.get_mut(dep_index).and_then(|opt| opt.as_mut()) {\n                    crate::cell::cell_dep_insert(dep_cell, r, c);\n                }\n            }\n        }\n        0\n    }\n\n    pub fn topo_sort(\u0026self, starting: \u0026Cell) -\u003e Box\u003cVec\u003c(i16, i16)\u003e\u003e {\n        // Create an empty result vector (equivalent to Node_l *head = NULL)\n        let mut sorted_nodes = Box::new(Vec::new());\n\n        // Create a stack for DFS traversal (equivalent to Node *st_top)\n        let mut stack = Box::new(Vec::new());\n        stack.push(starting.clone());\n\n        // Track visited cells using a BTreeSet (equivalent to OrderedSet *visited)\n        let mut visited = Box::new(BTreeSet::new());\n\n        // Working stack to simulate recursive DFS with explicit stack\n        let mut work_stack = Box::new(Vec::new());\n        work_stack.push(Box::new((starting.row, starting.col)));\n\n        while let Some(current) = work_stack.pop() {\n            let current = *current;\n            // println!(\"Current cell: {:?}\", current);\n            // Generate cell name for the current node\n            // let cell_name = Self::get_cell_name(current.row, current.col);\n\n            // If we've already processed this cell, skip it\n            if visited.contains(\u0026current) {\n                continue;\n            }\n\n            // Get dependents of current cell\n            let index = (current.0 - 1) as usize * self.cols as usize + (current.1 - 1) as usize;\n            if let Some(cell) = self.cells.get(index).and_then(|opt| opt.as_ref()) {\n                let dependent_keys = self.get_dependent_names(cell);\n                let mut all_dependents_visited = true;\n\n                // Check if all dependents are visited\n                for dep_key in \u0026dependent_keys {\n                    if !visited.contains(dep_key) {\n                        // If we have an unvisited dependent, we need to process it first\n                        // if let Some((r, c)) = self.spreadsheet_parse_cell_name(dep_key) {\n                        let (r, c) = *dep_key;\n\n                        // Push current cell back to work stack\n                        work_stack.push(Box::new(current));\n                        // Push dependent to work stack to process first\n                        work_stack.push(Box::new((r, c)));\n                        all_dependents_visited = false;\n                        break;\n                    }\n                }\n\n                // If all dependents are visited, we can add this cell to sorted result\n                if all_dependents_visited {\n                    visited.insert(current);\n                    sorted_nodes.push(current);\n                }\n            }\n        }\n\n        // Reverse result to match original C implementation order\n        sorted_nodes.reverse();\n        sorted_nodes\n    }\n\n    pub fn spreadsheet_set_cell_value(\n        \u0026mut self,\n        row: i16,\n        col: i16,\n        rhs: ParsedRHS,\n        status_out: \u0026mut String,\n    ) {\n        // if cell_name.is_empty() || formula.is_empty() {\n        //     *status_out = \"invalid args\".to_string();\n        //     return;\n        // }\n\n        // Parse cell name to get row and column\n        // let (r_, c_) = match self.spreadsheet_parse_cell_name(cell_name) {\n        //     Some(coords) =\u003e coords,\n        //     None =\u003e {\n        //         *status_out = \"invalid args\".to_string();\n        //         return;\n        //     }\n        // };\n\n        // Get the cell\n        let index = (row - 1) as usize * self.cols as usize + (col - 1) as usize;\n\n        // Firstly, check if the formula is copy\n\n        if let ParsedRHS::Function {\n            name: FunctionName::Copy,\n            args: (Operand::Cell(start_row, start_col), Operand::Cell(end_row, end_col)),\n        } = rhs\n        {\n            // Calculate offsets\n            let dest_row = row; //1\n            let dest_col = col; //1\n            let row_offset = dest_row as isize - start_row as isize; //1\n            let col_offset = dest_col as isize - start_col as isize; //0\n            // firstly iterate through all src_cells nd put them in some vector\n            // then iterate through all dest cells nd put value from vectors in dest cells\n            // can't be done in single iteration ; src and dest cells can be overlapping\n            // println!(\"{} {}\", start_row, start_col);\n            // println!(\"{} {}\", end_row, end_col);\n            let mut src_val: Vec\u003ci32\u003e = Vec::new();\n            let mut src_err: Vec\u003cbool\u003e = Vec::new();\n            for r in start_row..=end_row {\n                for c in start_col..=end_col {\n                    let src_index = ((r - 1) * self.cols + (c - 1)) as usize;\n                    if let Some(src_cell) = self.cells.get(src_index).and_then(|opt| opt.as_ref()) {\n                        src_val.push(src_cell.value);\n                        src_err.push(src_cell.error);\n                    }\n                }\n            }\n            // println!(\"src_val {:?}\", src_val);\n            // now iterate through all dest cells and put value from src_val in dest cells\n            let mut cnter = 0;\n            for r in start_row..=end_row {\n                for c in start_col..=end_col {\n                    self.update_dependencies((r, c), (0, 0), (0, 0), false);\n                    let dest_index = ((r as isize + row_offset - 1) * self.cols as isize\n                        + (c as isize + col_offset - 1))\n                        as usize;\n                    if dest_index \u003c self.cells.len() {\n                        if let Some(dest_cell) =\n                            self.cells.get_mut(dest_index).and_then(|opt| opt.as_mut())\n                        {\n                            self.undo_stack.push((\n                                dest_cell.formula.clone(),\n                                dest_cell.row,\n                                dest_cell.col,\n                            ));\n                            // println!(\"dest_cell {:?} {}\", src_val[cnter], cnter);\n                            dest_cell.value = src_val[cnter];\n                            dest_cell.formula =\n                                ParsedRHS::SingleValue(Operand::Number(dest_cell.value)); // Clear formula\n                            dest_cell.error = src_err[cnter]; // copy error state\n                            cnter += 1;\n                        }\n                    }\n                }\n            }\n            *status_out = \"ok\".to_string();\n            return;\n        }\n\n        // Find dependencies\n        let mut r1 = 0;\n        let mut r2 = 0;\n        let mut c1 = 0;\n        let mut c2 = 0;\n        let mut is_range = false;\n        match \u0026rhs {\n            ParsedRHS::Function {\n                args: (Operand::Cell(w, x), Operand::Cell(y, z)),\n                ..\n            } =\u003e {\n                r1 = *w;\n                r2 = *y;\n                c1 = *x;\n                c2 = *z;\n                is_range = true;\n            }\n            ParsedRHS::Arithmetic { lhs, rhs, .. } =\u003e {\n                if let Operand::Cell(w, x) = lhs {\n                    r1 = *w;\n                    c1 = *x;\n                }\n                if let Operand::Cell(y, z) = rhs {\n                    r2 = *y;\n                    c2 = *z;\n                }\n            }\n            ParsedRHS::Sleep(Operand::Cell(r, c)) =\u003e {\n                r1 = *r;\n                c1 = *c;\n            }\n            ParsedRHS::SingleValue(Operand::Cell(r, c)) =\u003e {\n                r1 = *r;\n                c1 = *c;\n            }\n            _ =\u003e {}\n        };\n\n        // Check for cycles\n        if self.first_step_find_cycle((row, col), (r1, c1), (r2, c2), is_range) {\n            *status_out = \"Cycle Detected\".to_string();\n            return;\n        }\n\n        // new\n        // println!(\n        //     \"cycle detection took {:?}\",\n        //     start_time.elapsed().as_secs_f64()\n        // );\n        // new\n\n        // Update dependencies\n        self.update_dependencies((row, col), (r1, c1), (r2, c2), is_range);\n\n        // println!(\"cell dependency of A1 are : {:?}\", self.cells[0].as_ref().unwrap().dependents);\n        // println!(\"cell dependency of current cell are : {:?}\", self.cells[index].as_ref().unwrap().dependents);\n\n        let cell = match self.cells.get_mut(index).and_then(|opt| opt.as_mut()) {\n            Some(cell) =\u003e cell,\n            None =\u003e {\n                *status_out = \"invalid args\".to_string();\n                return;\n            }\n        };\n        // new\n        // println!(\n        //     \"update dependencies took {:?}\",\n        //     start_time.elapsed().as_secs_f64()\n        // );\n        // new\n        // Update the cell's formula\n        // println!(\n        //     \"pushing cell {}{} with formula: {:?}\",\n        //     cell.row, cell.col, cell.formula\n        // );\n\n        // UNDO PENDING\n        self.undo_stack\n            .push((cell.formula.clone(), cell.row, cell.col));\n\n        // UNDO PENDING\n        // println!(\"length of stack after push {}\", self.undo_stack.len());\n        cell.formula = rhs;\n        // mutable reference not needed anymore\n        // take cell as immutable\n        let cell = match self.cells.get(index).and_then(|opt| opt.as_ref()) {\n            Some(cell) =\u003e cell,\n            None =\u003e {\n                *status_out = \"invalid args\".to_string();\n                return;\n            }\n        };\n        // Perform topological sort\n\n        let sorted_cells = self.topo_sort(cell);\n        // println!(\"sorted cells {:?}\", sorted_cells);\n        // new\n        // println!(\"topo sort took {:?}\", start_time.elapsed().as_secs_f64());\n        // new\n\n        // println!(\"Updating cells in topological order:\");\n        // for (row, col) in \u0026sorted_cells {\n        //     println!(\"Cell {}{}...\", Self::col_to_letter(*col as i32), row);\n        // }\n\n        // Evaluate expressions for all cells in topological order\n\n        for (row, col) in sorted_cells.iter() {\n            // Calculate index for the current cell in topological order\n            let sorted_index = (*row - 1) as usize * self.cols as usize + (*col - 1) as usize;\n\n            // Get formula from the sorted cell\n            // let formula = match self.cells.get(sorted_index).and_then(|opt| opt.as_ref()) {\n            //     Some(cell) =\u003e cell.formula.as_deref().unwrap_or(\"\"),\n            //     None =\u003e {\n            //         continue; // Skip if cell doesn't exist\n            //     }\n            // };\n            let formula = match self.cells.get(sorted_index).and_then(|opt| opt.as_ref()) {\n                Some(cell) =\u003e \u0026cell.formula,\n                None =\u003e {\n                    continue; // Skip if cell doesn't exist\n                }\n            };\n\n            // Evaluate expression\n            let (value, error_cell) = self.spreadsheet_evaluate_expression(formula, *row, *col);\n\n            // Update the sorted cell's value\n            if let Some(sorted_cell) = self\n                .cells\n                .get_mut(sorted_index)\n                .and_then(|opt| opt.as_mut())\n            {\n                sorted_cell.value = value;\n                sorted_cell.error = error_cell;\n            }\n        }\n        // new\n        // println!(\"evaluation took {:?}\", start_time.elapsed().as_secs_f64());\n        // new\n\n        *status_out = \"ok\".to_string();\n    }\n\n    pub fn spreadsheet_undo(\u0026mut self, status_out: \u0026mut String) {\n        // iterate through undo_stack extract cell name --\u003e update dependencies --\u003e set value\n        let mut undo_stack = self.undo_stack.clone();\n        self.undo_stack.clear();\n        for _ in 0..undo_stack.len() {\n            let (formula_new, row, col) = undo_stack.pop().unwrap();\n\n            self.spreadsheet_set_cell_value(row, col, formula_new, status_out);\n        }\n        // make the undo stack empty\n    }\n\n    // pub fn spreadsheet_redo(\u0026mut self) {}\n\n    pub fn spreadsheet_display(\u0026self) {\n        let end_row = if self.view_row + 10 \u003c self.rows {\n            self.view_row + 10\n        } else {\n            self.rows\n        };\n\n        let end_col = if self.view_col + 10 \u003c self.cols {\n            self.view_col + 10\n        } else {\n            self.cols\n        };\n\n        // Print column headers\n        print!(\"\\t\\t\");\n        for col in (self.view_col + 1)..=end_col {\n            print!(\"{}\\t\\t\", Self::col_to_letter(col));\n        }\n        println!();\n\n        // Print rows\n        for row in (self.view_row + 1)..=end_row {\n            print!(\"{}\\t\\t\", row);\n            for col in (self.view_col + 1)..=end_col {\n                let index = (row - 1) as usize * self.cols as usize + (col - 1) as usize;\n                if let Some(cell) = self.cells.get(index).and_then(|opt| opt.as_ref()) {\n                    if cell.error {\n                        print!(\"ERR\\t\\t\");\n                    } else {\n                        print!(\"{:\u003c16}\", cell.value);\n                    }\n                } else {\n                    print!(\"0\\t\\t\");\n                }\n            }\n            println!();\n        }\n    }\n\n    pub fn is_valid_command(\u0026self, cell_name: \u0026str, formula: \u0026str) -\u003e (bool, i16, i16, ParsedRHS) {\n        // initialise the return value\n        let mut ret = (false, 0, 0, ParsedRHS::None);\n        if cell_name.is_empty() || formula.is_empty() {\n            return ret;\n        }\n\n        // Check if valid cell name\n        // also update the ret val accordingly\n        if let Some((row, col)) = self.spreadsheet_parse_cell_name(cell_name) {\n            ret.1 = row;\n            ret.2 = col;\n        } else {\n            return ret;\n        }\n        // if self.spreadsheet_parse_cell_name(cell_name).is_none() {\n        //     return false;\n        // }\n\n        // Check if formula is empty (already checked above, redundant)\n        if formula.is_empty() {\n            return ret;\n        }\n\n        // Check for function call pattern: FUNC(...)\n        if let Some(captures) = FUNC_REGEX.captures(formula) {\n            let func = captures.get(1).unwrap().as_str();\n            let args = captures.get(2).unwrap().as_str();\n\n            if func.eq_ignore_ascii_case(\"SLEEP\") {\n                if args.is_empty() {\n                    return ret;\n                }\n                // Check if args is a valid integer\n                // also extract that integer\n                if let Ok(value) = args.parse::\u003ci32\u003e() {\n                    ret.0 = true;\n                    ret.3 = ParsedRHS::Sleep(Operand::Number(value));\n                    return ret;\n                }\n                // Check if args is a valid cell reference\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(args) {\n                    ret.0 = true;\n                    ret.3 = ParsedRHS::Sleep(Operand::Cell(row, col));\n                    return ret;\n                }\n                return ret;\n            } else {\n                // Check for range functions like MIN, MAX, etc.\n                if let Some(colon_pos) = args.find(':') {\n                    let (start, end) = args.split_at(colon_pos);\n                    let end = \u0026end[1..]; // Skip the colon\n\n                    if let (Some((start_row, start_col)), Some((end_row, end_col))) = (\n                        self.spreadsheet_parse_cell_name(start.trim()),\n                        self.spreadsheet_parse_cell_name(end.trim()),\n                    ) {\n                        if start_row \u003c= end_row \u0026\u0026 start_col \u003c= end_col {\n                            // if matches!(\n                            //     func.to_uppercase().as_str(),\n                            //     \"MIN\" | \"MAX\" | \"SUM\" | \"AVG\" | \"STDEV\" | \"CUT\" | \"COPY\"\n                            // ) {\n                            //     ret.0 = true;\n                            //     ret.3 = ParsedRHS::Function { name: FunctionName::, args: (Operand::Cell(start_row as usize,start_col as usize),Operand::Cell(end_row as usize, end_col as usize)) };\n                            //     return ret;\n                            // }\n                            // eprintln!(\"Outside fault function\");\n                            if let Some(fname) = FunctionName::from_strng(func) {\n                                // eprintln!(\"Function name: {}\", func);\n                                if func == \"COPY\" {\n                                    // eprintln!(\"Copy function detected\");\n                                    let dest_row = ret.1;\n                                    let dest_col = ret.2;\n                                    // Calculate offsets\n                                    let row_offset = dest_row - start_row;\n                                    let col_offset = dest_col - start_col;\n\n                                    // Calculate the final destination cell coordinates\n                                    let final_row = end_row + row_offset;\n                                    let final_col = end_col + col_offset;\n\n                                    if final_row \u003e 0\n                                        \u0026\u0026 final_row \u003c= self.rows\n                                        \u0026\u0026 final_col \u003e 0\n                                        \u0026\u0026 final_col \u003c= self.cols\n                                    {\n                                        ret.0 = true;\n                                        ret.3 = ParsedRHS::Function {\n                                            name: fname,\n                                            args: (\n                                                Operand::Cell(start_row, start_col),\n                                                Operand::Cell(end_row, end_col),\n                                            ),\n                                        };\n                                        return ret;\n                                    } else {\n                                        // Invalid destination cell\n                                        ret.0 = false;\n                                        return ret;\n                                    }\n                                }\n                                ret.0 = true;\n                                ret.3 = ParsedRHS::Function {\n                                    name: fname,\n                                    args: (\n                                        Operand::Cell(start_row, start_col),\n                                        Operand::Cell(end_row, end_col),\n                                    ),\n                                };\n                                return ret;\n                            }\n                        }\n                    }\n                }\n                return ret;\n            }\n        }\n\n        // Check if the formula is a single cell reference (e.g., A1)\n        if let Some((row, col)) = self.spreadsheet_parse_cell_name(formula) {\n            ret.0 = true;\n            ret.3 = ParsedRHS::SingleValue(Operand::Cell(row, col));\n            return ret;\n        }\n\n        // Check for only some integer with optional sign on the rhs\n        if let Ok(value) = formula.parse::\u003ci32\u003e() {\n            ret.0 = true;\n            ret.3 = ParsedRHS::SingleValue(Operand::Number(value));\n            return ret;\n        }\n        // Check for arithmetic expressions with cell references or numbers\n        let (b, x) = self.is_valid_arithmetic_expression(formula);\n        if b {\n            ret.0 = true;\n            ret.3 = x;\n            ret\n        } else {\n            ret.0 = false;\n            ret\n        }\n    }\n    pub fn is_valid_arithmetic_expression(\u0026self, expr: \u0026str) -\u003e (bool, ParsedRHS) {\n        // initialise the return value\n        let mut ret = (false, ParsedRHS::None);\n        // let mut oprnd1 = Operand::Number(0);\n        // let mut oprnd2 = Operand::Number(0);\n        // Use regex to separate expression into components\n\n        if let Some(captures) = ARITH_EXPR_REGEX.captures(expr) {\n            let first_operand = captures.get(1).unwrap().as_str();\n            let operator = captures.get(4).unwrap().as_str();\n            let second_operand = captures.get(5).unwrap().as_str();\n\n            // Verify first operand\n            let oprnd1 = if first_operand.chars().next().unwrap().is_ascii_alphabetic() {\n                // It's a cell reference\n                // self.spreadsheet_parse_cell_name(first_operand).is_some()\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(first_operand) {\n                    Operand::Cell(row, col)\n                } else {\n                    // It's a number with optional sign\n\n                    return (false, ParsedRHS::None);\n                }\n            } else if let Ok(value) = first_operand.parse::\u003ci32\u003e() {\n                Operand::Number(value)\n            } else {\n                return (false, ParsedRHS::None);\n            };\n\n            // Verify second operand\n            let oprnd2 = if second_operand.chars().next().unwrap().is_ascii_alphabetic() {\n                // It's a cell reference\n                if let Some((row, col)) = self.spreadsheet_parse_cell_name(second_operand) {\n                    Operand::Cell(row, col)\n                } else {\n                    // It's a number with optional sign\n\n                    return (false, ParsedRHS::None);\n                }\n            } else if let Ok(value) = second_operand.parse::\u003ci32\u003e() {\n                Operand::Number(value)\n            } else {\n                return (false, ParsedRHS::None);\n            };\n            // Check if the operator is valid\n            if let Some(op_char) = operator.chars().next() {\n                if \"+-*/\".contains(op_char) {\n                    ret.0 = true;\n                    ret.1 = ParsedRHS::Arithmetic {\n                        lhs: oprnd1,\n                        operator: op_char,\n                        rhs: oprnd2,\n                    };\n                }\n            } else {\n                return (false, ParsedRHS::None);\n            }\n\n            ret\n        } else {\n            ret\n        }\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":32}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":17}},{"line":82,"address":[],"length":0,"stats":{"Line":17}},{"line":83,"address":[],"length":0,"stats":{"Line":17}},{"line":84,"address":[],"length":0,"stats":{"Line":17}},{"line":85,"address":[],"length":0,"stats":{"Line":17}},{"line":86,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":17}},{"line":91,"address":[],"length":0,"stats":{"Line":18291339}},{"line":92,"address":[],"length":0,"stats":{"Line":18291322}},{"line":95,"address":[],"length":0,"stats":{"Line":1456}},{"line":96,"address":[],"length":0,"stats":{"Line":36584083}},{"line":97,"address":[],"length":0,"stats":{"Line":18291322}},{"line":98,"address":[],"length":0,"stats":{"Line":18291322}},{"line":102,"address":[],"length":0,"stats":{"Line":17}},{"line":105,"address":[],"length":0,"stats":{"Line":141}},{"line":106,"address":[],"length":0,"stats":{"Line":141}},{"line":107,"address":[],"length":0,"stats":{"Line":141}},{"line":108,"address":[],"length":0,"stats":{"Line":607}},{"line":109,"address":[],"length":0,"stats":{"Line":233}},{"line":110,"address":[],"length":0,"stats":{"Line":233}},{"line":111,"address":[],"length":0,"stats":{"Line":233}},{"line":113,"address":[],"length":0,"stats":{"Line":141}},{"line":116,"address":[],"length":0,"stats":{"Line":201}},{"line":117,"address":[],"length":0,"stats":{"Line":201}},{"line":119,"address":[],"length":0,"stats":{"Line":696}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":128}},{"line":127,"address":[],"length":0,"stats":{"Line":128}},{"line":128,"address":[],"length":0,"stats":{"Line":128}},{"line":129,"address":[],"length":0,"stats":{"Line":128}},{"line":131,"address":[],"length":0,"stats":{"Line":401}},{"line":132,"address":[],"length":0,"stats":{"Line":273}},{"line":134,"address":[],"length":0,"stats":{"Line":108}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":105}},{"line":138,"address":[],"length":0,"stats":{"Line":302}},{"line":139,"address":[],"length":0,"stats":{"Line":137}},{"line":140,"address":[],"length":0,"stats":{"Line":137}},{"line":142,"address":[],"length":0,"stats":{"Line":28}},{"line":146,"address":[],"length":0,"stats":{"Line":187}},{"line":147,"address":[],"length":0,"stats":{"Line":8}},{"line":150,"address":[],"length":0,"stats":{"Line":89}},{"line":151,"address":[],"length":0,"stats":{"Line":89}},{"line":153,"address":[],"length":0,"stats":{"Line":169}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":83}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":63}},{"line":163,"address":[],"length":0,"stats":{"Line":71}},{"line":169,"address":[],"length":0,"stats":{"Line":71}},{"line":170,"address":[],"length":0,"stats":{"Line":24}},{"line":171,"address":[],"length":0,"stats":{"Line":24}},{"line":173,"address":[],"length":0,"stats":{"Line":24}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":24}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":24}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":67}},{"line":194,"address":[],"length":0,"stats":{"Line":147}},{"line":195,"address":[],"length":0,"stats":{"Line":80}},{"line":196,"address":[],"length":0,"stats":{"Line":80}},{"line":197,"address":[],"length":0,"stats":{"Line":160}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":78}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":214,"address":[],"length":0,"stats":{"Line":4}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":7}},{"line":270,"address":[],"length":0,"stats":{"Line":7}},{"line":271,"address":[],"length":0,"stats":{"Line":7}},{"line":273,"address":[],"length":0,"stats":{"Line":7}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":12}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":9}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":9}},{"line":300,"address":[],"length":0,"stats":{"Line":18}},{"line":301,"address":[],"length":0,"stats":{"Line":4}},{"line":302,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":5}},{"line":306,"address":[],"length":0,"stats":{"Line":15}},{"line":310,"address":[],"length":0,"stats":{"Line":18}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":5}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":5}},{"line":316,"address":[],"length":0,"stats":{"Line":15}},{"line":321,"address":[],"length":0,"stats":{"Line":25}},{"line":324,"address":[],"length":0,"stats":{"Line":18}},{"line":325,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":9}},{"line":345,"address":[],"length":0,"stats":{"Line":26}},{"line":347,"address":[],"length":0,"stats":{"Line":26}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":6}},{"line":352,"address":[],"length":0,"stats":{"Line":18}},{"line":354,"address":[],"length":0,"stats":{"Line":20}},{"line":359,"address":[],"length":0,"stats":{"Line":5}},{"line":364,"address":[],"length":0,"stats":{"Line":39}},{"line":372,"address":[],"length":0,"stats":{"Line":131}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":48}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":40}},{"line":390,"address":[],"length":0,"stats":{"Line":74}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":44}},{"line":401,"address":[],"length":0,"stats":{"Line":62}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":9}},{"line":404,"address":[],"length":0,"stats":{"Line":9}},{"line":405,"address":[],"length":0,"stats":{"Line":9}},{"line":406,"address":[],"length":0,"stats":{"Line":9}},{"line":407,"address":[],"length":0,"stats":{"Line":27}},{"line":408,"address":[],"length":0,"stats":{"Line":9}},{"line":417,"address":[],"length":0,"stats":{"Line":35}},{"line":421,"address":[],"length":0,"stats":{"Line":129}},{"line":422,"address":[],"length":0,"stats":{"Line":129}},{"line":423,"address":[],"length":0,"stats":{"Line":54}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":75}},{"line":430,"address":[],"length":0,"stats":{"Line":39}},{"line":444,"address":[],"length":0,"stats":{"Line":39}},{"line":447,"address":[],"length":0,"stats":{"Line":78}},{"line":448,"address":[],"length":0,"stats":{"Line":39}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":39}},{"line":454,"address":[],"length":0,"stats":{"Line":39}},{"line":457,"address":[],"length":0,"stats":{"Line":39}},{"line":460,"address":[],"length":0,"stats":{"Line":71}},{"line":462,"address":[],"length":0,"stats":{"Line":71}},{"line":463,"address":[],"length":0,"stats":{"Line":71}},{"line":464,"address":[],"length":0,"stats":{"Line":284}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":16}},{"line":473,"address":[],"length":0,"stats":{"Line":16}},{"line":474,"address":[],"length":0,"stats":{"Line":16}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":16}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":16}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":51}},{"line":487,"address":[],"length":0,"stats":{"Line":103}},{"line":488,"address":[],"length":0,"stats":{"Line":52}},{"line":489,"address":[],"length":0,"stats":{"Line":52}},{"line":491,"address":[],"length":0,"stats":{"Line":52}},{"line":492,"address":[],"length":0,"stats":{"Line":156}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":6}},{"line":504,"address":[],"length":0,"stats":{"Line":6}},{"line":505,"address":[],"length":0,"stats":{"Line":6}},{"line":508,"address":[],"length":0,"stats":{"Line":12}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":6}},{"line":513,"address":[],"length":0,"stats":{"Line":6}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":11}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":5}},{"line":524,"address":[],"length":0,"stats":{"Line":5}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":534,"address":[],"length":0,"stats":{"Line":16}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":539,"address":[],"length":0,"stats":{"Line":3}},{"line":541,"address":[],"length":0,"stats":{"Line":6}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":42}},{"line":549,"address":[],"length":0,"stats":{"Line":61}},{"line":561,"address":[],"length":0,"stats":{"Line":61}},{"line":568,"address":[],"length":0,"stats":{"Line":61}},{"line":569,"address":[],"length":0,"stats":{"Line":16}},{"line":570,"address":[],"length":0,"stats":{"Line":16}},{"line":573,"address":[],"length":0,"stats":{"Line":46}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":52}},{"line":579,"address":[],"length":0,"stats":{"Line":106}},{"line":580,"address":[],"length":0,"stats":{"Line":54}},{"line":581,"address":[],"length":0,"stats":{"Line":54}},{"line":582,"address":[],"length":0,"stats":{"Line":162}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":45}},{"line":590,"address":[],"length":0,"stats":{"Line":11}},{"line":591,"address":[],"length":0,"stats":{"Line":11}},{"line":592,"address":[],"length":0,"stats":{"Line":44}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":3}},{"line":598,"address":[],"length":0,"stats":{"Line":3}},{"line":599,"address":[],"length":0,"stats":{"Line":12}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":61}},{"line":607,"address":[],"length":0,"stats":{"Line":36}},{"line":609,"address":[],"length":0,"stats":{"Line":36}},{"line":612,"address":[],"length":0,"stats":{"Line":36}},{"line":613,"address":[],"length":0,"stats":{"Line":36}},{"line":616,"address":[],"length":0,"stats":{"Line":36}},{"line":619,"address":[],"length":0,"stats":{"Line":36}},{"line":620,"address":[],"length":0,"stats":{"Line":36}},{"line":622,"address":[],"length":0,"stats":{"Line":172}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":68}},{"line":635,"address":[],"length":0,"stats":{"Line":136}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":208}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":16}},{"line":647,"address":[],"length":0,"stats":{"Line":16}},{"line":649,"address":[],"length":0,"stats":{"Line":16}},{"line":650,"address":[],"length":0,"stats":{"Line":16}},{"line":651,"address":[],"length":0,"stats":{"Line":16}},{"line":656,"address":[],"length":0,"stats":{"Line":52}},{"line":657,"address":[],"length":0,"stats":{"Line":52}},{"line":658,"address":[],"length":0,"stats":{"Line":52}},{"line":664,"address":[],"length":0,"stats":{"Line":36}},{"line":665,"address":[],"length":0,"stats":{"Line":36}},{"line":668,"address":[],"length":0,"stats":{"Line":37}},{"line":690,"address":[],"length":0,"stats":{"Line":37}},{"line":696,"address":[],"length":0,"stats":{"Line":2}},{"line":697,"address":[],"length":0,"stats":{"Line":2}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":13}},{"line":712,"address":[],"length":0,"stats":{"Line":26}},{"line":713,"address":[],"length":0,"stats":{"Line":13}},{"line":714,"address":[],"length":0,"stats":{"Line":52}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":2}},{"line":723,"address":[],"length":0,"stats":{"Line":15}},{"line":724,"address":[],"length":0,"stats":{"Line":26}},{"line":725,"address":[],"length":0,"stats":{"Line":13}},{"line":726,"address":[],"length":0,"stats":{"Line":13}},{"line":727,"address":[],"length":0,"stats":{"Line":13}},{"line":728,"address":[],"length":0,"stats":{"Line":13}},{"line":729,"address":[],"length":0,"stats":{"Line":13}},{"line":730,"address":[],"length":0,"stats":{"Line":13}},{"line":731,"address":[],"length":0,"stats":{"Line":39}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":2}},{"line":749,"address":[],"length":0,"stats":{"Line":2}},{"line":753,"address":[],"length":0,"stats":{"Line":35}},{"line":754,"address":[],"length":0,"stats":{"Line":35}},{"line":755,"address":[],"length":0,"stats":{"Line":35}},{"line":756,"address":[],"length":0,"stats":{"Line":35}},{"line":757,"address":[],"length":0,"stats":{"Line":35}},{"line":758,"address":[],"length":0,"stats":{"Line":11}},{"line":760,"address":[],"length":0,"stats":{"Line":11}},{"line":761,"address":[],"length":0,"stats":{"Line":11}},{"line":762,"address":[],"length":0,"stats":{"Line":11}},{"line":763,"address":[],"length":0,"stats":{"Line":11}},{"line":764,"address":[],"length":0,"stats":{"Line":11}},{"line":765,"address":[],"length":0,"stats":{"Line":11}},{"line":766,"address":[],"length":0,"stats":{"Line":11}},{"line":767,"address":[],"length":0,"stats":{"Line":11}},{"line":769,"address":[],"length":0,"stats":{"Line":3}},{"line":770,"address":[],"length":0,"stats":{"Line":5}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":4}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":3}},{"line":784,"address":[],"length":0,"stats":{"Line":3}},{"line":785,"address":[],"length":0,"stats":{"Line":3}},{"line":787,"address":[],"length":0,"stats":{"Line":18}},{"line":791,"address":[],"length":0,"stats":{"Line":35}},{"line":792,"address":[],"length":0,"stats":{"Line":1}},{"line":793,"address":[],"length":0,"stats":{"Line":1}},{"line":804,"address":[],"length":0,"stats":{"Line":34}},{"line":809,"address":[],"length":0,"stats":{"Line":68}},{"line":810,"address":[],"length":0,"stats":{"Line":34}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":34}},{"line":830,"address":[],"length":0,"stats":{"Line":34}},{"line":834,"address":[],"length":0,"stats":{"Line":34}},{"line":837,"address":[],"length":0,"stats":{"Line":136}},{"line":838,"address":[],"length":0,"stats":{"Line":34}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":34}},{"line":859,"address":[],"length":0,"stats":{"Line":72}},{"line":861,"address":[],"length":0,"stats":{"Line":38}},{"line":870,"address":[],"length":0,"stats":{"Line":152}},{"line":871,"address":[],"length":0,"stats":{"Line":38}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":38}},{"line":881,"address":[],"length":0,"stats":{"Line":76}},{"line":882,"address":[],"length":0,"stats":{"Line":38}},{"line":883,"address":[],"length":0,"stats":{"Line":38}},{"line":884,"address":[],"length":0,"stats":{"Line":114}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":34}},{"line":897,"address":[],"length":0,"stats":{"Line":3}},{"line":899,"address":[],"length":0,"stats":{"Line":3}},{"line":900,"address":[],"length":0,"stats":{"Line":3}},{"line":901,"address":[],"length":0,"stats":{"Line":9}},{"line":902,"address":[],"length":0,"stats":{"Line":6}},{"line":904,"address":[],"length":0,"stats":{"Line":6}},{"line":911,"address":[],"length":0,"stats":{"Line":3}},{"line":912,"address":[],"length":0,"stats":{"Line":6}},{"line":913,"address":[],"length":0,"stats":{"Line":1}},{"line":915,"address":[],"length":0,"stats":{"Line":2}},{"line":918,"address":[],"length":0,"stats":{"Line":6}},{"line":919,"address":[],"length":0,"stats":{"Line":1}},{"line":921,"address":[],"length":0,"stats":{"Line":2}},{"line":925,"address":[],"length":0,"stats":{"Line":3}},{"line":926,"address":[],"length":0,"stats":{"Line":53}},{"line":927,"address":[],"length":0,"stats":{"Line":25}},{"line":929,"address":[],"length":0,"stats":{"Line":3}},{"line":932,"address":[],"length":0,"stats":{"Line":28}},{"line":933,"address":[],"length":0,"stats":{"Line":25}},{"line":934,"address":[],"length":0,"stats":{"Line":250}},{"line":935,"address":[],"length":0,"stats":{"Line":225}},{"line":936,"address":[],"length":0,"stats":{"Line":900}},{"line":937,"address":[],"length":0,"stats":{"Line":1}},{"line":938,"address":[],"length":0,"stats":{"Line":1}},{"line":940,"address":[],"length":0,"stats":{"Line":224}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":25}},{"line":950,"address":[],"length":0,"stats":{"Line":48}},{"line":952,"address":[],"length":0,"stats":{"Line":48}},{"line":953,"address":[],"length":0,"stats":{"Line":95}},{"line":954,"address":[],"length":0,"stats":{"Line":1}},{"line":959,"address":[],"length":0,"stats":{"Line":45}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":2}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":10}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":1}},{"line":981,"address":[],"length":0,"stats":{"Line":1}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":16}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":7}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":14}},{"line":1017,"address":[],"length":0,"stats":{"Line":13}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":1}},{"line":1022,"address":[],"length":0,"stats":{"Line":1}},{"line":1024,"address":[],"length":0,"stats":{"Line":1}},{"line":1025,"address":[],"length":0,"stats":{"Line":1}},{"line":1028,"address":[],"length":0,"stats":{"Line":1}},{"line":1029,"address":[],"length":0,"stats":{"Line":1}},{"line":1031,"address":[],"length":0,"stats":{"Line":1}},{"line":1032,"address":[],"length":0,"stats":{"Line":1}},{"line":1033,"address":[],"length":0,"stats":{"Line":1}},{"line":1034,"address":[],"length":0,"stats":{"Line":1}},{"line":1036,"address":[],"length":0,"stats":{"Line":1}},{"line":1037,"address":[],"length":0,"stats":{"Line":1}},{"line":1038,"address":[],"length":0,"stats":{"Line":1}},{"line":1039,"address":[],"length":0,"stats":{"Line":1}},{"line":1040,"address":[],"length":0,"stats":{"Line":1}},{"line":1041,"address":[],"length":0,"stats":{"Line":1}},{"line":1044,"address":[],"length":0,"stats":{"Line":1}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":5}},{"line":1052,"address":[],"length":0,"stats":{"Line":5}},{"line":1053,"address":[],"length":0,"stats":{"Line":5}},{"line":1054,"address":[],"length":0,"stats":{"Line":5}},{"line":1055,"address":[],"length":0,"stats":{"Line":5}},{"line":1056,"address":[],"length":0,"stats":{"Line":5}},{"line":1059,"address":[],"length":0,"stats":{"Line":5}},{"line":1064,"address":[],"length":0,"stats":{"Line":3}},{"line":1069,"address":[],"length":0,"stats":{"Line":36}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":45}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":23}},{"line":1083,"address":[],"length":0,"stats":{"Line":23}},{"line":1084,"address":[],"length":0,"stats":{"Line":20}},{"line":1085,"address":[],"length":0,"stats":{"Line":20}},{"line":1086,"address":[],"length":0,"stats":{"Line":20}},{"line":1088,"address":[],"length":0,"stats":{"Line":3}},{"line":1089,"address":[],"length":0,"stats":{"Line":3}},{"line":1092,"address":[],"length":0,"stats":{"Line":34}},{"line":1094,"address":[],"length":0,"stats":{"Line":34}},{"line":1099,"address":[],"length":0,"stats":{"Line":59}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":24}},{"line":1108,"address":[],"length":0,"stats":{"Line":27}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":1}},{"line":1115,"address":[],"length":0,"stats":{"Line":22}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":24}},{"line":1124,"address":[],"length":0,"stats":{"Line":12}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":36}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":24}},{"line":1138,"address":[],"length":0,"stats":{"Line":24}},{"line":1139,"address":[],"length":0,"stats":{"Line":24}},{"line":1140,"address":[],"length":0,"stats":{"Line":24}},{"line":1141,"address":[],"length":0,"stats":{"Line":24}},{"line":1142,"address":[],"length":0,"stats":{"Line":24}},{"line":1143,"address":[],"length":0,"stats":{"Line":24}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":9}}],"covered":398,"coverable":521}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>