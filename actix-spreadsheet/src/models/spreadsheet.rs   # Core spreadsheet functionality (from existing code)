// filepath: /actix-spreadsheet/actix-spreadsheet/src/spreadsheet/spreadsheet.rs
use crate::cell::{Cell, cell_create};
use serde::{Deserialize, Serialize};
use std::collections::BTreeSet;

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct Spreadsheet {
    pub rows: i32,
    pub cols: i32,
    pub cells: Vec<Option<Box<Cell>>>,
}

impl Spreadsheet {
    pub fn spreadsheet_create(rows: i32, cols: i32) -> Option<Box<Self>> {
        let mut sheet = Box::new(Spreadsheet {
            rows,
            cols,
            cells: vec![None; (rows * cols) as usize],
        });

        Some(sheet)
    }

    pub fn col_to_letter(col: i32) -> String {
        let mut col = col;
        let mut result = String::new();
        while col > 0 {
            col -= 1;
            result.push(((col % 26) as u8 + b'A') as char);
            col /= 26;
        }
        result.chars().rev().collect()
    }

    pub fn letter_to_col(letters: &str) -> i32 {
        letters.chars().fold(0, |acc, c| acc * 26 + (c as i32 - 'A' as i32 + 1))
    }

    pub fn get_cell_name(row: i32, col: i32) -> String {
        format!("{}{}", Self::col_to_letter(col), row)
    }

    pub fn spreadsheet_parse_cell_name(&self, cell_name: &str) -> Option<(i32, i32)> {
        let mut letters = String::new();
        let mut digits = String::new();

        for c in cell_name.chars() {
            if c.is_ascii_alphabetic() {
                letters.push(c);
            } else if c.is_ascii_digit() {
                digits.push(c);
            }
        }

        if letters.is_empty() || digits.is_empty() {
            return None;
        }

        let col = Self::letter_to_col(&letters);
        let row = digits.parse::<i32>().ok()?;

        if col > self.cols || row > self.rows || row <= 0 {
            return None;
        }
        Some((row, col))
    }

    pub fn spreadsheet_set_cell_value(&mut self, cell_name: &str, formula: &str) {
        if let Some((row, col)) = self.spreadsheet_parse_cell_name(cell_name) {
            let index = ((row - 1) * self.cols + (col - 1)) as usize;
            if let Some(cell) = self.cells.get_mut(index).and_then(|opt| opt.as_mut()) {
                cell_create(cell, formula);
            }
        }
    }
}