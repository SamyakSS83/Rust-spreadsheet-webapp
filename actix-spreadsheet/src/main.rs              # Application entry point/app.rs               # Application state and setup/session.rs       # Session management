// src/main.rs
use actix_web::{web, App, HttpServer};
use actix_files as fs;
use std::sync::Arc;
use crate::app::AppState;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let app_state = Arc::new(AppState::new());

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::from(app_state.clone()))
            .service(fs::Files::new("/static", "./static").show_files_listing())
            .configure(routes::init_routes)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

// src/app.rs
use crate::models::session::SessionManager;
use crate::spreadsheet::Spreadsheet;

pub struct AppState {
    pub session_manager: SessionManager,
    pub current_spreadsheet: Option<Spreadsheet>,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            session_manager: SessionManager::new(),
            current_spreadsheet: None,
        }
    }
}

// src/models/session.rs
use std::collections::HashMap;

pub struct SessionManager {
    sessions: HashMap<String, String>, // session_id -> user_id
}

impl SessionManager {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
        }
    }

    pub fn create_session(&mut self, user_id: String) -> String {
        let session_id = uuid::Uuid::new_v4().to_string();
        self.sessions.insert(session_id.clone(), user_id);
        session_id
    }

    pub fn validate_session(&self, session_id: &str) -> Option<&String> {
        self.sessions.get(session_id)
    }
}