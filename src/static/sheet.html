<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            display: flex;
            padding: 10px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            align-items: center;
            gap: 10px;
            position: relative; /* Added to ensure proper stacking context */
        }

        #formula-bar {
            flex: 1;
            margin-left: 10px;
            padding: 5px;
            font-family: monospace;
            order: 1; /* This ensures formula bar comes after the actions */
        }

        #selected-cell {
            width: 100px;
            padding: 5px;
            background-color: #eee;
            border: 1px solid #ddd;
            text-align: center;
        }

        #display-bar {
            width: 200px;
            padding: 5px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            margin-left: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #grid-container {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        #grid {
            display: grid;
            grid-template-columns: 50px repeat(var(--cols, 10), 100px);
            grid-template-rows: 30px repeat(var(--rows, 10), 25px);
        }

        .cell {
            border: 1px solid #ddd;
            padding: 4px;
            overflow: hidden;
            white-space: nowrap;
            background-color: white;
            outline: none;
            user-select: none; /* Prevent text selection unless editing */
        }

        .cell.editing {
            user-select: text;
            white-space: pre-wrap;
            overflow: visible;
            background-color: #fff;
            box-shadow: inset 0 0 0 2px #4d90fe;
            padding: 3px;
        }

        .header-cell {
            background-color: #f0f0f0;
            font-weight: bold;
            text-align: center;
            position: sticky;
            z-index: 10;
        }

        .row-header {
            left: 0;
            z-index: 20;
        }

        .col-header {
            top: 0;
        }

        .corner-header {
            top: 0;
            left: 0;
            z-index: 30;
        }

        .selected {
            background-color: #e6f3ff;
            border: 1px solid #4d90fe;
        }

        .in-range {
            background-color: rgba(200, 220, 255, 0.5);
        }

        .error {
            background-color: #ffebee;
        }

        #actions {
            display: flex;
            gap: 10px;
            align-items: center;
            order: -1; /* This moves the actions div to the start of the toolbar */
        }

        .action-button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #save-button {
            background-color: #4CAF50;
            color: white;
        }

        #save-button:hover {
            background-color: #45a049;
        }

        #home-button {
            background-color: #2196F3;
            color: white;
        }

        #home-button:hover {
            background-color: #0b7dda;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background-color: white;
            padding: 20px 30px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .modal-content h2 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 6px 8px;
            margin-top: 4px;
            box-sizing: border-box;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-content button {
            margin-top: 10px;
            margin-right: 10px;
        }

        #graph-button {
            background-color: #bf63c4;
            /* a green tone */
        }

        #graph-button:hover {
            background-color: #de91d4;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            position: absolute;
            background-color: #f9f9f9;
            min-width: 120px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Increased z-index to ensure dropdown shows on top */
            border-radius: 4px;
            top: 100%;
            right: 0;
        }

        .dropdown-content a {
            color: black;
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            font-size: 14px;
        }

        .dropdown-content a:hover {
            background-color: #f1f1f1;
            border-radius: 4px;
        }

        #download-button {
            background-color: #5c6bc0;
            color: white;
            z-index: 1000; /* Ensure it is on top of other elements */
            position: relative; /* Ensure stacking context for z-index */
        }

        #download-button:hover {
            background-color: #3f51b5;
        }

        .hidden {
            display: none !important;
        }

        .error-modal {
            z-index: 2000;  /* Ensure it's above other elements */
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="toolbar">
            <div id="selected-cell"></div>
            <div id="display-bar"></div>
            <input type="text" id="formula-bar" placeholder="Enter formula here...">
            <div id="actions">
                <button id="graph-button" class="action-button">Graph</button>
                <div class="dropdown">
                    <button id="download-button" class="action-button">Download</button>
                    <div id="download-dropdown" class="dropdown-content hidden">
                        <a href="#" id="download-csv">CSV</a>
                        <a href="#" id="download-xlsx">Excel (XLSX)</a>
                    </div>
                </div>
                <button id="save-button" class="action-button">Save</button>
                <button id="home-button" class="action-button">Home</button>
            </div>
        </div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
    </div>
    <div id="graph-display-modal" class="modal hidden">
        <div class="modal-content">
            <span id="close-graph-modal" style="float:right; cursor:pointer;">&times;</span>
            <h2>Graph Preview</h2>
            <img id="graph-preview" src="" alt="Generated Graph" style="max-width: 100%; margin-top: 10px;">
        </div>
    </div>

    <div id="graph-modal" class="modal hidden">
        <div class="modal-content">
            <h2>Create Graph</h2>
            <label>Graph Title: <input type="text" id="graph-title" placeholder="e.g., Sales Data"></label><br>
            <label>X Range: <input type="text" id="x-range" placeholder="e.g., 0-10"></label><br>
            <label>Y Range: <input type="text" id="y-range" placeholder="e.g., 0-100"></label><br>
            <label>Graph Type:
                <select id="graph-type">
                    <option value="Line">Line</option>
                    <option value="Bar">Bar</option>
                    <option value="Scatter">Scatter</option>
                    <option value="Area">Area</option>
                </select>
            </label><br>
            <label>X Label: <input type="text" id="x-label" placeholder="e.g., Time (s)"></label><br>
            <label>Y Label: <input type="text" id="y-label" placeholder="e.g., Value"></label><br>
            <button id="create-graph">Create</button>
            <button id="close-modal">Cancel</button>
        </div>
    </div>

    <div id="save-modal" class="modal hidden">
        <div class="modal-content">
            <h2>Save Spreadsheet</h2>
            <form id="save-form">
                <label>Filename: <input type="text" id="filename-input" placeholder="e.g., my_spreadsheet"></label><br>
                <div style="margin-top: 10px;">
                    <button type="submit" id="confirm-save">Save</button>
                    <button type="button" id="cancel-save">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="error-modal" class="modal hidden">
        <div class="modal-content" style="max-width: 400px;">
            <span id="close-error-modal" style="float:right; cursor:pointer;">&times;</span>
            <h2 style="color: #d32f2f;">Error</h2>
            <div id="error-message" style="margin: 15px 0; font-size: 16px;"></div>
            <div style="text-align: right;">
                <button id="error-ok-button" class="action-button" style="background-color: #d32f2f; color: white;">OK</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const grid = document.getElementById('grid');
            const formulaBar = document.getElementById('formula-bar');
            const selectedCellDisplay = document.getElementById('selected-cell');
            const displayBar = document.getElementById('display-bar');
            const saveButton = document.getElementById('save-button');
            const homeButton = document.getElementById('home-button');
            const graphButton = document.getElementById("graph-button");
            const modal = document.getElementById("graph-modal");
            const closeModal = document.getElementById("close-modal");

            let isFormulaBuildMode = false;
            let formulaBeingBuilt = null;

            // Add version tracking for conflict management
            let currentVersion = 0;
            let isPolling = true;

            // Add after the variable declarations in DOMContentLoaded
            let isRangeSelectionMode = false;
            let rangeStartCell = null;
            let rangeEndCell = null;
            let functionMode = null;
            let selectedRange = [];

            // Error modal handlers
            const errorModal = document.getElementById('error-modal');
            const closeErrorModalBtn = document.getElementById('close-error-modal');
            const errorOkButton = document.getElementById('error-ok-button');

            // Close modal when clicking X
            closeErrorModalBtn.addEventListener('click', () => {
                errorModal.classList.add('hidden');
            });

            // Close modal when clicking OK button
            errorOkButton.addEventListener('click', () => {
                errorModal.classList.add('hidden');
            });

            // Close modal when clicking outside
            errorModal.addEventListener('click', (e) => {
                if (e.target === errorModal) {
                    errorModal.classList.add('hidden');
                }
            });

            // Close modal on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !errorModal.classList.contains('hidden')) {
                    errorModal.classList.add('hidden');
                }
            });

            // Start polling for updates
            startPolling();

            // Function to start polling for sheet changes
            function startPolling() {
                if (isPolling) {
                    pollForChanges();
                    setInterval(pollForChanges, 3000); // Check every 3 seconds
                }
            }

            // Poll server for sheet changes
            async function pollForChanges() {
                try {
                    const response = await fetch('/api/sheet_status');
                    const status = await response.json();

                    // If server version is newer than our version, refresh
                    if (status.version > currentVersion && currentVersion > 0) {
                        // Refresh the sheet to show updates from other users
                        displayBar.textContent = "Sheet has been updated by another user. Refreshing...";
                        await fetchSheetData();

                        // Update our version to match server
                        currentVersion = status.version;
                    } else if (currentVersion === 0) {
                        // Initialize version on first load
                        currentVersion = status.version;
                    }
                } catch (error) {
                    console.error('Error polling for changes:', error);
                }
            }

            graphButton.addEventListener("click", () => {
                modal.classList.remove("hidden");
            });

            closeModal.addEventListener("click", () => {
                modal.classList.add("hidden");
            });

            document.getElementById("create-graph").addEventListener("click", async function () {
                const graphtitle = document.getElementById("graph-title").value;
                const xRange = document.getElementById("x-range").value;
                const yRange = document.getElementById("y-range").value;
                const type = document.getElementById("graph-type").value;
                const xLabel = document.getElementById("x-label").value;
                const yLabel = document.getElementById("y-label").value;


                const payload = {
                    x_range: xRange,
                    y_range: yRange,
                    title: graphtitle,
                    x_label: xLabel,
                    y_label: yLabel,
                    graph_type: type,
                };

                try {
                    const response = await fetch('/api/graph', {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(payload),
                    });

                    console.log("Content-Type:", response.headers.get("Content-Type"));

                    if (!response.ok) {
                        throw new Error("Graph generation failed");
                    }

                    const blob = await response.blob();
                    const imgUrl = URL.createObjectURL(blob);
                    document.getElementById("graph-preview").src = imgUrl;
                    document.getElementById("graph-display-modal").classList.remove("hidden");

                    const a = document.createElement("a");
                    a.href = imgUrl;
                    a.download = "graph.png";
                    a.click();


                } catch (error) {
                    alert("Error: " + error.message);
                }

                modal.classList.add("hidden");
            });
            document.getElementById("close-graph-modal").addEventListener("click", () => {
                document.getElementById("graph-display-modal").classList.add("hidden");
            });

            document.getElementById("close-modal").addEventListener("click", function () {
                const modal = document.getElementById("graph-modal");
                modal.classList.add("hidden");
            });

            let selectedCell = null;
            let sheetData = null;

            // Fetch sheet data
            async function fetchSheetData() {
                const response = await fetch('/api/sheet');
                sheetData = await response.json();
                renderGrid(sheetData.rows, sheetData.cols);
                updateCellValues(sheetData.cells);

                // Get the latest version after sheet refresh
                try {
                    const statusResponse = await fetch('/api/sheet_status');
                    const status = await statusResponse.json();
                    currentVersion = status.version;
                } catch (error) {
                    console.error('Error fetching sheet version:', error);
                }
            }

            // Render the grid
            function renderGrid(rows, cols) {
                grid.style.setProperty('--rows', rows);
                grid.style.setProperty('--cols', cols);
                grid.innerHTML = '';

                // Add corner cell (empty)
                const cornerCell = document.createElement('div');
                cornerCell.className = 'cell header-cell corner-header';
                grid.appendChild(cornerCell);

                // Add column headers (A, B, C...)
                for (let c = 1; c <= cols; c++) {
                    const colHeader = document.createElement('div');
                    colHeader.className = 'cell header-cell col-header';
                    colHeader.textContent = columnToLetter(c);
                    grid.appendChild(colHeader);
                }

                // Add rows with headers
                for (let r = 1; r <= rows; r++) {
                    // Row header (1, 2, 3...)
                    const rowHeader = document.createElement('div');
                    rowHeader.className = 'cell header-cell row-header';
                    rowHeader.textContent = r;
                    grid.appendChild(rowHeader);

                    // Regular cells
                    for (let c = 1; c <= cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.dataset.name = columnToLetter(c) + r;
                        cell.addEventListener('click', () => selectCell(cell));
                        grid.appendChild(cell);
                    }
                }
            }

            // Convert column number to letter (1=A, 2=B, etc.)
            function columnToLetter(col) {
                let letter = '';
                while (col > 0) {
                    col--;
                    letter = String.fromCharCode(65 + (col % 26)) + letter;
                    col = Math.floor(col / 26);
                }
                return letter;
            }

            // Update cell values from data
            function updateCellValues(cells) {
                cells.forEach(cellData => {
                    if (!cellData.name) return;

                    const selector = `.cell[data-name="${cellData.name}"]`;
                    const cellElement = document.querySelector(selector);
                    if (cellElement) {
                        cellElement.textContent = cellData.value;
                        if (cellData.error) {
                            cellElement.classList.add('error');
                        } else {
                            cellElement.classList.remove('error');
                        }
                        cellElement.dataset.formula = cellData.formula || '';
                    }
                });
            }

            // Select a cell
            function selectCell(cell) {
                // If we're in formula build mode, don't change selection
                if (isFormulaBuildMode && formulaBeingBuilt && cell !== formulaBeingBuilt) {
                    return;
                }
                
                // If we're in range selection mode, don't change the primary selection
                if (isRangeSelectionMode) {
                    rangeEndCell = cell;
                    highlightSelectedRange();
                    return;
                }
                
                // Deselect previously selected cell
                if (selectedCell) {
                    selectedCell.classList.remove('selected');
                    // If we were in edit mode, exit it first
                    if (selectedCell.isContentEditable) {
                        exitCellEditMode(selectedCell);
                    }
                }

                // Select new cell
                cell.classList.add('selected');
                selectedCell = cell;
                selectedCellDisplay.textContent = cell.dataset.name;

                // Update display bar with cell value and formula
                displayBar.textContent = `Value: ${cell.textContent || '0'}`;
                if (cell.dataset.formula) {
                    displayBar.textContent += ` | Formula: ${cell.dataset.formula}`;
                }

                // Update formula bar but don't focus it automatically
                formulaBar.value = cell.dataset.formula || '';
            }

            // Make a cell editable for direct editing
            function enterCellEditMode(cell) {
                if (cell) {
                    cell.contentEditable = true;
                    cell.classList.add('editing');
                    cell.focus();
                    
                    // Select all text in the cell for easy replacement
                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.selectNodeContents(cell);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Store original text in case user cancels
                    cell.dataset.originalText = cell.textContent;
                    
                    // If user types "=", we'll enter formula build mode
                    cell.addEventListener('input', handleCellInput);
                }
            }
            
            // Handler for cell input - checks for formula build mode
            function handleCellInput(e) {
                const cell = e.target;
                const text = cell.textContent.trim();
                
                // If the cell starts with "=", enter formula build mode
                if (text === "=") {
                    isFormulaBuildMode = true;
                    formulaBeingBuilt = cell;
                    displayBar.textContent = "Building formula: Click on cells to add them to your formula";
                } else if (!text.startsWith('=')) {
                    // If no longer starting with =, exit formula build mode
                    isFormulaBuildMode = false;
                    formulaBeingBuilt = null;
                }
                
                // Check for function names that will trigger range selection
                const functionMatch = text.match(/^=?\s*(sum|min|max|avg|stdev|copy)\s*$/i);
                if (functionMatch) {
                    functionMode = functionMatch[1].toUpperCase();
                    displayBar.textContent = `Building ${functionMode} formula. Press Shift+Arrow keys to select range.`;
                }
            }

            // Exit edit mode for a cell
            function exitCellEditMode(cell) {
                if (cell && cell.isContentEditable) {
                    // Remove the input handler
                    cell.removeEventListener('input', handleCellInput);
                    
                    // Save the value from the cell
                    let newValue = cell.textContent.trim();
                    cell.contentEditable = false;
                    cell.classList.remove('editing');
                    
                    // Reset formula build mode
                    isFormulaBuildMode = false;
                    formulaBeingBuilt = null;
                    
                    // Update the formula bar with the new value
                    formulaBar.value = newValue;
                    // If the value starts with =, remove it before submitting
                    if (newValue.startsWith('=')) {
                        // newValue = newValue.substring(1);
                        // console.log("Formula bar updated with:", newValue);
                        newValue = newValue.substring(1);
                        // console.log("Formula bar updated with:", newValue);
                        
                    }
                    console.log("Processing value:", newValue);
                    const regex = /^(SUM|MIN|MAX|AVG|STDEV|COPY)([A-Z]{1,3}\d{1,3})([A-Z]{1,3}\d{1,3})$/i;
                    const match = newValue.match(regex);
                    console.log("Regex match result:", match);
                    if (match) {
                        // Extract and convert to uppercase
                        const func = match[1].toUpperCase();
                        const cell1 = match[2].toUpperCase();
                        const cell2 = match[3].toUpperCase();
                        let range = getCellRangeNotation(cell1, cell2);
                        console.log("Range notation:", range);
                        console.log("Extracted values:", { func, cell1, cell2 });
                        // Rebuild the formula string as FUNCTION(cell1:cell2)
                        newValue = `${func}(${range})`;
                        console.log("New formula:", newValue);
                    }
                    // Submit the value to the server
                    submitCellValue(cell.dataset.name, newValue);
                }
            }

            // Submit a cell value to the server
            async function submitCellValue(cellName, formula) {
                console.log("Submitting value:", formula);
                try {
                    const response = await fetch('/api/update_cell', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            cell: cellName,
                            rhs: formula,
                            version: currentVersion
                        })
                    });

                    const result = await response.json();

                    if (result.status.startsWith('Conflict:')) {
                        // Handle version conflict
                        displayBar.textContent = result.status;
                        if (result.needs_refresh) {
                            await fetchSheetData();
                        }
                    } else if (result.status.includes("cycle") || 
                              result.status.includes("circular") || 
                              result.status.includes("invalid command") || 
                              result.status.includes("Invalid") || 
                              result.status.includes("Error")) {
                        
                        // Show simple alert instead of modal popup
                        alert(result.status);
                        
                        // Clear the incorrect formula from the cell
                        const cellElement = document.querySelector(`.cell[data-name="${cellName}"]`);
                        if (cellElement) {
                            // Reset to previous valid value
                            await fetchSheetData(); // Refresh to get the last valid state
                            
                            // Clear the formula bar as well
                            formulaBar.value = '';
                        }
                        
                        // Update display bar with the error
                        displayBar.textContent = result.status;
                    } else {
                        // Update was successful
                        currentVersion = result.version;
                        
                        // Refresh the sheet to show all updates
                        fetchSheetData();

                        // Update the display bar
                        displayBar.textContent = `Value: ${result.value !== undefined ? result.value : ''}`;
                        if (formula) {
                            displayBar.textContent += ` | Formula: ${formula}`;
                        }
                    }
                } catch (error) {
                    console.error('Error updating cell:', error);
                    alert(`Error updating cell: ${error.message}`);
                    displayBar.textContent = `Error updating cell: ${error.message}`;
                }
            }

            // Function to show error pop-up
            function showErrorPopup(message) {
                const errorModal = document.getElementById('error-modal');
                const errorMessage = document.getElementById('error-message');
                
                // Set message content
                errorMessage.textContent = message;
                
                // Show modal with shake animation
                errorModal.classList.remove('hidden');
                errorModal.querySelector('.modal-content').classList.add('shake');
                
                // Focus the OK button for accessibility
                document.getElementById('error-ok-button').focus();
            }

            // Add double-click handler to enter edit mode
            grid.addEventListener('dblclick', function(e) {
                const cell = e.target.closest('.cell');
                if (cell && !cell.classList.contains('header-cell')) {
                    selectCell(cell);
                    enterCellEditMode(cell);
                }
            });

            // Modify the cell click handler to support formula building
            grid.addEventListener('click', function(e) {
                const cell = e.target.closest('.cell');
                if (!cell || cell.classList.contains('header-cell')) return;
                
                // If we're in formula build mode and clicked a different cell than the one we're editing
                if (isFormulaBuildMode && formulaBeingBuilt && cell !== formulaBeingBuilt) {
                    // Prevent the default selection behavior
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Get the clicked cell's name (e.g., "A1")
                    const cellReference = cell.dataset.name;
                    
                    // Insert the cell reference at the current cursor position or append it
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    
                    // Create text node with the cell reference
                    const referenceNode = document.createTextNode(cellReference);
                    range.insertNode(referenceNode);
                    
                    // Move cursor after the inserted text
                    range.setStartAfter(referenceNode);
                    range.setEndAfter(referenceNode);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Keep focus on the formula cell
                    formulaBeingBuilt.focus();
                    
                    return;
                }
                
                // Normal cell selection
                selectCell(cell);
            });

            // Also add formula building mode to the formula bar
            formulaBar.addEventListener('input', function(e) {
                const text = formulaBar.value.trim();
                
                if (text === "=") {
                    isFormulaBuildMode = true;
                    displayBar.textContent = "Building formula: Click on cells to add them to your formula";
                } else if (!text.startsWith('=')) {
                    isFormulaBuildMode = false;
                }
            });
            
            // Handle clicks when formula bar has focus and we're in formula building mode
            grid.addEventListener('click', function(e) {
                const cell = e.target.closest('.cell');
                if (!cell || cell.classList.contains('header-cell')) return;
                
                if (isFormulaBuildMode && document.activeElement === formulaBar) {
                    // Prevent default cell selection
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Get cursor position in formula bar
                    const cursorPos = formulaBar.selectionStart;
                    
                    // Insert cell reference at cursor position
                    const cellRef = cell.dataset.name;
                    const before = formulaBar.value.substring(0, cursorPos);
                    const after = formulaBar.value.substring(cursorPos);
                    
                    formulaBar.value = before + cellRef + after;
                    
                    // Set cursor position after the inserted reference
                    formulaBar.selectionStart = cursorPos + cellRef.length;
                    formulaBar.selectionEnd = cursorPos + cellRef.length;
                    
                    // Keep focus on formula bar
                    formulaBar.focus();
                }
            });

            // Enhance keyboard navigation to handle direct editing
            document.addEventListener('keydown', function (e) {
                if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    // Assume the undo is handled on the server side.
                    // If sheetData.undo_stack is empty, show "no undo".
                    // Otherwise, call the /api/undo endpoint.
                    if (!sheetData || !sheetData.undo_stack || sheetData.undo_stack.length === 0) {
                        displayBar.textContent = "no undo";
                    } else {
                        fetch('/api/undo', { method: 'POST' })
                            .then(response => response.json())
                            .then(data => {
                                displayBar.textContent = data.status;
                                fetchSheetData(); // refresh the grid
                            })
                            .catch(error => {
                                console.error("Undo error:", error);
                                displayBar.textContent = "Error performing undo";
                            });
                    }
                    return;
                }

                if (isFormulaBuildMode) {
                    if (e.key === 'Enter') {
                        // Finish building formula
                        if (formulaBeingBuilt) {
                            exitCellEditMode(formulaBeingBuilt);
                        } else if (document.activeElement === formulaBar) {
                            // Submit formula from formula bar
                            const formula = formulaBar.value.trim();
                            if (selectedCell) {
                                submitCellValue(selectedCell.dataset.name, formula);
                            }
                        }
                        isFormulaBuildMode = false;
                        return;
                    }
                    
                    if (e.key === 'Escape') {
                        // Cancel formula building
                        isFormulaBuildMode = false;
                        if (formulaBeingBuilt) {
                            formulaBeingBuilt.textContent = formulaBeingBuilt.dataset.originalText || '';
                            exitCellEditMode(formulaBeingBuilt);
                        }
                        displayBar.textContent = "";
                        return;
                    }
                }

                if (!selectedCell) return;

                const currentRow = parseInt(selectedCell.dataset.row);
                const currentCol = parseInt(selectedCell.dataset.col);
                let newRow = currentRow;
                let newCol = currentCol;

                // If we're already editing a cell directly
                if (selectedCell.isContentEditable) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        // Save changes and exit edit mode
                        exitCellEditMode(selectedCell);
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'Escape') {
                        // Cancel editing
                        selectedCell.textContent = selectedCell.dataset.originalText || '';
                        selectedCell.contentEditable = false;
                        selectedCell.classList.remove('editing');
                        e.preventDefault();
                        return;
                    }
                    // Let all other keys be handled normally when editing
                    return;
                }

                // When not in edit mode, handle different key interactions
                if (e.key === 'Enter' || e.key === 'F2') {
                    // Enter or F2 should enter edit mode for the cell
                    if (document.activeElement === formulaBar) {
                        // If the formula bar already has focus, submit the value
                        if (e.key === 'Enter') {
                            const formula = formulaBar.value.trim();
                            submitCellValue(selectedCell.dataset.name, formula);
                        }
                    } else {
                        // Otherwise, enter edit mode on the cell
                        enterCellEditMode(selectedCell);
                    }
                    e.preventDefault();
                    return;
                }
                
                // Start editing immediately on any printable character key
                if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    // If a letter, number or symbol is pressed, enter edit mode and start with that character
                    enterCellEditMode(selectedCell);
                    // Clear the cell content since we want to replace it
                    selectedCell.textContent = '';
                    // Let the key event continue to insert the character
                    return;
                }
                
                // Navigate with arrow keys (when formula bar is not focused)
                if (document.activeElement !== formulaBar) {
                    switch (e.key) {
                        case 'ArrowUp':
                            newRow = Math.max(1, currentRow - 1);
                            e.preventDefault(); 
                            break;
                        case 'ArrowDown':
                            newRow = Math.min(sheetData.rows, currentRow + 1);
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            newCol = Math.max(1, currentCol - 1);
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            newCol = Math.min(sheetData.cols, currentCol + 1);
                            e.preventDefault();
                            break;
                        case 'Tab':
                            // Tab moves right, Shift+Tab moves left
                            if (e.shiftKey) {
                                newCol = Math.max(1, currentCol - 1);
                            } else {
                                newCol = Math.min(sheetData.cols, currentCol + 1);
                            }
                            e.preventDefault();
                            break;
                    }

                    if (newRow !== currentRow || newCol !== currentCol) {
                        const newCellSelector = `.cell[data-row="${newRow}"][data-col="${newCol}"]`;
                        const newCell = document.querySelector(newCellSelector);
                        if (newCell) {
                            selectCell(newCell);
                        }
                    }
                }
            });

            // Handle formula submission
            formulaBar.addEventListener('keydown', async function (e) {
                if (e.key === 'Enter' && selectedCell) {
                    const cellName = selectedCell.dataset.name;
                    const formula = formulaBar.value.trim();

                    try {
                        const response = await fetch('/api/update_cell', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                cell: cellName,
                                rhs: formula,
                                version: currentVersion // Send current version
                            })
                        });

                        const result = await response.json();

                        if (result.status.startsWith('Conflict:')) {
                            // Handle version conflict
                            displayBar.textContent = result.status;
                            if (result.needs_refresh) {
                                await fetchSheetData(); // Refresh to get latest data
                            }
                        } else {
                            // Update was successful
                            currentVersion = result.version; // Update our version

                            // Refresh the sheet to show all updates
                            fetchSheetData();

                            // Update the display bar
                            if (result.value !== undefined) {
                                displayBar.textContent = `Value: ${result.value}`;
                                if (formula) {
                                    displayBar.textContent += ` | Formula: ${formula}`;
                                }
                            }

                            // Clear the formula bar
                            formulaBar.value = '';
                        } 
                    } catch (error) {
                        console.error('Error updating cell:', error);
                        alert('Failed to update cell');
                    }
                }
            });

            // Add visibility change handler to pause/resume polling when tab is hidden/visible
            document.addEventListener('visibilitychange', function () {
                if (document.hidden) {
                    isPolling = false;
                } else {
                    isPolling = true;
                    startPolling();
                }
            });

            // Handle save button click
            saveButton.addEventListener('click', async function () {
                // First check if this is a loaded sheet
                const sheetInfoResponse = await fetch('/api/sheet_info');
                const sheetInfo = await sheetInfoResponse.json();
                
                // For loaded sheets, directly overwrite using the original path
                if (sheetInfo.is_loaded && sheetInfo.original_path) {
                    displayBar.textContent = "Updating existing spreadsheet file...";
                    
                    // Use the original path to save without prompting
                    const saveResponse = await fetch(`/api/save?filename=${encodeURIComponent(sheetInfo.original_path)}`, {
                        method: 'POST'
                    });
                    
                    const result = await saveResponse.json();
                    if (result.status === 'ok') {
                        displayBar.textContent = `Spreadsheet saved to ${sheetInfo.original_path}`;
                    } else {
                        throw new Error(result.message || 'Failed to save spreadsheet');
                    }
                    return;
                }
                
                // For new sheets, always ask where to save
                if ('showSaveFilePicker' in window) {
                    displayBar.textContent = "Select where to save your spreadsheet...";

                    // Set up file save options with .bin.gz extension
                    const opts = {
                        suggestedName: 'spreadsheet.bin.gz',
                        types: [{
                            description: 'Compressed Spreadsheet File',
                            accept: { 'application/gzip': ['.bin.gz'] }
                        }]
                    };

                    try {
                        // Show save file picker to get user's chosen location
                        const fileHandle = await window.showSaveFilePicker(opts);
                        const fileName = fileHandle.name;
                        
                        // Get complete path if possible (depends on browser security)
                        let filePath = fileName;
                        
                        displayBar.textContent = "Saving spreadsheet...";
                        
                        // Export the spreadsheet data
                        const exportResponse = await fetch('/api/export', {
                            method: 'POST'
                        });
                        
                        if (!exportResponse.ok) {
                            throw new Error('Failed to export spreadsheet data');
                        }
                        
                        // Get the spreadsheet data as a blob
                        const blob = await exportResponse.blob();
                        
                        // Write to the selected file using the File System Access API
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        // Now update the original_path in the server state
                        // This makes future saves go directly to this location
                        const saveResponse = await fetch(`/api/save?filename=${encodeURIComponent(filePath)}`, {
                            method: 'POST'
                        });
                        
                        const result = await saveResponse.json();
                        if (result.status !== 'ok') {
                            console.warn("Saved file successfully but failed to update original path:", result.message);
                        }

                        displayBar.textContent = `Spreadsheet saved to ${filePath}`;
                    } catch (pickErr) {
                        // User may have cancelled
                        if (pickErr.name === 'AbortError') {
                            displayBar.textContent = "Save operation cancelled.";
                            return;
                        }
                        throw pickErr;
                    }
                } else {
                    // Fallback for browsers without File System Access API
                    const filename = prompt("Enter filename to save spreadsheet:", "spreadsheet.bin.gz");
                    if (!filename) {
                        displayBar.textContent = "Save operation cancelled.";
                        return;
                    }

                    displayBar.textContent = "Preparing download...";
                    
                    // Export the spreadsheet data
                    const exportResponse = await fetch('/api/export', {
                        method: 'POST'
                    });

                    if (!exportResponse.ok) {
                        throw new Error('Failed to export spreadsheet');
                    }

                    // Get blob and trigger download
                    const blob = await exportResponse.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename.endsWith('.bin.gz') ? filename : `${filename}.bin.gz`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Try to update the original path for future saves
                    const fullFilename = filename.endsWith('.bin.gz') ? filename : `${filename}.bin.gz`;
                    const saveResponse = await fetch(`/api/save?filename=${encodeURIComponent(fullFilename)}`, {
                        method: 'POST'
                    });

                    displayBar.textContent = `Spreadsheet downloaded as ${fullFilename}`;
                }
            });

            // Add download functionality
            const downloadButton = document.getElementById('download-button');
            const downloadDropdown = document.getElementById('download-dropdown');
            const downloadCsv = document.getElementById('download-csv');
            const downloadXlsx = document.getElementById('download-xlsx');

            // Toggle dropdown when download button is clicked
            downloadButton.addEventListener('click', function () {
                downloadDropdown.classList.toggle('hidden');
            });

            // Hide dropdown when clicking elsewhere
            document.addEventListener('click', function (event) {
                if (!event.target.matches('#download-button')) {
                    if (!downloadDropdown.classList.contains('hidden')) {
                        downloadDropdown.classList.add('hidden');
                    }
                }
            });

            // Handle CSV download
            downloadCsv.addEventListener('click', async function (e) {
                e.preventDefault();
                displayBar.textContent = "Preparing CSV download...";

                try {
                    const response = await fetch('/api/download/csv');

                    if (!response.ok) {
                        throw new Error('Failed to generate CSV');
                    }

                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'spreadsheet.csv';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    displayBar.textContent = "CSV downloaded successfully";
                } catch (error) {
                    console.error('Error downloading CSV:', error);
                    displayBar.textContent = `Error: ${error.message}`;
                }

                downloadDropdown.classList.add('hidden');
            });

            // Handle XLSX download
            downloadXlsx.addEventListener('click', async function (e) {
                e.preventDefault();
                displayBar.textContent = "Preparing Excel download...";

                try {
                    const response = await fetch('/api/download/xlsx');

                    if (!response.ok) {
                        throw new Error('Failed to generate Excel file');
                    }

                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'spreadsheet.xlsx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    displayBar.textContent = "Excel file downloaded successfully";
                } catch (error) {
                    console.error('Error downloading Excel:', error);
                    displayBar.textContent = `Error: ${error.message}`;
                }

                downloadDropdown.classList.add('hidden');
            });

            // Home button click handler
            homeButton.addEventListener('click', function () {
                // Extract username from the current URL path
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                if (pathParts.length > 0) {
                    const username = pathParts[0];
                    window.location.href = `/${username}`;
                } else {
                    // Fallback in case we can't determine the username
                    window.location.href = '/';
                }
            });

            // Initialize the grid
            fetchSheetData();

            // Add save modal functionality
            const saveModal = document.getElementById('save-modal');
            const saveForm = document.getElementById('save-form');
            const filenameInput = document.getElementById('filename-input');
            const confirmSaveBtn = document.getElementById('confirm-save');
            const cancelSaveBtn = document.getElementById('cancel-save');
            
            // Modified save button click handler
            saveButton.addEventListener('click', async function() {
                // First check if this is a loaded sheet
                const sheetInfoResponse = await fetch('/api/sheet_info');
                const sheetInfo = await sheetInfoResponse.json();
                
                // For loaded sheets with an original path, save directly
                if (sheetInfo.is_loaded && sheetInfo.original_path) {
                    displayBar.textContent = "Updating existing spreadsheet...";
                    
                    // Use the original path to save without prompting
                    const saveResponse = await fetch(`/api/save?filename=${encodeURIComponent(sheetInfo.original_path)}`, {
                        method: 'POST'
                    });
                    
                    const result = await saveResponse.json();
                    if (result.status === 'ok') {
                        displayBar.textContent = `Spreadsheet saved successfully!`;
                    } else {
                        displayBar.textContent = `Error: ${result.message || 'Failed to save spreadsheet'}`;
                    }
                    return;
                }
                
                // For new sheets, show the save dialog
                saveModal.classList.remove('hidden');
                filenameInput.focus();
            });
            
            // Handle save form submission
            saveForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const filename = filenameInput.value.trim();
                if (!filename) {
                    alert('Please enter a filename');
                    return;
                }
                
                displayBar.textContent = "Saving spreadsheet...";
                saveModal.classList.add('hidden');
                
                try {
                    // Save with the specified name to the user's directory
                    const formData = new FormData();
                    formData.append('name', filename);
                    
                    const saveResponse = await fetch('/api/save_with_name', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await saveResponse.json();
                    if (result.status === 'ok') {
                        displayBar.textContent = `Spreadsheet saved as ${filename}`;
                    } else {
                        throw new Error(result.message || 'Failed to save spreadsheet');
                    }
                } catch (error) {
                    console.error('Error saving spreadsheet:', error);
                    displayBar.textContent = `Error: ${error.message}`;
                }
            });
            
            // Cancel save operation
            cancelSaveBtn.addEventListener('click', function() {
                saveModal.classList.add('hidden');
            });

            // Function to highlight a range of cells
            function highlightSelectedRange() {
                // Clear previous range highlighting
                document.querySelectorAll('.cell.in-range').forEach(cell => {
                    cell.classList.remove('in-range');
                });
                
                if (!rangeStartCell || !rangeEndCell) return;
                
                // Get the coordinates of start and end cells
                const startRow = parseInt(rangeStartCell.dataset.row);
                const startCol = parseInt(rangeStartCell.dataset.col);
                const endRow = parseInt(rangeEndCell.dataset.row);
                const endCol = parseInt(rangeEndCell.dataset.col);
                
                // Determine the actual top-left and bottom-right cells
                const topRow = Math.min(startRow, endRow);
                const bottomRow = Math.max(startRow, endRow);
                const leftCol = Math.min(startCol, endCol);
                const rightCol = Math.max(startCol, endCol);
                
                // Highlight all cells in the range
                for (let row = topRow; row <= bottomRow; row++) {
                    for (let col = leftCol; col <= rightCol; col++) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('in-range');
                        }
                    }
                }
                
                // Update the selected cell display to show the range
                const startName = rangeStartCell.dataset.name;
                const endName = rangeEndCell.dataset.name;
                selectedCellDisplay.textContent = `${startName}:${endName}`;
            }
            
            // Function to clear range selection
            function clearRangeSelection() {
                isRangeSelectionMode = false;
                rangeStartCell = null;
                rangeEndCell = null;
                functionMode = null;
                
                // Remove highlighting from all cells
                document.querySelectorAll('.cell.in-range').forEach(cell => {
                    cell.classList.remove('in-range');
                });
            }
            
            // Helper function to convert a cell name (e.g. "B2") into coordinates {row, col}
            function cellNameToCoordinates(cellName) {
                const match = cellName.match(/^([A-Z]+)(\d+)$/);
                if (!match) return null;
                const letters = match[1];
                const row = parseInt(match[2]);
                let col = 0;
                for (let i = 0; i < letters.length; i++) {
                    col = col * 26 + (letters.charCodeAt(i) - 64); // 'A' is 65 so A=1
                }
                return { row, col };
            }

            // Updated getCellRangeNotation function accepts either DOM elements or cell name strings.
            function getCellRangeNotation(start, end) {
                let startCoords, endCoords;
                
                // If start is a string, derive coordinates from it; otherwise from its dataset
                if (typeof start === 'string') {
                    startCoords = cellNameToCoordinates(start);
                } else {
                    startCoords = {
                        row: parseInt(start.dataset.row),
                        col: parseInt(start.dataset.col)
                    };
                }
                
                // Same for the end parameter
                if (typeof end === 'string') {
                    endCoords = cellNameToCoordinates(end);
                } else {
                    endCoords = {
                        row: parseInt(end.dataset.row),
                        col: parseInt(end.dataset.col)
                    };
                }
                
                if (!startCoords || !endCoords) return '';
                
                // Determine the actual top-left and bottom-right cells.
                const topRow = Math.min(startCoords.row, endCoords.row);
                const bottomRow = Math.max(startCoords.row, endCoords.row);
                const leftCol = Math.min(startCoords.col, endCoords.col);
                const rightCol = Math.max(startCoords.col, endCoords.col);
                
                // Convert the column numbers back to letters using your existing function.
                const topLeft = columnToLetter(leftCol) + topRow;
                const bottomRight = columnToLetter(rightCol) + bottomRow;
                
                return `${topLeft}:${bottomRight}`;
            }

            // Function to update the formula with the current range
            function updateFunctionFormula() {
                if (!functionMode || !rangeStartCell || !rangeEndCell) return;
                
                const formulaCell = document.querySelector('.cell.editing');
                if (formulaCell) {
                    const range = getCellRangeNotation(rangeStartCell, rangeEndCell);
                    // Update the cell with the formula so far (without closing parenthesis)
                    formulaCell.textContent = `=${functionMode}(${range}`;
                }
            }
        });
    </script>
</body>

</html>